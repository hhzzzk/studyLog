## Programmable Rendering Pipeline

```markdown
Programmable Rendering Pipeline(프로그래밍 가능한 랜더링 파이프라인)은 
그래픽스 파이프라인을 __개발자가 직접 커스터마이징__할 수 있는 기술입니다. 
기존의 고정 랜더링 파이프라인과는 달리, 
__쉐이더 프로그래밍__을 통해 개발자가 
그래픽스 __파이프라인의 각 단계를 프로그램으로 제어__할 수 있습니다.

프로그래머블 랜더링 파이프라인은 주로 그래픽스 API인 OpenGL의 버전 2.0 이상과 DirectX의 버전 9 이상부터 지원되며, 쉐이더 언어를 사용하여 개발자가 작성한 코드가 그래픽스 하드웨어에서 실행됩니다. 프로그래머블 랜더링 파이프라인은 다음과 같은 주요 특징을 갖습니다:

1. 쉐이더 프로그래밍: 개발자는 버텍스 쉐이더(Vertex Shader)와 프래그먼트 쉐이더(Fragment Shader)를 작성하여 렌더링 파이프라인의 각 단계를 직접 제어할 수 있습니다. 쉐이더는 그래픽스 하드웨어에서 
	__병렬__로 실행되어 높은 성능을 제공합니다.

2. 유연한 작업 흐름: 개발자는 쉐이더를 사용하여 정점 데이터의 변환, 조명, 재질, 그림자, 텍스처 매핑, 알파 블렌딩 등 다양한 그래픽스 작업을 수행할 수 있습니다. 이로 인해 더 다양하고 현실적인 시각적 효과를 구현할 수 있습니다.

3. 확장 가능성: 쉐이더 프로그래밍은 렌더링 파이프라인의 다양한 단계에서 사용될 수 있습니다. 버텍스 쉐이더와 프래그먼트 쉐이더 외에도, 기하 쉐이더(Geometry Shader), 헐(템) 쉐이더(Tessellation Shader) 등 다양한 종류의 쉐이더를 사용할 수 있습니다.

4. 시각적 품질 개선: 프로그래머블 랜더링 파이프라인을 사용하면 개발자는 조명, 그림자, 반사, 굴절 등의 복잡한 시각 효과를 더욱 정교하게 조정할 수 있습니다. 이로 인해 그래픽스의 시각적 품질이 향상됩니다.

프로그래머블 랜더링 파이프라인은 그래픽스 애플리케이션 및 게임에서 널리 사용되며, 높은 수준의 그래픽스 품질과 성능을 제공합니다.

```







## GLSL

```markdown
GLSL은 OpenGL Shading Language의 약자로, 
그래픽스 애플리케이션에서 쉐이더 프로그래밍을 위해 사용되는 고급 언어입니다. 

- GLSL은 GPU에서 실행되는 쉐이더 코드를 작성하기 위해 설계되었습니다.

GLSL은 C 프로그래밍 언어를 기반으로 하며, C와 유사한 문법을 가지고 있습니다. 
그러나 GLSL은 그래픽스 파이프라인의 
특정 단계(버텍스 쉐이더, 프래그먼트 쉐이더 등)에서 실행되는 코드를 작성하는 데에 특화되어 있습니다.


# GLSL을 사용하면 다음과 같은 작업을 수행할 수 있습니다:

버텍스 쉐이더: 정점 데이터의 변환, 조명 계산, 텍스처 좌표 계산 등을 수행합니다.

프래그먼트 쉐이더: 래스터화된 픽셀에 대한 작업을 처리하고, 픽셀의 색상 계산, 조명 모델링, 텍스처 매핑, 그림자 효과 등을 수행합니다.

#
GLSL은 GPU의 병렬 처리 능력을 활용하여 그래픽스 작업을 효율적으로 처리할 수 있도록 설계되었습니다. 개발자는 GLSL을 사용하여 그래픽스 파이프라인의 각 단계에서 발생하는 연산을 프로그래밍적으로 제어할 수 있으며, 이를 통해 다양한 시각적 효과와 고성능의 그래픽스를 구현할 수 있습니다.
```



## Overview of Rendering Pipeline

```markdown
렌더링 파이프라인은 컴퓨터 그래픽스에서 시각적인 이미지를 생성하기 위해 필요한 모든 단계와 구성 요소를 포함한 구조입니다. 이는 대화형 컴퓨터 그래픽스를 위한 핵심 요소로 볼 수 있습니다.

먼저, 우리는 고정 렌더링 파이프라인에 초점을 맞춥니다. 고정 렌더링 파이프라인은 상태 머신으로 동작하며, 그래픽스 파이프라인의 각 단계를 미리 정의된 방식으로 처리합니다. 이는 렌더링 파이프라인을 프로그래밍 가능한 단계로 수정하기 전에 사용되던 전통적인 방식입니다.

렌더링 파이프라인에서 이미지를 형성하기 위해서는 필요한 모든 정보가 명시되어야 합니다. 예를 들어, 객체의 위치와 모양, 조명 정보, 재질 속성 등을 파이프라인에 명시해야 합니다. 이러한 정보들은 렌더링 파이프라인의 다양한 단계에서 사용되어 최종적으로 시각적인 이미지가 생성됩니다.

# CPU와 GPU가 협력하여 고품질의 그래픽스를 생성하는 것이 대화형(interactive) 컴퓨터 그래픽스의 핵심 개념

# 렌더링 파이프라인에서 객체의 위치와 모양, 조명 정보, 재질 속성 등과 같은 관련 정보는 CPU에서 GPU로 전송되어 처리
```

```markdown
Programmable Rendering Pipeline은 기존의 고정 랜더링 파이프라인에서 vertex 프로세서와 fragment 프로세서에서 수행되던 작업을 프로그래머가 원하는 대로 조정할 수 있는 기능을 제공합니다.

고정 랜더링 파이프라인에서는 렌더링 과정의 각 단계가 미리 정의되어 있으며, 프로그래머는 이러한 단계에서 수행되는 작업을 변경하기 어렵습니다. 예를 들어, vertex 프로세서는 변환 및 조명 계산을 담당하고, fragment 프로세서는 픽셀의 색상 계산과 조명 모델 적용을 담당합니다. 
    이러한 작업은 하드웨어에 의해 미리 정의되어 있어 
    프로그래머는 이러한 고정된 동작을 수정할 수 없습니다.

#
하지만 Programmable Rendering Pipeline에서는 프로그래머가 vertex 쉐이더와 fragment 쉐이더를 사용하여 작업을 직접 정의할 수 있습니다. 
이 쉐이더는 GPU에서 실행되는 작은 프로그램으로, 
프로그래머는 이를 사용하여 렌더링 파이프라인의 동작을 원하는 대로 커스터마이즈할 수 있습니다. 
예를 들어, vertex 쉐이더를 사용하여 변환 행렬 계산이나 조명 계산을 수정할 수 있고, 
fragment 쉐이더를 사용하여 픽셀의 색상 계산이나 텍스처 매핑을 변경할 수 있습니다.


이렇게 Programmable Rendering Pipeline은 프로그래머가 렌더링 파이프라인의 동작을 조정하고 원하는 형태로 변형할 수 있는 유연성을 제공합니다. 이를 통해 그래픽스 애플리케이션의 시각적 품질과 다양성을 크게 향상시킬 수 있습니다.
```





```markdown
# Per-vertex Lighting(정점별 조명)과 Per-pixel Lighting(픽셀별 조명)은 
랜더링 파이프라인에서 조명 계산이 어느 단계에서 이루어지는지에 따라 차이가 있습니다.

고정 랜더링 파이프라인에서는 정점별 조명만 지원합니다. 
__조명 계산은 정점 프로세서__에서만 수행됩니다. 
따라서 광원의 계산이 정점 위치에 따라 한 번만 이루어지며, 나머지 픽셀은 보간에 의해 이 값을 공유합니다. 이로 인해 조명 계산이 픽셀 수준에서 이루어지지 않으므로 하이라이트와 같은 광택 효과가 더 거친 삼각형에서는 무시될 수 있습니다.

#
반면, 프로그램 가능한 랜더링 파이프라인에서는 픽셀별 조명을 지원합니다. 
조명 계산을 프래그먼트 프로세서에서 수행할 수 있도록 프로그래밍할 수 있습니다. 
이를 통해 __픽셀 수준에서 조명 계산을 수행__하고 
광택 효과와 같은 광원으로부터의 반사를 더 정확하게 나타낼 수 있습니다. 
삼각형의 조명 계산이 프래그먼트 단계에서 이루어지므로 
조명 계산에 대한 정보가 픽셀별로 고유하게 적용됩니다. 
이는 좀 더 섬세한 조명 효과와 함께 거친 삼각형에서도 광택 효과를 포함한 조명을 나타낼 수 있게 해줍니다.
```



```markdown
glCreateShader: 새로운 쉐이더 객체를 생성합니다.
glShaderSource: 쉐이더 객체에 GLSL 소스 코드를 로드합니다.
glCompileShader: 쉐이더 객체를 컴파일합니다.
glAttachShader : 쉐이더 객체를 쉐이더 프로그램에 연결합니다.
glLinkProgram: 쉐이더 프로그램을 링크하여 실행 가능한 프로그램으로 만듭니다.
glUseProgram: 쉐이더 프로그램을 현재 사용할 프로그램으로 지정합니다.
```



## I/O Storage Qualifiers in GLSL 1.2

```markdown
# Uniforms (유니폼):
   - 전체 쉐이더에서 동일한 값을 가지는 전역 변수를 선언합니다.
   - 쉐이더 전체에서 공유되는 상태를 나타내는 변수입니다.
렌더링 중에 변경되지 않는 값을 선언합니다.
정점 쉐이더와 프래그먼트 쉐이더에서 모두 사용할 수 있습니다.
읽기 전용입니다.
애플리케이션에서 API 명령을 통해 직접 초기화하거나 OpenGL에 의해 간접적으로 초기화될 수 있습니다.

# Attributes (어트리뷰트):
   - OpenGL에서 per-vertex 기반으로 정점 쉐이더로 전달되는 변수를 선언합니다.
   - 각 정점마다 다른 값을 가지는 변수입니다.
정점 쉐이더에서만 사용할 수 있습니다.
읽기 전용입니다.
OpenGL 정점 API를 통해 전달되거나 정점 배열의 일부로 전달됩니다.

# Varyings (베리잉):
   - 정점 쉐이더, 프래그먼트 쉐이더, 그리고 그들 사이의 고정된 기능 사이에 인터페이스를 제공하는 변수입니다.
   - 정점 쉐이더에서 생성되어 프래그먼트 쉐이더로 전달되는 변수입니다.
   - 베리잉은 정점과 프래그먼트 사이의 데이터를 보간(interpolation)하는 역할을 수행합니다.
정점 쉐이더에서 프래그먼트 쉐이더로 데이터를 전달하기 위해 사용됩니다.
정점 쉐이더에서는 읽기/쓰기가 가능하며, 프래그먼트 쉐이더에서는 읽기 전용입니다.

# 빌트인 변수?
또한, 내장 변수와 일반 변수를 사용할 수 있습니다:
- 내장 변수(빌트인): OpenGL에서 미리 정의된 상수와 유니폼 상태와 관련된 변수입니다.
	따로 선언하지 않았는데 쓸 수 있는 변수들
	gl_Position, gl_FrontFacing, gl_PointSize, (버텍스 쉐이더)
    gl_FragCoord, gl_FrontFacing, gl_PointCoord (프랙 쉐이더)6가지 있음
(((gl_Position은 vertex shader에서 사용되는 빌트인 변수로, 정점의 최종 위치를 지정하는 데 사용됩니다.
vertex shader에서 이 변수에 값을 할당하여 정점의 위치를 변환하고, 
이 위치는 이후의 변환과 래스터화 단계에서 사용됩니다.)))

///
- 일반 변수: 사용자가 정의한 변수로, 유니폼, 어트리뷰트, 베리잉 등의 유형으로 선언할 수 있습니다.

이러한 I/O 저장 한정자들을 사용하여 GLSL 쉐이더에서 데이터의 흐름과 상태를 조작하고 전달할 수 있습니다.

# 
이러한 저장 한정자들은 쉐이더에서 데이터를 선언하고 다른 쉐이더와의 상호작용을 제어하는 데 사용됩니다. 유니폼은 렌더링 중에 변경되지 않는 상수 값을 나타내며, 어트리뷰트는 정점마다 다른 값을 가지는 변수를 나타내고, 베리잉은 정점 쉐이더와 프래그먼트 쉐이더 간의 데이터 흐름을 담당합니다.

## 읽기 전용?
(((읽기 전용이라는 말은 GPU에서 해당 변수를 변경할 수 없으며, 
쉐이더 코드 내에서 해당 변수에 쓰기 작업을 수행할 수 없다는 의미입니다. 
변수의 값을 변경하려면 CPU 측에서 해당 변수를 업데이트하고 
그 값을 GPU로 전달해야 합니다. 
일반적으로 유니폼 변수는 CPU에서 값을 설정하고 그 값을 쉐이더로 전달하는 데 사용됩니다. 
GPU는 이러한 유니폼 변수의 값을 읽어와서 쉐이더 코드에서 사용할 수 있습니다. 
따라서, 유니폼 변수는 읽기 전용이므로 GPU에서 변경할 수 없고, 
CPU에서 해당 변수의 값을 업데이트하는 역할을 합니다.)))
```



https://www.youtube.com/watch?v=Bzv5202kfBA



```markdown
- 데이터 타입에서 double은 안씀
# 빌트인 함수들 설명

버텍스 쉐이더는 일반적으로 여러 개의 attribute를 입력으로 받고, varying 변수를 출력으로 내보냅니다. 또한, gl_Position과 같은 내장 변수들도 출력으로 사용됩니다. 이렇게 출력된 varying 변수들은 래스터라이저를 통해 버텍스 정보에서 픽셀 정보로 변환된 후, fragment 쉐이더의 입력으로 사용됩니다.

fragment 쉐이더는 래스터라이저를 거쳐서 입력된 varying 변수와 gl_FragCoord와 같은 내장 변수들을 입력으로 받습니다. fragment 쉐이더는 이들을 처리하여 최종적인 색상 값을 계산하고, 결과인 gl_FragColor를 출력으로 내보냅니다.

따라서, 버텍스 쉐이더와 fragment 쉐이더는 상호작용하여 그래픽스 파이프라인에서 각각의 역할을 수행하며, 입력과 출력에는 attribute, varying 변수 및 내장 변수들이 사용됩니다.

# 최종 output gl_FragColor???
((gl_FragColor라는 이름의 내장 변수가 있었습니다. 이 변수는 fragment 쉐이더에서 출력으로 사용되며, 해당 픽셀의 최종 색상 값을 지정하는 데에 쓰입니다.

하지만, 최신의 OpenGL 및 GLSL 버전에서는 더 이상 gl_FragColor를 내장 변수로 사용하지 않습니다. 대신, fragment 쉐이더에서 출력할 색상 값을 사용자 정의 출력 변수로 선언하고, 해당 변수를 직접 지정하여 출력해야 합니다))
```



## 빌트인 변수

```markdown
Built-in variables는 GLSL에서 사전에 정의된 변수로, OpenGL 렌더링 파이프라인의 다양한 단계에서 사용되는 특별한 변수입니다. 이러한 변수들은 사용자가 직접 선언하거나 정의하지 않고도 사용할 수 있습니다.

Built-in variables은 버텍스 쉐이더와 프래그먼트 쉐이더에서 각기 다른 목적으로 사용됩니다. 몇 가지 일반적인 Built-in 변수의 예는 다음과 같습니다:

# 버텍스 쉐이더의 Built-in 변수:

gl_Position: 버텍스 쉐이더의 출력 변수로, 버텍스의 변환된 위치를 저장합니다.
gl_PointSize: 점을 그릴 때 사용되는 점의 크기를 지정합니다.
gl_VertexID: 현재 처리 중인 버텍스의 인덱스를 저장합니다.

# 프래그먼트 쉐이더의 Built-in 변수:
gl_FragCoord: 프래그먼트의 화면 상의 위치를 저장합니다.
gl_FrontFacing: 현재 프래그먼트가 앞면인지(시계 방향) 뒷면인지(반시계 방향) 판별합니다.
gl_FragColor (이전 버전): 프래그먼트의 최종 색상 값을 저장합니다. (GLSL 1.20 이전)
gl_FragData (다중 출력): 프래그먼트의 여러 색상 버퍼에 대한 출력을 지원합니다.
```



## Specifying Uniform Data

유니폼 데이터 세팅

33페이지

```markdown
# glGetUniformLocation()
쉐이더 프로그램 내에서 유니폼 변수의 위치 검색하는데 사용
쉐이더 프로그램 식별자와 유니폼 변수의 이름을 매개변수로 받고
해당 유니폼 변수의 위치 반환함

# glUniform()
유니폼 변수에 값을 할당
유니폼 변수의 위치와 값을 매개변수로 받아 해당 위치에 값이 할당
함수의 이름에 따라 유니폼 변수의 타입과 크기
```

## Specifying Vertex Attribute Data

```markdown
 `glEnableVertexAttribArray()`: 버텍스 속성 배열을 활성화합니다. 이 함수를 사용하여 해당 속성을 사용하도록 설정합니다.

`glDisableVertexAttribArray()`: 버텍스 속성 배열을 비활성화합니다. 이 함수를 사용하여 해당 속성을 사용하지 않도록 설정합니다.

`glVertexAttribPointer()`: 버텍스 속성 데이터의 구조와 속성을 지정합니다. 이 함수를 사용하여 정점 데이터의 위치, 데이터 형식, 간격 등을 설정합니다.


`glVertexAttrib__I__Pointer()`: 정수 형식의 버텍스 속성 데이터의 구조와 속성을 지정합니다.
					- `glVertexAttribPointer()`와 유사하지만 정수 형식의 데이터에 사용됩니다.

이러한 함수들은 버텍스 데이터를 쉐이더 프로그램으로 전달하기 위해 사용됩니다. 예를 들어, `glVertexAttribPointer()` 함수를 사용하여 버텍스의 위치, 색상, 텍스처 좌표 등의 속성을 지정하고, `glEnableVertexAttribArray()` 함수를 사용하여 해당 속성을 활성화한 후, `glDrawArrays()` 함수를 사용하여 정점 데이터를 사용하여 도형을 그릴 수 있습니다.

이러한 함수들은 정점 속성 데이터를 버퍼 객체로부터 읽어오거나 직접 지정할 수 있으며, 정점 데이터의 형식과 구조를 지정하여 그래픽스 파이프라인에서 사용할 수 있도록 합니다.
```

