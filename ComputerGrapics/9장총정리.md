# 9장총정리

#  Texture Mapping, Blending

[TOC]

일단 텍스처 처리는 fragment 쉐이더에서 한다. cpu에서 vertex정보들은 pixel로 바뀐후임

# \Texture Mapping Basics

객체의 세부 사항을 표현하는 방법에 대해 설명하면, 

객체의 세부 사항을 표현하기 위해 일반적으로 텍스처 매핑 기술을 사용합니다. 



- 텍스처 매핑은 폴리곤 안쪽을 채우기 위해 이미지를 사용하는 기법입니다.

컴퓨터 그래픽스에서는 "텍스처"란 객체의 표면에 그림을 그리는 데 사용되는 대형 이미지 데이터 덩어리를 의미합니다.



## Texture Mapping

텍스처 매핑은 컴퓨터 그래픽스에서 사용되는 기술로, 

- 3D 객체의 표면에 이미지를 매핑하여 세부적인 외관을 부여하는 과정을 말합니다. 

  ​이를 통해 객체의 표면을 실제로 그림으로 "칠할" 수 있습니다.



텍스처 매핑은 기하학적인 폴리곤 모델에 이미지를 입히는 과정으로 이해할 수 있습니다. 

- 객체의 각 폴리곤은 텍스처 좌표라는 UV 좌표를 가지며, 

  이 좌표는 2D 이미지의 해당 지점을 가리킵니다. 

### 텍스처 좌표(Texture Coordinates)

```markdown
텍스처 좌표는 3D 객체의 각 폴리곤의 텍스처 공간에서의 위치를 나타내는 
		2D 좌표입니다. 
이 좌표를 사용하여 텍스처 이미지에서 폴리곤에 매핑할 올바른 색상을 찾을 수 있습니다.

텍스처 좌표는 일반적으로 UV 좌표로 표현됩니다. 
UV 좌표는 각 폴리곤의 꼭지점에 연결되어 해당 폴리곤의 텍스처 매핑을 정의합니다. 
각 정점은 U 값과 V 값으로 구성된 좌표를 가지며, 이는 텍스처 이미지의 가로와 세로 축을 나타냅니다.


텍스처 좌표는 정점의 위치와 함께 사용되어 
폴리곤의 표면에 텍스처를 매핑하는 데 필요한 정보를 제공합니다.


폴리곤의 각 점은 텍스처 좌표를 가지고 있으며, 
이를 기반으로 텍스처 매핑 과정에서 적절한 텍스처 좌표를 계산합니다. 
이렇게 계산된 텍스처 좌표를 사용하여 폴리곤의 각 픽셀에 
텍스처 이미지의 해당 색상을 매핑하여 객체의 외관을 형성합니다.


텍스처 좌표의 정확성과 정확한 매핑은 텍스처 매핑의 결과물인 객체의 외관에 큰 영향을 미칩니다. 올바르게 매핑된 텍스처 좌표는 텍스처 이미지의 세부 내용을 객체에 정확하게 반영하여 실감나고 자연스러운 외관을 만들어줍니다. 따라서 텍스처 좌표를 올바르게 조정하고 계산하는 것은 텍스처 매핑의 중요한 부분입니다.
```



>  폴리곤의 각 정점은 텍스처 좌표와 연결되어 해당 폴리곤의 텍스처 공간을 정의합니다.
>
>  텍스처 매핑은 객체의 각 폴리곤에 대해 텍스처 좌표를 계산하고, 
>
>  해당 좌표에 매핑된 이미지의 색상을 폴리곤에 적용하여 표면을 덮습니다. 



이렇게 하면 폴리곤의 표면이 이미지의 세부적인 내용과 색상으로 채워지며, 

객체는 보다 현실적이고 세밀한 외관을 갖게 됩니다.



텍스처 매핑은 게임 개발, 가상 현실, 시뮬레이션 및 시각 효과 분야에서 널리 사용됩니다. 다양한 텍스처 매핑 기법과 알고리즘이 개발되어 객체의 외관을 더욱 풍부하고 실감나게 만들 수 있습니다.



## How can OpenGL Patch Colors from Texture?

- 텍스처 좌표를 사용해 이중선형 보간함

  - 폴리곤의 텍스처 좌료 사용해 텍스처 이미지에서 픽셀의 색상을 보간한다.

- 텍스처 이미지에서 색상 샘플링

  - 텍스처 이미지에서 실제 색상 값을 샘플링하여 패치의 색상을 얻는다.

    >  텍스처 이미지는 일련의 픽셀로 구성
    >
    >  텍스처 좌표는 해당 픽셀을 지정함

    - 텍스처 좌표 > 텍스처 이미지의 픽셀 > 해당 픽셀의 색상값 가져옴

    ```markdown
    # 샘플링 문제
    텍스처 이미지는 유한한 픽셀로 구성
    텍스처 좌표와 픽셀 사이의 정확한 일치 확언 불가
    	텍스처 좌표의 정확성 매우 중요
    ```



## Using Texture Mapping in Modern OpenGL

1. 텍스처 식별자 생성 -  glGenTextures()

2. 텍스처 식별자 바인딩 - glBindTexture(), 이 텍스처 쓸고야~

3. 텍스처 데이터 지정

   ```markdown
   일반적으로 이미지 파일에서 텍스처 데이터를 로드하거나, 생성된 이미지를 사용할 수 있습니다. 
   0. 이미지 생성/로드

   1. 활성 텍스처 유닛(active texture unit)을 선택
   	glActiveTexture(GL_TEXTUREi) 함수를 사용하여 텍스처 유닛을 선택합니다.
   	
   2. glTexParameter() 텍스처 매개변수를 지정
   	이는 텍스처를 위한 wrapping mode(텍스처의 경계를 처리하는 방법) 및
       filtering method(텍스처를 확대 또는 축소할 때 사용되는 필터링 방법)를 정의합니다. 
       
   3. glTexImage2D() 함수를 사용하여 텍스처 데이터를 지정 (cpu 이미지가 gpu텍스쳐로 변환)
   ```

   ​

4. 텍스처 매핑과 함께 렌더링

   ```markdown
   텍스처 매핑을 사용하여 객체를 렌더링

   1. 활성 텍스처 유닛을 선택하고(glActiveTexture(GL_TEXTUREi))

   2. 바인딩한 텍스처 식별자를 선택한 텍스처 유닛에 바인딩(glBindTexture()).

   3. glVertexAttribPointer() - 각 정점에 대한 텍스처 좌표를 지정

   4. glEnableVertexAttribArray() - 텍스처 좌표를 사용할 수 있도록 활성화

   5. 셰이더에서 사용할 텍스처 샘플러를 지정 - glUniform1i(glGetUniformLocation(…), i)
   ```

   이미지 데이터가 gpu에서 사용하는 텍스쳐로 바뀐다



## Specifying a Texture Image

이미지를 텍스처로 지정하기?

1. 먼저 파일에서 이미지 로드 

   ​	근데 openGL에는 직접 로드하는 기능이 내장되어 있지 않음. 플랫폼별로 맞는거 사용

2. 로드 후 이미지 데이터는 cpu쪽 메모리에서 비트맵과 유사한 데이터 구조에 저장되어야 함

   - 픽셀 데이터 : 가로,세로크기/색상형식/알파채널여부 등 포함한 비트맵 데이터 구조, 이런 데이터구조!
   - 로드한 이미지 데이터는 glTexImage2D() 함수를 사용하여 GPU의 텍스처로 전달
   - 전달된 이미지 데이터는 서버 측 , GPU의 메모리에 저장되며 텍스처 유닛에 바인딩해 사용함



> 텍스처 유닛(Texture Unit)은 GPU에서 텍스처를 처리하는 단위







# \Texture Address Mode

*텍스처 주소 모드(Texture Address Mode)는* 

- 텍스처 좌표 (s, t)가 [0,1] 범위를 벗어날 때 어떻게 처리할지를 지정하는 방법
- 텍스처 좌표는 텍스처 이미지의 픽셀 위치를 나타내는 값이며, (s, t)는 각각 가로 및 세로 방향의 좌표
- 텍스처 주소 모드는 텍스처 매핑을 다양한 방식으로 제어하고, 원하는 효과를 얻기 위해 사용됩니다.



주소 모드는 텍스처를 반복해서 적용하거나 텍스처 경계를 늘리는 등의 작업을 수행할 때 사용됩니다.

> 예를 들어, 텍스처의 패턴을 반복시켜 큰 영역을 채우거나, 
>
> 텍스처 경계를 늘려 외곽 영역을 채우는 등의 효과를 주기 위해 주소 모드를 조정할 수 있습니다.



텍스처 주소 모드는 텍스처 좌표의 값이 	**텍스처 공간을 벗어났을 때**	 	적용됩니다. 

주소 모드에는 다양한 옵션이 있으며, 일반적으로는 다음과 같은 주소 모드를 사용할 수 있습니다:



*Wrapping Mode (감싸기 모드)* == 텍스처 주소 모드

- 텍스처 좌표가 텍스처 영역을 벗어났을 때 어떻게 처리할지를 지정하는 옵션

```markdown
# Repeat (반복): 
텍스처 좌표가 [0,1] 범위를 벗어날 경우, 해당 축을 반복하여 텍스처를 반복시킵니다. 
예를 들어, 좌표 값이 1.2인 경우 0.2로 반복하여 텍스처를 적용합니다.

# Mirrored Repeat (거울 반복): 
텍스처 좌표가 [0,1] 범위를 벗어날 경우, 해당 축을 반복하되, 범위를 벗어난 영역은 반전된 형태로 반복합니다. 
예를 들어, 좌표 값이 1.2인 경우 0.8로 반복되어 텍스처를 적용합니다.

# Clamp to Edge (경계 고정): 
텍스처 좌표가 [0,1] 범위를 벗어날 경우, 가장 가까운 텍스처 좌표 값을 사용하여 텍스처를 고정합니다. 
예를 들어, 좌표 값이 1.2인 경우 1.0으로 고정되어 텍스처를 적용합니다.

```



*Filtering Methods (필터링 방법)*

- 텍스처를 확대 또는 축소할 때 텍스처 픽셀 사이의 		**보간 방법**		을 지정하는 옵션입니다. 

- 텍스처는 일반적으로 텍스처 좌표에 정확히 매핑되지 않는 경우가 많으므로 

  - 필터링은 텍스처를 부드럽게 보이게 하거나 선명하게 유지하는 데 사용됩니다.

  ```markdown
  # Nearest Neighbor Filtering (최근접 이웃 필터링): 
  확대 및 축소시 텍스처 픽셀을 가장 가까운 텍스처 좌표에 있는 픽셀 값으로 선택합니다. 
  이는 텍스처를 픽셀화된 형태로 표시할 수 있지만, 계단 현상이 발생할 수 있습니다.

  # Linear Filtering (선형 필터링): 
  텍스처 픽셀을 주변 텍스처 픽셀 값의 가중 평균으로 보간합니다. 
  이를 통해 텍스처를 부드럽게 보여줄 수 있지만, 약간의 흐릿함이 발생할 수 있습니다.
  ```

  ​



# \ Sampling Problem in Texture Mapping

**텍셀**

- GPU의 텍스처의 픽셀보다 작은 단위. 

여러개의 텍셀이 모이면 픽셀 크기 됨, (1픽셀 = N텍셀)

텍셀은 GPU 메모리에 저장, 샘플링 작업을 통해 텍스처의 픽셀 값과 관련된 정보 가져올 때 사용



**샘플링**

- 텍스처(gpu)에서 특정 위치의 픽셀(cpu) 값을 가져오는 과정
- GPU의 텍스처에서 텍스처 좌표를 사용해 해당 위치의 픽셀 값(CPU)을 GPU의 텍스처 데이터로 읽어오는 과정

**샘플링 문제**

- 텍스처 매핑에서 발생, 픽셀에 대응하는 텍셀들이 있음(1:N) 해당 텍셀들 중 어떤 값을 고를지 문제 발생
- 2가지 경우
  - 1대다 픽셀텍셀관계일때 어떤 텍셀 고를지 문제(텍스처의 해상도가 픽셀보다 낮을때)
    - Aliasing
  - 다대1 픽텔관계,  픽셀이 텍셀보다 작은 포함관계, 픽셀의 색을 채우기 위해 보간이 필요함

> 이미지가 있고 이걸 CPU에서 파일을 로드함. 그리고 GPU에 보내면 이게 텍스쳐임.
> vertex마다 맞는 텍스처의 좌표 있음. 텍스처의 좌표 따라서 gpu 텍스처의 픽셀 값을 가져와서 객체의 vertex에 적용.
>
> ```
> 이미지를 CPU에서 파일로 로드한 후 GPU로 전송하여 텍스처로 사용합니다. 각 정점에는 해당 텍스처에 맞는 좌표가 할당되며, 이 좌표를 사용하여 GPU에서 텍스처의 픽셀 값을 가져와서 객체의 각 정점에 적용합니다.
>
> 정점의 텍스처 좌표는 텍스처 이미지에서의 위치를 가리키는데, GPU에서는 이 텍스처 좌표를 사용하여 텍스처의 픽셀 값을 가져옵니다. 텍스처의 픽셀 값은 해당 좌표에 위치한 픽셀의 색상 값을 의미합니다. GPU는 텍스처 좌표에 해당하는 픽셀 값을 가져와서 객체의 정점에 적용하여 텍스처를 객체의 표면에 매핑합니다.
>
> 이렇게 텍스처 좌표에 따라 GPU에서 텍스처의 픽셀 값을 가져와 객체의 정점에 적용함으로써, 텍스처의 색상과 디테일이 객체에 적용되어 렌더링 결과에 반영됩니다.
> ```





## Aliasing

샘플링 속도의 한계로 인해 발생하는 아티팩트(화질 깨지는?)

즉, 실제 세계에서는 부드럽고 연속적인 변화가 있는데, 이를 제한된 샘플링 속도로 표현하려고 할 때 발생하는 현상

- 텍스처의 해상도가 픽셀보다 낮은 경우 텍스처의 세부 정보가 충분히 표현되지 않아 앨리어싱 발생 가능



## Antialiasing

각 픽셀에 대한 해당 픽셀에 기여하는 primitive의 영향을 고려.

- Pixel color = Primitive color x (occupancy rate)
- 최종 화면 표시 픽셀 색상 = 픽셀이 속한 객체 색상 * 픽셀이 해당 도형의 일부를 차지하는 비율

```markdown
여기의 픽셀은 화면, 디스플레이의 픽셀임, 화면의 최소단위

# Magnification - 줌인
GPU 텍스처의 픽셀보다 화면의 픽셀이 더 크다.
화면의 한 픽셀에 여러개의 텍셀, 일대다
# Minification - 줌아웃
GPU 텍스처의 픽셀보다 화면의 픽셀이 더 작음
여러 개의 픽셀이 한 개의 텍셀에 매핑, 다대일

>>> 텍셀의 크기가 확대, 축소의 메인
```





## Texture Filtering

- 텍셀이 디스플레이 픽셀에 매핑될 때 색상을 결정하는 방법



> **Nearest sampling (default)**  - 픽셀 중심에 가장 가까운 텍셀의 색상이 선택됨(계산적음,품질저하)

>  **Linear sampling (better quality)** - 텍셀 주변의 색상을 보간해 픽셀 색상 결정(계산많음,품질증가)







# \ Advanced Topics of Texture Mapping

## Advanced texture Sampling

고급 텍스처 샘플링은 기본 최단거리샘플링, 선형샘플링 방법을 넘어서 3d 객체에 매핑할 때 더 현실적인 기술들

###  	MIP mapping

텍스처의 다른 해상도의 이미지들을 미리 준비하여 

텍스처를 확대 또는 축소할 때 필요한 샘플링 크기에 맞는 적절한 해상도의 이미지를 선택하는 방법입니다. 

이를 통해 텍스처가 멀리 떨어진 부분에서도 세부적인 정보를 잃지 않고 부드럽게 표현됩니다.

```markdown
- 텍스처의 축소(minification) 문제를 효율적으로 다루기 위해 사용되는 기법입니다. 
- Mipmap은 이미지 피라미드(image pyramid)를 구축하여 사용

((기본적으로, 텍스처는 원본 이미지의 해상도를 줄인 버전들로 구성된 이미지 피라미드를 가지고 있습니다. 
이 이미지 피라미드는 원본 이미지를 여러 단계로 반복적으로 축소하여 생성됩니다. 
각 단계에서는 이미지의 해상도가 절반으로 줄어들게 됩니다.))

#
    OpenGL에서는 텍스처 샘플링 시에 mip맵을 사용하여 텍스처를 필터링합니다. 
    샘플링이 필요한 픽셀의 크기와 가장 근접한 해상도의 mipmap 레벨을 선택
```

```markdown
- 이상현상(아티팩트) 발생가능
	생성 과정에서 텍스처 색상이 다른 부분과 혼합되거나 하는 등
	
밉맵 생성과정에서 텍스처 색상을 축소된 버전으로 변환하면서 색상 간에 혼합 발생 가능

```



### 	FSAA / MSAA

(풀스크린안티앨리어싱, 멀티샘플안티앨리어싱)

전체 화면 이미지에서 앨리어싱 피하기 위한 슈퍼 샘플링 안티앨리어싱 기술

- 성능과 전역 효율 문제,  픽셀당 렌더링 비용 4배 증가, 매우 높은 이미지 품질을 위한 방법

# /Blending

## Alpha Blending

알파 블랜딩은 텍스처의 알파 채널 값을 이용해 객체의 투명도 조절하는 기술

알파 채널은 텍스처 이미지에서 픽셀의 불투명도를 나타내는 값



알파값은 1-0 범위로 표현, 1이면 완전 불투명 안비침



### 	빌보드

빌보드와 같이 3d 객체를 2d 평면에 텍스처로 표현할 때 사용됨

빌보드는 3d 객체를 화면에 평면으로 표시하는 기법으로

텍스처 이미지는 알파 채널을 가지고 있어야 함

### 	Blending equation in Modern OpenGL

알파 블랜딩 공식

블렌딩 작업에 사용되는 	__소스와 대상__		의 색상 값을 결합해 최종 출력 색상 계산

![image](https://github.com/hhzzzk/2023_graphics/assets/67236054/39b4b03c-d486-4c8c-9fce-a909897cd78f)

output_color = source_color * source_factor + destination_color * destination_factor

/  c가 컬러 f가 팩터

```
source_color는 블렌딩 작업의 소스 색상 값이고, 
destination_color는 대상 색상 값입니다. 
소스 팩터(source_factor)와 대상 팩터(destination_factor)는 각각 소스 색상 값과 
대상 색상 값의 가중치를 조절하는 요소
```

### 	페인터 알고리즘과 알파블랜딩

Alpha Blending과 Painter's Algorithm은 모두 투명한 객체를 처리하기 위해 사용되는 기술이지만, 

Alpha Blending은 실제로 객체의 픽셀에 투명도를 적용하는 방식이고, 

Painter's Algorithm은 객체들을 올바른 순서로 렌더링하여 투명한 효과를 구현하는 방식

### 	openGL 함수

```markdown
# glBlendFunc(): specify pixel arithmetic
glBlendFunc(srcFactor, dstFactor) 형태로 사용됩니다. - 소스/대상 블렌딩팩터
두 픽셀 사이의 색상 값에 대한 연산을 지정

# glBlendFuncSeperate(): specify pixel arithmetic for RGB / A separately
이 함수는 RGB 색상 값과 알파 값을 별도로 지정할 수 있는 블렌딩 팩터를 설정

# glBlendEquation(): specify the blend equation for RGBA
RGBA 색상에 대한 블렌딩 방정식을 설정

# glBlendEquationSeperate(): specify the blend equations for RGB / A separately
RGB 색상 채널과 알파 채널에 대해 각각 다른 블렌딩 방정식을 설정
```

### 	알파블랜딩 고려해야 할 점

- Z 버퍼 테스트 > 기본적으로 수행 안함. 그래서 픽셀 깊이 상관없이 하앗ㅇ 그려짐
  - 투명 객체를 정확한 깊이로 렌더링하려면 Z버퍼 테스트 해야함
- 렌더링 순서 > 알파 블랜딩은 순서에 따라 결과 달라질 수 있음
  - 따라서 알파 블렌딩을 할 때는 객체들을 올바른 순서로 정렬해야 함





# \ Multi-Texturing with Programmable Rendering Pipeline

## 	Multi-Texturing

- 둘 이상의 텍스처를 혼합해 새로운 텍스처 이미지를 생성하는 작업
- 프래그먼트 쉐이더에서 많이 사용



## 	Normal Mapping

- 이미지의 RGB 채널을 활용해 표면의 법선 벡터를 나타내는 기술
- 3D 모델의 표면을 표현하기 위해 사용

> 각 픽셀의 RGB값 자체를 법선 벡터로 사용
>
> 이를 조합해 표면의 방향과 경사 표현

## 	Image Processing

- Convolution 합성곱은 이미지 프로세싱에서 일반적으로 사용되는 연산

- 이미지와 커널(필터) 사이의 연산, 주로 이미지 필터링에 사용

  > 커널은 작은 크기의 행렬로 이미지의 각 픽셀과 인접한 픽셀들의 가중합을 계산해 새로운 픽셀 값 생성

  이러한 커널을 이용해 이미지를 smoothing, 등 여러 이미지 처리 작업 수행 가능

  ​