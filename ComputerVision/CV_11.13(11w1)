CV_11.13(11w1)

# backprop
벡터와 매트릭스 연산 차이
매트릭스 형태 유지

벡터가 쌓여서 매트릭스
매트릭스 연산으로 한번에 처리한다. 연산효율up
[[2,1,-3],
[-3,4,2]]
면 입력 2개, 데이터가 N개이다. x : N*D

dL/dx, downstream 그래디언트 구하기
입력과 크기같다. N*D
야코비안은 연산량이 많은 문제

Local gradient slice를 구해서 일반화해보자
각 x입력에 대해 로컬 그래디언트 슬라이스 구하기

결국 연산에 관여되지 않으면 0이되고 관여해야 미분되면서 남는다.
개입되는 부분의 weight만 반영된다.

일반화하면 40페이지
dL/dx = (dL/dy) wT
N*D = (N*M)(M*D)
쉽게 생각하면 곱셈 연산 가능하도록 전치 시켜주면 됨

# cnn
32*32*3인 이미지를 stretch, vufclaus 3072
클래스가 10개면 w의 파라미터만 3072 * 10 > 파라미터가 너무 많다.

sol 컨볼루션의 도입
파라미터를 줄일 수 있다.
이미지의 spatial 구조를 보존할 수 있다.

필터의 도입.
필터가 3*5*5면 이미지의 채널 rgb,이 3개인 5*5크기의 필터이다.

최종 ouput은 1개가 나온다. activation map
이미지의 depth와 무관

output개수는 필터의 개수와 같다. 입력 depth와 상관없음

필터 4차원
6*3*5*5면
6개의 필터를 사용한 depth 3인 가로세로 55인 필터이다.

## 이미지를 여러개 사용
입력 4차원 2*3*32*32면
2개의 이미지를 사용한 깊이 3인 가로세로 32,32의 이미지

여러 장의 이미지를 batch로 묶는다.

일반화하면 입력은
N * Cin * H * W
필터는
Cout * Cin * Kw * Kh
output은
N * Cout * H' * W'

입력의 이미지 개수가 최종 출력과 출력 N
입력의 깊이가 필터의 깊이
필터의 개수가 출력의 Cout

## stacking Convolutions
중첩
컨볼루션 연산하면 선형 연산처럼 걍 선형연산 평생 이어짐
비선형성을 위해 ReLU 등 추가

인간이 필터를 설정하는게 아니라 딥러닝으로 data-driven 알아서 오류역전파해서 적절한 필터를 찾는다.


28페이지까지함
