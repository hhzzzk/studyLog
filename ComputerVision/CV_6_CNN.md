# CV_6_CNN

ing 

11.13(11w1)



## CNN의 등장배경

![image](https://github.com/hhzzzk/studyLog/assets/67236054/f3aa725c-c2d9-4f84-81bc-0232e8991939)

예시로 32,32,3 크기의 이미지를 stretch, 쫙 피면 3072개의 파라미터가 생긴다. 굉장히 많다

심지어 이를 fully connected layer에 넣으면 각 입력과 출력의 뉴런 사이에 모든 연결이 존재하게 된다.

그러므로 32 x 32 x 3 x 클래스 수에 해당하는 굉장히 많은 파라미터를 필요로 하게 된다.



이를 해결하기 위해 컨볼루션 레이어를 도입한 것이 CNN



## Convolution layer

각 뉴런은 입력 이미지의 필터와 연결된다.

이를 통해 파라미터를 공유함으로써 전체 파라미터 수를 크게 줄일 수 있다.

이 작은 영역을 필터라고 한다. 필터를 통해 이미지의 지역 패턴을 인식한다.

3x3크기의 필터가 있다면 각 뉴런은 3x3 영역의 입력과 연결되고 이 필터를 이미지 전체에 적용해 공간적인 특징을 감지한다.



CNN은 이미지의 공간 구조를 잘 보존한다. 합성곱(컨볼루션) 레이어는 지역적 패턴을 인식하고 풀링 레이어는 이미지의 크기를 줄이면서 중요한 정보를 유지한다.

이런 구조를 통해 이미지에서 중요한 정보를 추출하고 추상화한다. 이를 통해 객체의 위치나 크기에 덜 민감하게 학습된다.

![image](https://github.com/hhzzzk/studyLog/assets/67236054/2beacab8-1d21-49f0-9229-1941385c7bdc)



필터가 3,5,5면 3개의 채널 RGB를 가지는 5X5 크기의 필터이다. 각 채널은 이미지의 다른 특징을 인식한다.



최종 output은 1개의 숫자로 이루어진 activation map이다. 이는 필터와 이미지를 연산한 결과에 편향 bias를 더한 것이다.

- 이미지의 채널 수와 무관하게 최종 출력은 1개의 스칼라 값으로 나온다.



필터를 여러 개 사용하면 6,3,5,5 처럼 4차원 텐서로 표현한다. (필터 개수, 채널수, 필터 크기)

![image](https://github.com/hhzzzk/studyLog/assets/67236054/4b9989ee-cf16-4b37-aae6-3477423193c1)

출력 개수는 사용된 필터의 개수와 동일하다. 즉 필터 하나당 한 개의 출력=활성화 맵이 나온다.

- 입력 depth, 채널 수와는 상관없이 출력의 개수는 필터의 개수이다!



![image](https://github.com/hhzzzk/studyLog/assets/67236054/57ce5474-15e0-42a0-b437-684d784d4fa9)

입력이 2개의 이미지라면 6개의 필터를 사용하므로 출력은 총 12개가 나올 것이다.



![image](https://github.com/hhzzzk/studyLog/assets/67236054/0398f11c-d174-4b49-85e0-b4cf370141c8)



일반화하면 다음과 같은 공식이 나온다.

입력은 (입력의 개수, 채널수, 이미지크기)

필터는 (필터 개수, 채널수, 필터크기)

출력은 (입력개수, 필터개수(채널수아님!!!!!!), 출력크기) - 출력크기 계산 공식은 패딩이랑 이런거 



## What do convolutional filters learn? 

![image](https://github.com/hhzzzk/studyLog/assets/67236054/1f16d173-9afe-4bf9-ab67-8dbff34e6689)



선형 분류기에서는 하나의 클래스당 하나의 템플릿이 학습되었다.

이러한 방식은 간단하지만 실제 문제는 비선형성이 존재한다. 간단한 분류 문제에서만 효과적이다.

그래서 비선형성을 추가해야 한다. 

(하나의 레이어에서는 선형, 비선형 연산이 모두 수행된다.)



**First-layer Conv Filters: Local Image Templates**

CNN에서는 비선형성을 도입하기 위해 활성화 함수로 ReLU나 시그모이드를 사용한다.

따라서 CNN의 첫번째 층에서는 지역적인, local 이미지 패턴을 학습하고 이후의 층에서는 이러한 특징들을 조합해 더 높은 수준으로 이미지의 특성을 추상화한다. 

```
한 개의 레이어 안에서는 선형성과 비선형 연산이 수행된다. cnn의 경우 각 컨볼루션 레이어에서 선형, 비선형 연산이 수행되면서 이미지의 특성을 추상화시킨다. 첫번째 컨볼루션 레이어에서도 그러하다. 이 과정이 반복되어 후반 레이어로 갈수록 더 높은 수준의 특성을 추상화시키는 것이다
```



## A closer look at spatial dimensions

![image](https://github.com/hhzzzk/studyLog/assets/67236054/ed2ba1a5-318b-405b-881f-74f003150ef1)



패딩 과정 없이 그냥 이미지를 컨볼루션 레이어에서 필터와 연산을 하면 피처맵의 크기가 input보다 작아진다.

입력과 출력의 크기가 다르면 입력 이미지의 일부 정보가 손실되거나, 해상도가 감소. 가중치가 감소하는 등의 문제가 생길 수 있다. 그러므로 입력과 출력의 크기를 맞춰주는 과정이 필요하다. 해당 과정이 패딩이다.



**padding**

패딩은 input의 테두리 부분을 0으로 채우는 것이다. 다른 값도 가능한데 보통 0으로 채우면 연산과정에 영향이 없음. 크기 유지 기능만 해서 굿임

![image](https://github.com/hhzzzk/studyLog/assets/67236054/257359ae-2adb-4ce7-8c27-32bb4283f454)



위에서 안한 출력의 크기가 이거다

출력의 크기는 (입력크기 - 필터크기 + 1 + 패딩두배)



## Receptive Fields

![image](https://github.com/hhzzzk/studyLog/assets/67236054/f6923572-99be-4c28-b5a6-38fe2c85e84b)

수용영역, 리셉티브 필드는 출력의 각 요소가 input의 receptive field의 크기만큼 영향을 받는다.

즉 출력이 입력 이미지에서 어떤 영역을 보고 있는지를 나타낸다.

커널=필터는 이 영역을 사용해 해당 위치에서의 특징을 추출한다.

---

![image](https://github.com/hhzzzk/studyLog/assets/67236054/85412077-995a-4ca4-a021-a9b0f3f63038)

receptive field의 크기는 = 1 + L ( K-1 )

위의 그림은 3개의 레이어를 사용한 것이다. L개의 레이어, K는 커널=필터의 크기다.

위의 예제에서는 수용 영역의 크기가 7*7로 전체를 커버한다.

그러나 최종 output이 전체 이미지 크기를 다 수용 영역으로 하려면 == 각 출력이 전체 이미지를 "보도록"하기 위해서는

input 이미지가 매우 클 경우 컨볼루션 레이어가 굉장히 많이 필요하다.



이를 해결하기 위한 해결책으로 다운샘플링이 있다.

다운샘플링은 피처 맵의 공간적인 크기를 줄이면서 중요한 정보를 보존한다.



## Downsampling

![image](https://github.com/hhzzzk/studyLog/assets/67236054/018893ef-99ac-4557-b6b7-f72fb803cc5c)

다운샘플링에는 여러 방법이 있는 stride, 걸음수를 조절할 수 있다.

1칸씩 이동하면서 연산하지 않고 위에서는 2칸씩 이동하며 필터와 연산해 output, 피처맵을 추출한다.



그래서 또 업데이트된 output의 크기는

입력의 크기에 필터의 크기를 빼고 패딩두배해서 더한다. 그걸 걸음수로 나누고 1을 더한다.



![image](https://github.com/hhzzzk/studyLog/assets/67236054/d01aab1e-e9c8-4d73-bdc2-ca31a7a7641a)



![image](https://github.com/hhzzzk/studyLog/assets/67236054/ebad8f39-d86f-4345-9ebe-3caf40179ce5)

파라미터 개수는 입력개수 곱 필터크기가세 +1에다가 필터 개수를 곱한다.

![image](https://github.com/hhzzzk/studyLog/assets/67236054/581703d7-49f9-4a20-ad4d-ad58b3f3c415)



수학 문제 내기 너무 좋죠?