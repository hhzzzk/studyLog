# 소프트웨어 아키텍처 - 1(정의)



#### What is Architecture

- 소프트웨어 아키텍처는 조직의 목적을 만족하기 위해 만들어 진다
- ![img](https://velog.velcdn.com/images/3eung_h10n/post/131b5fe7-0120-4176-9d8d-f778a17dbf83/image.png)

------

#### Software Architecture is a bridge

- 소프트웨어 아키텍처는 알려진 기술을 사용하여 설계 및 분석, 문서화 및 구현이 가능함
- 알려진 기술을 활용해 비즈니스 및 미션 목표를 달성함
- 복잡성을 다루어 이해하기 쉬운 형태로 만들 수 있음

#### 건축과 비교(고층건물 짓기)

- 복잡해서 한 사람이 모든 것을 이해할 수 없음
- 여러 전문 분야가 필요
- 분야 간의 요구가 상충
- 중앙에서 통제하는 작업 공정 필요

#### *위의 문제들로 설계가 필요 -> 소프트웨어 아키텍처*

------

#### Software Architecture Definition

- 시스템을 이해하고 분석하기 위해 필요한 구조들의 집합
- 위의 구조들은 시스템을 이루는 소프트웨어 요소, 요소들의 관계, 요소와 관계의 특성으로 이루어짐

#### *소프트웨어 아키텍처란 시스템을 설명 및 설계하기 위해 필요한 구성 요소와 관계를 나타내며 이들의 특성도 포함 한다*

------

> ### Architecture is a Set of Software Structures
>
> - 소프트웨어 아키텍처는 여러 가지 구조로 구성된다
>   (아키텍처를 대표하는 단일 구조는 없다)

#### Modules

- 특정한 계산적인 책임이 할당된 구성 요소
- 프로그래밍 팀의 작업 할당의 기초
- 객체 지향 분석 및 설계의 결과물, 클래스 다이어그램

#### *모듈은 소프트웨어 시스템 내에서 계산적인 책임을 가지고 있는 구성 요소, 프로그래밍 팀이 작업 할당 및 관리에 사용, 클래스 다이어그램을 통해 시각화 될 수 있음*

------

#### Dynamic Structures

- 요소들이 실행 시간에 어떻게 상호 작용하느지에 중점을 둠
- 실행시간 구조는 Component-and-connector, C&C로 부름)

#### *동적 구조는 소프트웨어 실행 중 요소들의 상호 작용에 주력, 실행시간 동안의 상호 작용과 구조는 C&C로 부름, 시스템의 동작을 시각화하고 이해하는데 도움을 준다*

------

#### Mapping from software structures to the system’sorganizational, developmental, installation, and execution environments(소프트웨어 구조에서 시스템의 조직, 개발, 설치 및 실행 환경의 매핑)

- 모듈은 개발팀에 할당되어 개발되고 파일 구조에 배치 되거나 구성요소는 하드웨어에 배포된다
- 할당 구조

#### *소프트웨어 구조와 시스템의 조직, 개발, 설치, 실행 환경과의 관계 , 소프트웨어 구조의 요소들이 시스템의 여러 측면과 연관되는 측면을 나타내는 것*

------

#### 요구사항

- 어떤 구조가 시스템과 시스템의 특성을 이해하게 도움을 준다면 그 구조는 아키텍처적인 것
- 추론은 시스템의 특정 속성에 관한 것이어야 하고 그 속성이 관계자들에게 의미있는 내용이어야 함
  - 시스템이 달성하는 기능
  - 시스템이 결함에 대처할 수 있는 가용성
  - 시스템에 특정 변경을 가하는 난이도
  - 시스템이 사용자 요청에 대한 응답을 처리할 수 있는 반응성

---

# 소프트웨어 아키텍처 - 2(구조)

#### Architecture is an Abstraction

- 아키텍처는 소프트웨어 요소와 요소 간의 관계로 구성
- 복잡성을 다루는 방법
  - 아키텍처는 복잡성(요소간의 관계)을 다루기 위해 공개적인 측면에 중점을 둔다 -> 소프트웨어 요소의 개인적인 세부 사항, 내부 구현은 아키텍처적인 부분이 아니라는 의미
- 추상화는 시스템의 복잡성을 다루는데 필수적

------

#### Architecture includes Behavior

- 각 요소의 행동은 요소들이 서로 상호 작용하는 방식을 반영
- 요소의 행동은 다른 요소에 영향을 미치거나 시스템 전체에도 영향을 미칠 수 있다
- 이러한 행동은 소프트웨어 아키텍처의 일부로 고려되어야 하며, 문서화되어야 한다

------

#### Every Software System has a Software Architecture

- 모든 시스템은 소프트웨어 아키텍처를 가짐
- 모든 시스템이 시스템을 이해하고 추론하기 위해 필요한 요소와 요소간의 관계로 구성되어 있기 때문
- 하지만 아키텍처가 누구에게도 알려지지 않을 수 있으며 설명 또는 명세와 별도로 존재할 수 있다

#### *아키텍처가 시스템의 본질적인 부분이지만 문서화되거나 명세화되지 않을 수도 있다*

------

#### Software Architecture Definition - 2

- 아키텍처는 시스템의 기본적인 구성을 나타낸다 이것은 시스템의 구성 요소, 그것들의 관계, 설계 및 진화를 이끄는 원칙으로 구체화
- 이 전 내용과 비슷

------

#### Goal of Software Architecture

- ![img](https://velog.velcdn.com/images/3eung_h10n/post/d41f4bf6-c18f-4744-8b91-946b8892e7a6/image.png)
- 일정한 설계 변수가 결정되어야 함
- 주어진 제약 조건 하에서 최상의 측정 가능한 성능을 달성 해야함

#### *아키텍처의 목적 -> 최적화 : 주어진 제약 조건에서 설계 변수를 결정하여 가장 우수한 성능(목적 성능)을 최대화, 최소화 하는 것*

------

#### Common Aspects in Software Architecture Problem

- 문제에는 여러 해결책이 존재함, 최적의 해결책을 찾아야 한다
- 달성해야 할 하나 이상의 목표와 그 목표를 얼마나 잘 달성하는지 측정하는 방법이 존재
- 다양한 형태의 제약 조건이 존재(hard, soft)
  - hard는 강제적으로 지켜져야 하는 제약(비용, 공장의 성능 같은 것들)
  - soft는 최적화와 관련이 높음
- 영향을 주는 주요한 변수의 변경
  - 이들 값의 변경은 성능이나 제약 조건 위반에 영향을 미친다 -> 영향 변수의 조정으로 시스템의 성능을 최적화하면서 제약 조건을 만족 해야함

------

#### 소프트웨어 개발

- ![img](https://velog.velcdn.com/images/3eung_h10n/post/b6ef8e3a-aac6-4d06-954b-aa666911ad83/image.png)
- 모델링(분석 / 설계) -> 구현의 단계를 개발로 부름

------

#### SW 개발 패러다임

- ![img](https://velog.velcdn.com/images/3eung_h10n/post/a586af44-087d-4a94-ad2e-f2b57b6389f6/image.png)

------

#### 소프트웨어 모델링 목적

- 모델링 : 표현, 명세, 구축, 문서화
- ![img](https://velog.velcdn.com/images/3eung_h10n/post/b702f8a0-83c7-4310-b32b-70d31f00a3a5/image.png)



# 소프트웨어 아키텍처 - 3(Views)

> ## Views

##### 오브젝트 -> 요소

------

### C&C(Command and Control)

- ![img](https://velog.velcdn.com/images/3eung_h10n/post/273185d8-a1b4-490b-8d5f-3746d58079ea/image.png)
- C&C 구성 요소
  - 공유 리포지토리(Database)
    - 데이터와 정보를 저장
    - 서버들과 관리 컴포넌트에 의해 접근
  - 서버
    - 공유 리포지토리에 접근, 데이터를 읽고 쓰는 역할
    - 클라이언트 텔러들과 상호 작용, 데이터 처리 및 관리
  - 관리 컴포넌트(Administrative)
    - 시스템의 관리와 모니터링
    - 서버 및 리포지토리의 동작을 감시, 관리
  - 클라이언트 텔러
    - 서버와 상호 작용, 공유 리포지토리의 데이터를 요청 or 업데이트
    - 클라이언트 텔러끼리 통신, 데이터나 이벤트를 공유("Publish-subscribe" 연결자 사용)

#### *C&C 구조는 데이터 중심의 시스템에서 다양한 역할을 수행하며 효율적인 상호 작용을 가능하게 함*

------

#### UML

- Module Elements in UML(Unified Modeling Language)
  - ![img](https://velog.velcdn.com/images/3eung_h10n/post/eeb877ef-8f9a-4ea6-b265-234c23bd20ce/image.png)
  - 클래스 : 보통 3개의 구획으로 나누어 이름, 속성, 기능을 표시, 이름은 필수지만 다른 2가지는 생략이 가능
  - 소프트웨어 시스템을 모델링하고 설계하는 데 사용되는 방법
  - 시스템의 모듈화, 컴포넌트 분해, 시스템 아키텍처등의 표현에 도움을 줌

------

#### Module Relations in UML

- ![img](https://velog.velcdn.com/images/3eung_h10n/post/979456b1-8643-4f07-87e0-6c5dec0c2e18/image.png)
- is-part-of relation
  - 큰 개체가 하위 개체로 구성
  - ex) 자동차는 엔진, 바퀴, 창문으로 구성 자동차와 엔진, 바퀴, 창문 간의 관계가 is-part-of 관계
- is-a-relation(상속)
  - 클래스 상속 : 하위 클래스가 상위 클래스의 모든 특성을 상속
    - 클래스 간의 계층 구조 형성 및 공통된 특성 재사용
  - 인터페이스 관계
    - 인터페이스가 메서드를 정의, 클래스가 해당 인터페이스의 메서드를 제공하는 방법
- depends-on-relation
  - 상위 클래스가 하위 클래스의 메서드를 사용하는 경우

------

#### Structures and Views

- View는 소프트웨어, 아키텍처의 일부분을 나타내는 것으로 시스템 관계자들이 읽고 작성할 수 있다
  - view는 아키텍처 요소들의 일관된 집합 : 시스템의 일부를 선택하고 그 부분을 나타내는 것이 view
  - 선택된 아키텍처적인 요소들의 표현, 요소들 간의 상호 작용을 나타낸다
- Structure은 시스템 내에서 실제로 존재하는 요소들의 집합
  - 시스템의 실제 구성 요소들과 그들 간의 관계를 나타낸다, 뷰는 이 구조를 특정 관점에서 보여준다

#### *'뷰'는 아키텍처 '구조'의 일부를 특정 관점에서 표현한 것*

------

#### Example of Structures and Views

- 모듈 구조
  - 시스템의 모듈구성과 그들간의 조직관계를 정의
  - 모듈은 소프트웨어 시스템을 기능적인 부분으로 분할한 요소들
- 모듈 뷰
  - 모듈 구조의 특정 관점, 특정 관계자 그룹을 위해 선택된 구조적인 정보를 포함하는 표현
  - 뷰는 구조를 특정 템플릿과 표기법에 따라 문서화한 것, 이를 통해 관계자들이 읽고 이해함

#### *소프트웨어 아키텍트는 시스템의 아키텍처를 설계하고 구조화, 아키텍트는 모듈 구조를 설계하고 그 구조를 뷰를 통해 문서화하여 공유*

- 같은 시스템의 다른 뷰
  - ![img](https://velog.velcdn.com/images/3eung_h10n/post/c4d37e0c-a714-4335-80fa-8de9b2778854/image.png)

------

> ### 4+1 View Model

------

#### 모델링 뷰

- ![img](https://velog.velcdn.com/images/3eung_h10n/post/d6b5665e-3192-4873-b2c3-826c920dfdd7/image.png)

------

#### Logical Viewpoint(논리적 관점)

- 소프트웨어 시스템이 최종 사용자에게 제공해야 하는 서비스와 기능적 요구사항을 지원
  - 기능적 요구사항 지원
    - 시스템이 수행해야 하는 기능과 서비스를 정의
    - 사용자, 다른 시스템과 상호작용간에 어떤 동작을 수행해야 하는지 나타낸다
  - 핵심 추상화 표시
    - 클래스, 객체, 모듈 이들 간의 상호작용 같은 개념적인 요소를 표시
    - 시스템의 기능과 동작을 논리적으로 나타내어 관계자들에게 시스템의 구조와 동작 방식을 제시

------

#### Process Viewpoint(프로세스 관점)

- 런타임에서 발생하는 동시성 측면 과 비기능적 요구사항을 다룸
  - 동시성
    - 시스템이 실행 중일 때 task, thread, process와 그들 간의 상호작용
    - 여러 작업이 동시에 처리될때 발생, 효율성, 성능, 데이터 공유, 동기화등을 고려
  - 비기능적 요구사항
    - 성능 : 응답시간, 처리량
    - 시스템 가용성 : 사용 가능한 시간 및 가동 중지 시간
    - 동시성 및 분산 : 다중 사용자나 다중 시스템 간의 효과적인 상호작용과 분산 아키텍처를 고려
    - 시스템 무결성 : 오류가 없는 동작 보장 및 데이터의 무결성 유지
    - 내결함성 : 하드웨어, 소프트웨어 오류에 대해 견딜 수 있는 능력

------

#### Deployment Viewpoint(배포 관점)

- 논리적, 프로세스, 구현 관점에서 식별된 다양한 요소가 다양한 노드에 어떻게 매핑되어야 하는지 저의 및 비기능적 요구사항 고려

  - 논리, 프로세스, 구현 관점의 요소 매핑
    - 다양한 관점에서 식별된 요소들이 물리적인 노드(하드웨어, 서버등)에 어떻게 배치하고 연결할지 정의
    - 논리적인 요소(클래스, 모듈), 프로세스(서비스, app 인스턴스), 구현 관점에서의 요소들에 적용
  - 비기능적 요구사항
    - 시스템의 가용성
    - 신뢰성(오류 허용 및 복구 능력)
    - 성능 및 확장성(부하 증가에 따른 확장 가능성)

  #### *ex) 웹 애플리케이션의 배포 관점에서는 웹 서버, 애플리케이션 서버, 데이터베이스 서버 등의 요소들이 어떻게 물리적인 서버 노드에 배치되고 연결되어야 하는지를 정의*

------

#### Implementation Viewpoint(구현 관점)

- 소프트웨어 모듈을 개발 환경에서 어떻게 구성하는지에 중점(실제로 개발하는 과정과 관련이 높다)
  - 소프트웨어 모듈의 구성
    - 소프트웨어 모듈 : 시스템의 구성 요소
    - 이 모듈들이 서로 연결되고 협력하여 시스템의 기능을 구현
  - 프로그램 라이브러리 or 서브시스템 패키징
    - 모듈은 프로그램 라이브러리나 서브 시스템으로 패키징 되기도 한다
    - 코드의 재사용성을 높이고 단순화, 유지보수에 유리

------

#### Use Case Viewpoint(시나리오 관점)

- 아키텍처의 네 가지 관점(위의 4가지)에서의 요소들이 서로 원활하게 작동하는 방식을 보여주기 위해 사용 사례(use case)를 활용
  - 아키텍처 디자인 중요한 요소 발견
    - 아키텍처 디자인 과정에서 중요한 아키텍처 요소를 발견하는 데 도움을 줌, 사용 사례를 통해 시스템의 동작 과정을 이해 아키텍처 요소 식별 및 설계
  - 아키텍처 디자인의 유효성 확인 및 설명
    - 사용 사례를 통해 아키텍처가 사용자 또는 시스템과 어떻게 상호작용하는지를 시각화하고 이를 통해 아키텍처 디자인의 유효성을 검증, 설명
  - 프로토타입 테스트의 시작점
    - 아키텍처 프로토타입의 테스트를 시작하기 위한 출발점으로 사용
    - 사용 사례를 기반으로 아키텍처의 프로토타입을 개발하고 테스트, 시스템의 초기 버전을 검증하고 개선할때 중요한 역할을 한다

#### *시나리오 관점은 아키텍처 디자인 과정에서 시스템의 동작과 상호작용을 구체화, 검증하는 데 도움을 주고 아키텍처의 유효성을 입증하는데 중요한 역할을 한다*

------

> ### 4+1 View Model Summary

- 논리적 관점 (Logical View)
  - 중점
    - 시스템의 기능적 요구사항.
  - 내용
    - 클래스 다이어그램, 시퀀스 다이어그램, 계층 다이어그램과 같은 다이어그램을 사용하여 시스템의 논리적 구조를 나타냄
- 구현 관점 (Implementation View)
  - 중점
    - 소프트웨어를 개발 환경에서 정적으로 구성하는 것.
  - 내용
    - 컴포넌트 다이어그램, 패키지 다이어그램과 같은 다이어그램을 사용하여 소프트웨어 모듈의 구현과 조직을 표현
- 프로세스 관점 (Process View)
  - 중점
    - 시스템의 런타임 동작, 프로세스, 통신, 동시성, 성능 및 확장성 등
  - 내용
    - 액티비티 다이어그램을 사용하여 시스템의 런타임 동작을 설명
- 배포 관점 (Deployment View)
  - 중점
    - 시스템 엔지니어의 관점, 시스템의 위상, 배포 및 통신을 다룸.
  - 내용
    - 배포 다이어그램을 사용하여 논리적 요소가 물리적 노드에 배치되고 연결되는 방법을 표현
- 시나리오 관점 (Scenarios View)
  - 중점
    - 아키텍처를 설명하고 검증하기 위한 사용 사례.
  - 내용
    - 사용 사례 다이어그램을 사용하여 아키텍처를 설명하고 검증하는 데 사용되는 시나리오를 나타냄



# 소프트웨어 아키텍처 - 4(Design)

> ## Design

#### Overview

- Architecture Design: What
- Architecture Design: Who
- Architecture Design: Why
- Architecture Design: When
- Architecture Design: Output
- IEEE standard for software life cycle

------

#### software design

- 소프트웨어 디자인의 목표 : 고객 요구사항 충족, 성공적인 구현을 이끄는 모델을 만드는 것

------

### Architecture Design: What

- 소프트웨어의 주요 구조적 요소 간의 관계를 정의
  - 어떤 부분이 시스템의 핵심 요소이며 이들이 어떻게 상호 작용 하는지 결정
- 시스템에 정의된 요구사항 달성하고 아키텍처를 구현하는 데 사용할 수 있는 아키텍처 스타일과 아키텍처를 구현하는 방식에 영향을 미치는 제약 사항을 결정
  - 아키텍처 스타일의 선택 : 시스템의 성능, 확장성, 보안에 영향을 미침
  - 제약조건 : 기술적, 비용적, 시간적, 리소스 관련된 제약 조건을 고려해야 함
- 아키텍처 디자인 표현은 시스템 요구 사항 명세와 분석 모델에서 파생됨
  - 아키텍처를 그림, 다이어그램, 문서 등으로 표현하여 팀원 간의 이해를 촉진

------

### Architecture Design: Who

- 소프트웨어 아키텍트와 디자이너들이 소프트웨'어 시스템의 요구사항을 아키텍처 디자인으로 번역하는 역할
- 번역 과정에서 시스템의 복잡성을 분석하고 이를 해결하기 위해 다양한 디자인 전략을 적용

------

### Architecture Design: Why

- 디자인을 통해 시스템 요구사항을 충족할 수 있고 미래의 요구사항 변경및 재사용을 위해 소프트웨어 디자인이 필요함
- 소프트웨어 제작 과정에서 시간과 비용의 절약을 위해 필요
- 좋은 디자인은 제작 과정에서 위험을 줄이고 개발팀의 협력을 도우며 구현 및 테스트를 쉽게 만들어줌

------

### Architecture Design: When

- 소프트웨어 아키텍처의 디자인은 소프트웨어 개발 수명 주기(SDLC)중 하나에 속함
- SDLC
  1. 소프트웨어 요구사항 분석 : 고객 및 관계자와 대화를 통해 요구사항 수집 및 문서화
  2. 소프트웨어 아키텍처 디자인 : 이 단계에서 아키텍처 디자인이 수행, 시스템의 구조와 구현 방향 결정
  3. 소프트웨어 개발 및 구현 : 디자인 단계에서 결정된 구조와 디자인에 따라 실제 개발
  4. 테스팅 및 품질 보증, 유지보수 및 진화 : 개발된 소프트웨어를 유지 보수 및 발전
- ![img](https://velog.velcdn.com/images/3eung_h10n/post/f4bcadaf-85fa-4276-84ac-3480d655a954/image.png)

#### *소프트웨어 아키텍처 디자인은 소프트웨어 개발 수명 주기의 초기 단계 중 하나이다*

------

### Architecture Design: Output

- 전반적으로 시스템을 구축할 계획 및 설계의 개요를 나타내는 것이 아키텍처 디자인이다
- IEEE의 소프트웨어 디자인 설명서의 권장 방법에 제공된 주요 섹션
  - 디자인 개요 : 소프트웨어 디자인 문서의 목적, 범위 및 개요
  - 분해 설명 : 모듈, 데이터 프로세스를 어떻게 나누고 조합할 것인지 설명
  - 의존성 및 연결 설명 : 구성 요소간의 상호 작용과 관계를 설명하여 시스템 전체의 동작 방식을 이해하도록 해줌
  - 속성 : 각 구성 요소의 특징과 기능을 자세히 다루는 부분
  - 사용자 인터페이스 설명 : 사용자 인터페이스의 디자인과 동작에 대한 설명, 사용자와 시스템 간의 상호 작용을 이해하기 위한 정보를 제공
  - 상세 디자인 : 데이터 구조, 모듈의 동작, 알고리즘 등을 자세히 설명

------

### IEEE standard for software

- ![img](https://velog.velcdn.com/images/3eung_h10n/post/164d4201-dc0a-4581-af2c-a2ed5d9dcaca/image.png)

------

### Software Requirement Specification (SRS)

##### *디자인에 필요한 요구사항을 분석하는 방법*

- 요구사항 모델링
  - 정보 도메인 및 데이터 모델링
    - 시스템이 다루는 정보와 데이터를 모델링, 설명 데이터베이스의 구조와 데이터 흐름 등
  - 기능 및 행위 모델링
    - 기능은 수행해야 하는 기능과 작업 행위는 시스템의 동작과 흐름을 설명
  - 사용자 인터페이스 모델링
    - 사용자와 시스템 간의 상호작용을 설명하고 시각적으로 표현
- 요구사항 설명(설명하는 방법)
  - Use Case Specifications(UML)
    - UML을 사용하여 사용사례와 사용자 요구사랑을 설명
    - 시스템의 사용 사례는 시나리오와 행위를 포함하는 다이어그램과 텍스트로 설명됨
  - Data Flow Diagram(DFD)
    - 데이터 흐름과 처리 과정을 표현
    - 정보의 흐름을 시각화한다
  - State Transition Diagrams(STD)
    - 상태 전이 다이어그램, 상태와 상태 간의 전이 및 변화를 표현
    - 종적인 행위를 설명하는데 주로 사용
- 요구사항의 두 가지 측면
  - 기능적 요구사항
    - 시스템이 수행해야 하는 작업, 기능
  - 비기능적 요구사항
    - 품질, 제약 사항, 성능, 보안, 유지 보수 등



# 소프트웨어 아키텍처 - 5(Design Guidelines)

> ## Design Guidelines

#### Overview

• Software Architect's Tasks
• Definition of Architecture Styles
• Consider Quality Attributes -> in the next lecture!
• Software Architecture Design Guidelines
• Models for Software Architecture

------

#### Software Architect`s Tasks

- 시스템을 정적으로 파티션하고 하위 시스템으로 분해, 하위 시스템 간의 통신을 설정
  - 시스템을 관리하고 이해하기 쉬운 작은 부분으로 나누어 하위 시스템 간의 통신 방식을 정의하여 하위 시스템이 정보를 교환, 협력할 수 있도록 함
- 다양한 하위 시스템 간의 동적 관계를 데이터 흐름, 제어 흐름 조작 또는 메시지 발송 등으로 확립
  - 각 하위 시스템 간의 상호 작용 방식 설계, 구현
- 아키텍처 스타일 선택 시 품질 및 비기능 요구 사항에 대한 트레이드오프 분석을 수행
  - 다양한 아키텍처 옵션 간의 트레이드오프 분석을 수행하여 각 옵션의 장단점을 이해하고 최종 아키텍처를 선택

------

#### Architecture Styles

- 비슷한 디자인 그룹의 공통 속성을 추상화
  - 유사한 그룹의 공통적인 특성, 속성을 추상화 요약하여 유사한 문제에 대하여 일관된 설계와 패턴을 사용 할 수 있음
- 시스템을 구성 요소와 이를 연결하는 커넥터의 집합으로 구조화하는것에 대한 규칙과 제약 조건, 패턴을 포함
- 구성 요소 유형의 전체적인 패턴과 흐름 제어 및 데이터 전송의 런타임 상호 작용을 지배
  - 구성요소들이 런타임 시에 어떻게 상호 작용하며 데이터 흐름과 제어 흐름을 조절하는지 관리

------

#### Key components of an architecture style

- Elements : 시스템에서 필요한 기능을 수행
- Connectors : element들의 상호작용 지원
- Constraints : element가 시스템을 형성하는 방법을 정의하는 제약 조건
- Attributes : 선택한 구조의 장단점을 설명

------

#### Software Architecture Design Guidelines

- '어떻게' 보다 '무엇을'을 먼저 생각해라
  - 무엇을 달성해야 하는지 먼저 고려해라
  - 시스템의 기능적, 비기능적 요구 사항을 먼저 파악한 후에 세부 디자인 작업을 수행 하라는 의미
- 구상 디자인을 생각하기 전에 추상적 디자인을 생각해라
  - 시스템 구성 요소의 인터페이스와 추상 데이터 유형을 먼저 수립해야함
  - 그 후에 시스템의 기본 구조와 상호 작용 방식을 정의
- 디자인 초기에 비기능적 요구 사항을 고려해라
  - 기능적 요구사항을 아키텍처 디자인에 매핑할때 비기능적 요구사항을 함계 고려해야함
  - 따라서 성능, 보안 등의 비기능적 요구사항을 초기에 고려해야한다
- 소프트웨어의 재사용성과 확장성을 고려해라
  - 새로운 시스템의 신뢰성과 비용의 효율을 위해
- 각 요소 내에서는 높은 응집도를 유지하고 요소들 간에는 느슨한 결합도를 유지해라
  - 유지보수와 확장성을 위해 요소가 자체적으로 의미 있는 수행하고 다른 요소들과는 느슨하게 결합되도록
- 설계의 수정을 허용하세요
  - 초기 설계가 완벽하지 않기 때문
- 모호한 설계와 과도하게 상세한 설계를 피해라
  - 모호하면 제약이 부족하고 과도하게 상세하면 구현을 제한함

------

#### Models for Software Architecture

- 아키텍처는 시스템의 고수준 추상화를 명시함
  - 이를 위해 분해, 조합, 아키텍처 스타일, 품질 속성을 활용
- 아키텍처가 포함하는 내용
  - 구성 요소와 구성요소 간의 설명
  - 구성 요소들 간의 상호작용
  - 모든 구성 요소와 연결(커넥터)의 배치 구성
  - 프로젝트의 기능, 비기능적 요구사항

------

#### Ways to describe Software Architecture

- Box and Line 다이어그램
  - 박스로 비즈니스 개념 선으로 구성 요소 간의 관계를 표현
- UML
  - 소프트웨어 설계와 문서화를 위한 표준하ㅗ된 모델링 언어
  - 정적, 동적 다이어그램으로 나뉨
- 아키텍처 뷰 모델(4+1뷰 모델)
  - 4+1뷰 모델
  - 논리, 프로세스, 개발, 구현, 사용사례 뷰로 구성
- ADL(Architecture Description Language, ADL)
  - ADL은 소프트웨어 아키텍처를 형식적이고 의미론적으로 설명하는데 사용
  - 정확하고 포괄적인 문서화 및 이해를 도움



---

# 소프트웨어 아키텍처 - 6(Quality Attributes)

> ## Quality Attribute

- 제품 또는 서비스의 모든 특성과 특징의 총체는 명시적 또는 암시적으로 제시된 요구를 충족하는 능력에 영향을 미친다
  - 품질의 정의, 서비스의 특성과 특징은 품질을 만족 시키기 위해 고려되어야 함

------

#### Quality Attribute

- 품질특성이란 양이나 질로 관찰하여 수치로 측정할 수 있는 시스템의 특성
- 품질특성은 시스템의 비기능적 요구사항의 중요한 부분이다
- 시스템의 측정 가능하거나 테스트 가능한 속성으로 관계자의 요구사항을 얼마나 효과적으로 충족시키는지를 나타냄

------

#### Quality Attributes in Implementation

- Implementation attributes(런타임시 관측되지 않는 구현 특성에서의 퀄리티 특성)
  - Interoperability(상호 운용성)
    - 내부 구성 요소 간의 데이터 교환 및 보편적 접근성
  - Maintainability and Extensibility(유지보수성 및 확장성)
    - 시스템을 수정하고 편리하게 확장할 수 있는 능력
  - Testability(테스트 가능성)
    - 시스템의 테스트 케이스 수립의 난이도
  - Portability(이식성)
    - 소프트웨어 및 하드웨어 플랫폼에 대한 독립성 수준(독립성이 높아야 다른 플랫폼으로 이동하기 유리함)
  - Scalability(확장성)
    - 사용자 요청의 증가에 대응하는 시스템의 능력(기능적보단 규모적인 측면 강조)
  - Flexibility(유연성)
    - 원래 설계된 목적 외의 다양한 환경이나 문제에 맞게 수정할 수 있는 능력

------

#### Quality Attributes in Runtime

- Runtime attributes(런타임시 관찰 가능한 퀄리티 특성)
  - Availability(가용성)
    - 시스템이 이용 가능한 능력(연중무휴 그런 느낌)
  - Security(보안)
    - 시스템이 외부 또는 내부로부터의 악의적인 공격에 대응하는 능력
  - Performance(성능)
    - 시스템의 응답 시간, 처리량 및 자원 활용과 관련된 효율성 향상
  - Usability(사용성)
    - 시스템을 사용함으로써 사용자의 만족도 수준
  - Reliability(신뢰성)
    - 장애 발생 빈도, 출력 결과의 정확성, 고장에서의 복구능력, 고장 예측 능력 및 평균 고장 시간
  - Maintainability(유지보수성)
    - (확장성, 적응성, 서비스 가능성, 테스트 가능성, 호환성 및 설정 가능성): 소프트웨어 시스템 변경의 편의성

------

#### Quality Attributes in Business needs

- 비즈니스 특성
  - Time to market(출시 시간): 요구사항 분석부터 제품이 출시되는 날짜까지 걸리는 시간
  - Cost(비용): 시스템을 구축, 유지 보수 및 운영하는 비용
  - Lifetime(수명): 제품이 사용되는 기간, 제품이 사용 종료되기까지의 시간

##### *비즈니스 측면에서의 소프트웨어 퀄리티*

------

#### Typical quality attribute tradeoff pairs(상충관계)

- 여러 조합이 존재하긴 하지만 일반적인 tradeoff의 쌍이 있음
  - 신뢰성 and 성능
    - 시스템의 안정성과 오류 없이 작동하는 능력인 신뢰성을 달성하기 위해 추가적인 안정화, 오류 처리 메커니즘을 도입하면 성능이 저하될 수 있음
  - 확장성(Scalability) and 성능
    - 더 많은 사용자나 데이터를 처리하기 위해 더 많은 자원을 할당하여 확장성을 향상시킬 수 있지만 이로 인해 성능이 희생될 수 있음



---

# 소프트웨어 아키텍처 - 7(Quality)

> ## Quality

------

### Product Quality Model(품질 모델)

- 품질 모델의 구조
  - Quality
    - 목표 시스템이 풍족해야 할 품질
  - Quality Factor
    - 사용자나 관리자 중심
    - 시스템이 외부에 보이는 품질
  - Quality Subfactor
    - 구현자 중심
    - 시스템 내부에서 다루는 품질
    - Quality Factor를 측정할 수 있는 소프트웨어 속성으로 바꾼 것
  - Metric
    - 평가자 중심
    - 품질을 측정하는 방법과 척도
- ![img](https://velog.velcdn.com/images/3eung_h10n/post/1b169521-9172-4df3-b080-6be37b98f2bb/image.png)
- 품질 모델 구조의 적용 예시
  - ![img](https://velog.velcdn.com/images/3eung_h10n/post/219f148b-90db-4304-866f-e16e1fc44962/image.png)

------

#### ISO/IEC 9126 모델

- ISO와IEC에 의해 제안된 품질 모델 소프트웨어 품질 인증을 위한 국제 표준
  - 이후 ISO/IEC 25010:2011로 대체됨
- 품질 모델 프레임 워크
  - 라이프 사이클에서 품질
    - ![img](https://velog.velcdn.com/images/3eung_h10n/post/412ff4d1-b588-4805-9929-9be929e1cfec/image.png)
- ![img](https://velog.velcdn.com/images/3eung_h10n/post/1879120e-61a8-425a-ad9f-ccbecf8f7a18/image.png)
- 각 항목에 세부 사항들이 있음
  - ![img](https://velog.velcdn.com/images/3eung_h10n/post/294742e2-26bb-4250-afb4-032ae0b083ea/image.png)

------

- ![img](https://velog.velcdn.com/images/3eung_h10n/post/cd76be77-4c2a-4d3e-94bf-8c626be6b538/image.png)

- ![img](https://velog.velcdn.com/images/3eung_h10n/post/7b64f5e3-4e87-4895-ada8-d6806efbf2d0/image.png)

- ![img](https://velog.velcdn.com/images/3eung_h10n/post/04eee0b3-7c05-4caa-a660-228fc3bd136f/image.png)

- #### ISO 25010

  - ![img](https://velog.velcdn.com/images/3eung_h10n/post/d904366d-dda7-4f13-aaf8-ecb0e4b6dc93/image.png)

  ------

  #### Functional Suitability

  - 제품, 시스템이 제시된 요구사항을 지정된 조건에서 사용할 때 어느 정도로 만족시키는 기능을 제공하는지를 나타냄
    - Functional Completeness(기능적 완성도)
      - 제시된 작업과 사용자의 요구사항을 처리하고 지원하는데 어느 정도로 완전한지
    - Functional Correctness(기능적 정확성)
      - 시스템이 정확하고 필요한 정밀도로 결과를 산출하는 데 어느정도로 정확한지
    - Functional Appropriateness(기능적 적절성)
      - 시스템의 기능이 명시된 작업과 목표를 효과적으로 수행하는지

  ------

  #### Performance efficiency

  - 제시된 조건 하에서 사용된 자원 양에 대한 성능
    - Time Behavior(시간 동작)
      - 응답 및 처리 시간과 처리량 비율이 요구 사항을 얼마나 충족시키는지를 나타냄
    - Resource Utilization(자원 활용)
      - 기능을 수행하는 동안 사용되는 자원의 양과 유형이 요구 사항을 얼마나 충족시키는지
    - Capacity(용량)
      - 시스템이 가지는 최대 한계치(데이터 양, 연결 수등)을 얼마나 충족시키는지

  ------

  #### Compatibility

  - 다른 제품, 시스템과 소프트웨어 환경을 공유하면서 정보를 교환하고 필요한 기능을 수행하는 능력
    - Co-existence(공존성)
      - 다른 제품들과 공통의 환경 및 자원을 공유하면서 필요한 기능을 수행할 수 있는 정도
    - Interoperability(상호 운용성)
      - 두 개 이상의 시스템이 정보를 교환하고 교환된 정보를 사용할 수 있는 정도

  ------

  #### Usability

  - 사용자에게 만족도를 느끼게 하며 명시된 목표를 달성할 수 있는 정도
    - Appropriateness(적절성)
      - 사용자가 자신의 요구 사항을 시스템이 어느 정도로 만족 시켜주는지 인식할 수 있는 능력
    - Recognizability(인식성)
      - 사용자가 시스템을 보고 쉽게 알아볼 수 있는 능력
    - Learnability (학습성)
      - 사용자가 시스템을 사용하여 목표를 달성하고 학습하는 데 어느 정도로 효과적인지
    - Operability(운용성)
      - 제품 또는 시스템이 쉽게 작동하고 제어할 수 있는지
    - User Error Protection(사용자 오류 방지)
      - 사용자가 실수 하지 않도록 보호하는 정도
    - User Interface Aesthetics(사용자 인터페이스 미학성)
      - 인터페이스가 사용자에게 쾌적하고 만족스러운 상호 작용을 가능하게 하는 정도
    - Accessibility (접근성)
      - 다양한 사용자 그룹이 시스템을 사용할 수 있도록 하는 능력

  ------

  #### Reliability

  - 시스템이 제시된 기간과 조건 하에서 제시된 기능을 어느 정도로 수행하는지
    - Maturity(성숙도)
      - 시스템이 정상적인 운영 상황에서 얼마나 안정되고 신뢰성 있게 작동하는지
    - Availability(가용성)
      - 시스템이 필요한 시점에 작동 가능하고 접근 가능한 정도
    - Fault Tolerance(고장 허용성)
      - 시스템이 하드웨어 또는 소프트웨어의 결함이 존재하는 상황에서도 의도대로 작동하는 정도, 시스템이 결함이 발생해도 중단 없이 작동하고 데이터 무결성을 보존하는 능력
    - Recoverability(복구성)
      - 시스템이 중단이나 장애 발생 시 영향을 받은 데이터를 복구하고 원하는 시스템 상태를 다시 설정할 수 있는 정도

  ------

  #### Security

  - 정보와 데이터에 대한 엑세스 권한 유형 및 수준에 적절한 정도의 데이터 엑세스를 가지도록 하는 것
    - Confidentiality(기밀성)
      - 데이터에 대한 접근을 권한을 가진 사람들에게만 허용하고, 무단 엑세스로부터 데이터를 보호하는 정도
    - Integrity(무결성)
      - 데이터에 대한 무단 엑세스와 변경을 방지하는 정도
    - Non-repudiation(부인 방지)
      - 행동 또는 이벤트가 발생하였을때 나중에 반박할 수 없도록 증명할 수 있는 정도
    - Accountability(책임 추적성)
      - 엔티티의 행동이 고유하게 추적될 수 있는 정도, 특정 엔티티(사용자)의 행동을 추적하고 책임을 할당할 수 있는 능력
    - Authenticity(인증성)
      - 특정 주체나 자원이 자신이 주장한 정체성과 일치하는지를 확인할 수 있는 능력

  ------

  #### Maintainability

  - 시스템이 주어진 환경이나 요구 사항의 변화에 얼마나 빠르게 적응할 수 있는지를 나타냄
    - Modularity (모듈성)
      - 시스템이 별개의 구성 요소로 구성되어 있어서 한 요소를 변경하더라도 다른 요소에 미치는 영향이 최소한으로 제한되는 정도
    - Reusability (재사용성)
      - 자산(Asset)이 하나 이상의 시스템에서 사용되거나 다른 자산을 구축하는데 어느 정도로 사용될 수 있는지
    - Analyzability (분석 가능성)
      - 의도된 변경이 시스템에 미치는 영향을 평가하는 데 효과적이고 효율적으로 판단할 수 있는지
    - Modifiability (수정 가능성)
      - 수정과정에서 새로운 결함을 도입하지 않고 기존 제품 품질을 저하시키지 않고 어느 정도로 가능한지를 평가
    - Testability (테스트 가능성)
      - 시스템에 대한 테스트 기준을 설정하고 이 기준이 충족되었는지를 확인하기 위한 테스트를 수행하는 데 어느 정도로 효과적이고 효율적인지

  ------

  #### Portability

  - 시스템이 다른 사용 환경으로 전환될 때 얼마나 효과적이고 효율적으로 전환될 수 있는지를 나타내는 정도
    - Adaptability (적응성)
      - 다른 하드웨어, 소프트웨어등 사용 환경에 효과적으로 사용 가능하도록 수정하거나 적응 시킬 수 있는 능력
    - Installability (설치 가능성)
      - 시스템이 특정 환경에서 성공적으로 설치되거나 제거될 수 있는 효과적이고 효율적인 정도
    - Replaceability (대체 가능성)
      - 다른 소프트웨어를 대체하고 같은 환경에서 같은 목적으로 사용할 수 있는 능력

  ------

  ### ISO/IEC 9126

  - ![img](https://velog.velcdn.com/images/3eung_h10n/post/2af48b15-d8ed-4902-9660-cc1e7d10322f/image.png)
  - ![img](https://velog.velcdn.com/images/3eung_h10n/post/bc1fcad7-62b6-43d3-abe5-5ddefea75bfa/image.png)
  - ![img](https://velog.velcdn.com/images/3eung_h10n/post/b9e0771c-d65f-4634-af04-21bd9c6ed7ea/image.png)



# 소프트웨어 아키텍처 - 8(GRASP)

> ## GRASP Design Principles

- General Responsibility Assignment Software Patterns(GRASP)
  - 객체지향 소프트웨어 디자인에서 사용되는 기본적이고 범용적인 원칙들을 패턴 형태로 제시

------

### GRASP Design

- 객체지향 프로그램 디자인에서는 책임을 할당하는 것이 매우 중요(변경 가능성과 재사용성을 위함)
  - 책임을 할당하는 중요성
    - 객체가 수행해야 하는 작업과 역할은 디자인의 핵심 부분이며 이를 올바르게 할당해야함
  - 디자인 방향 제공
    - 책임 할당은 클래스에 어떤 역할을 부여할 것인지 객체 간 상호 작용을 어떻게 정의할 것인지에 대한 방향 ㅈ공
  - 객체와 책임 식별
    - 객체와 그들이 수행해야 하는 책임을 식별하는 것은 소프트웨어 디자인의 출발점
  - 클래스 결정
    - 클래스는 객체의 템플릿이고 공통된 책임집합을 갖는다, 클래스를 결정할때 각각 다른 객체가 어떤 책임을 갖는지 고려해야 함

------

### Responsibilities and Methods

- Responsibility : 책임은 클래스의 계약 또는 의미이고 이를 메서드를 사용하여 구현해야함, 메서드는 단독이나 다른 메서드, 객체와 협력하여 동작
- 책임은 두 가지 유형으로 나눌 수 있음
  - Doing Responsibility
    - 클래스가 직접 수행하는 작업
    - 클래스가 스스로 작업을 수행하거나 다른 객체에 작업을 요청, 다른 객체의 활동을 조정하는 등의 동작을 포함
    - 클래스가 실제로 무언가를 수행하는 역할
  - Knowing Responsibility
    - 클래스가 정보를 알고 있는 역할
    - 자체 데이터, 관련된 객체에 대한 정보, 계산된 값을 알고 있는 경우 등
    - 클래스가 정보를 제공하거나 검색하는 역할

#### *자동차 클래스의 운전이라는 책임은 doing responsibility이고 자동차 클래스가 직접 운전을 수행 연료 레벨 확인이라는 책임은 knowing responsibility이며 자동차 클래스가 자체적으로 연료 레벨을 알려주거나 다른 객체로 연료 레벨 정보를 제공*

------

> ### GRASP Patterns

1. Low Coupling
2. High Cohesion
3. Expert
4. Creator
5. Controller
6. Don’t talk to Stranger

------

### Low Coupling

- 결합 : 다른 클래스에 대한 지식을 가지고 있는지 다른 클래스에 의존하는지를 측정하는 지표
  - 결합의 측정
    - 하나의 클래스나 모듈이 다른 클래스, 모듀렝 얼마나 의존하거나 연결되어 있는지
  - 높은 결합도의 문제점
    - 연결된 클래스의 변경이 다른 클래스의 변경을 강제할 수 있음
    - 개별 클래스를 이해하거나 테스트하기 어렵게 만들 수 있음
    - 재사용성의 저하
  - 원칙
    - 낮은 결합도를 유지하기 위해 책임을 할당할 떄 고려 해야함

------

### High Cohesion

- 응집도 : 클래스 내부의 책임들이 얼마나 관련되어 있고 집중되어 있는지

  - 응집도 측정
    - 하나의 클래스가 관련된 책임을 가지고 있는 정도 응집도가 높으면 클래스의 책임이 서로 관련되어 있고 중점적, 응집도가 낮으면 클래스의 책임이 서로 관련 없거나 다양한 작업을 수행
  - 낮은 응집도의 문제점
    - 클래스가 관련 없는 작업을 수행하거나 너무 많은 작업을 처리할 떄 응집도가 낮음
    - 이러한 클래스는 이해하기 어렵고, 재사용 및 유지보수에 불리
    - 변경에 대한 민감성이 높아지며 코드가 복잡해짐
  - 원칙
    - 복잡성을 관리하기 위해 책임을 할당할 때 응집도를 높게 유지해야함
  - 목적을 명확하게 정의(이것도 응집도를 높이는 방법 중 하나임)
    - 쉬운 이해와 유지 관리
    - 코드 재사용
    - 결합도를 최소화 할 수 있음(결합도와 응집성은 다른 것)

  ------

  #### 결합성과 응집도

- ![img](https://velog.velcdn.com/images/3eung_h10n/post/6425adf2-6c3d-4f11-ab91-e44c9a31b49e/image.png)

------

### Expert

- expert 패턴 : 책임을 할당하는 데 사용되는 패턴 중 하나, 어떤 클래스에게 책임을 할당할 때 정보 전문가(expert 클래스)에게 그 책임을 할당하는 원칙
- 원칙
  - 필요한 정보를 가지고 있는 클래스에게 책임을 할당, expert클래스가 정보를 모두 알기 떄문에 expert클래스가 책임을 할당 받음
  - expert클래스는 모든 정보를 가지고 있음, 경우에 따라 다른 클래스와 협력하여 책임을 수행
- 이점
  - 캡슐화 유지
    - 책임을 할당하는 클래스가 자신의 정보를 사용하므로 클래스가 자체 데이터에 접근하고 조작하기 떄문에 캡슐화 유지
  - 낮은 결합도
    - 클래스 간의 존속성을 피하므로 결합도가 낮아짐
  - 행동 분산
    - 특정 행동이 필요한 정보를 가지고 있는 클래스로 분산, 클래스의 코드 이해 및 유지관리에 용이
  - 높은 응집도
    - 클래스의 책임을 정보와 관련성에 따라 할당하므로 응집도가 높음

#### *주문 처리 시스템에서 주문을 취소하는 책임은 주문 정보를 가지고 있는 주문 클래스가 expert역할을 할 수 있음*

#### *Expert 패턴에서 책임을 할당하는 클래스가 정보와 관련된 작업을 적절하게 할 수 있으며, 객체간의 협력을 효율적으로 관리 할 수 있음*

------

### Creator

- 클래스 간의 생성 관계를 결정하고 어떤 클래스가 다른 클래스의 인스턴스를 생성할 책임을 가질 수 있는지 결정
  - 객체 간 연관 및 상호 작용에 기반한 생성자 결정
    - 클래스 간의 생성자 역할을 결정할 때 객체 간의 연관과 상호 작용을 고려해서 어떤 클래스가 다른 클래스의 인스턴스를 생성해야 하는지 결정
    - 클래스 B가 클래스 A의 인스턴스 생성 책임을 가질 때의 조건
      - 클래스 B가 클래스 A의 객체를 집계(aggregates)하거나 포함(contains)하거나 기록(records)하거나 밀접하게 사용(closely uses)하는 경우, 클래스 B에게 클래스 A의 인스턴스를 생성하는 책임을 할당할 수 있음
      - 또한, 클래스 B가 클래스 A의 인스턴스를 생성할 때 필요한 초기화 데이터를 가지고 있는 경우, 클래스 B는 클래스 A를 생성하는 전문가(Expert)로 간주됨

------

### Controller

- 외부 이벤트와 내부 이벤트 간의 결합을 관리하기 위한 필요성이 있음
- 해결방향 : controller라는 개체를 만들어 외부 이벤트를 받고 해당 이벤트를 적절한 내부 이벤트 핸들링 개체로 전달하는 책임을 부여
- contoller의 역할
  - 시스템 전체를 나타내는 객체
    - 시스템 전체의 이벤트 처리와 관련된 외부 이벤트 소스와 내부 이벤트 핸들러간의 관계를 담당
  - 유스 케이스를 나타내는 객체
    - 특정 유스 케이스에 대한 시퀀스 또는 작업을 처리하는 데 사용
- Solution(이벤트 처리를 다루는 책임에 따른 클래스 할당)
  - 전체 시스템을 나타내는 클래스
    - 시스템 전체의 이벤트 처리 및 관리를 담당하는 클래스, 시스템의 외부 이벤트를 내부 이벤트 핸들링 객체로 조율
  - 전체 비즈니스 또는 조직을 나타내는 클래스
    - 조직 전반의 이벤트 처리를 관리하는 클래스, 시스템의 핵심 비즈니스 로직을 제어
  - 실제 세계에서 활동 중인 것을 나타내는 클래스
    - 실제 세계에서 활동중인 역할 또는 개체를 나타내는 클래스로 해당 역할의 이벤트 처리를 담당
  - 유스 케이스의 모든 시스템 이벤트를 처리하는 인공 핸들러 클래스
    - 시스템 이벤트 처리를 담당하는 클래스(실질적 핸들러)
- 이점
  - 컨트롤러 클래스의 재사용
    - 컨트롤러 클래스는 시스템, 비즈니스 로직을 캡슐화, 이는 재사용 가능
  - 유스 케이스 관리
  - 활동 순서 제어

------

### Don’t talk to Stranger

- 클래스 간의 직접적인 상호 작용을 피하고 간접적인 통신을 통해 결합도를 낮추는 방법
  - 두 개의 클래스가 필수적이지 않다면 직접적으로 상호 작용하면 안 됨, 한 클래스가 다른 클래스의 메서드를 직접 호출하는 대신 중간계층의 다른 클래스를 통해 호출 해야함
  - 효과
    - 전체적인 결합도를 낮추는 효과



# 소프트웨어 아키텍처 - 9(SOLID Design Principle)

> ## SOLID Design Principles

- SOLID
  - ![img](https://velog.velcdn.com/images/3eung_h10n/post/8b917d46-a50e-413a-9a96-de43580c58f4/image.png)

------

### The Single Responsibility Principle (SRP)

- 클래스는 한 개의 책임을 가져야 한다
- 클래스를 변경하는 이유는 한 개여야한다
  - 클래스가 한 개의 이유로만 변경되려면 클래스가 한 개의 책임만을 가져야함
- 지켜지지 않은 사례
  - ![img](https://velog.velcdn.com/images/3eung_h10n/post/ee029592-0445-48e9-a749-186818324756/image.png)
  - 데이터를 읽고 화면에 보여주는 두 개의 책임이 한 클래스에 밀접하게 결합되어 있어서 코드 수정시 연쇄적으로 코드 수정이 일어남
  - 코드를 절차 지향적으로 만들었기 때문에 변경이 어려움
  - ![img](https://velog.velcdn.com/images/3eung_h10n/post/a66f9f10-5af3-425c-bf15-e0859105b612/image.png)
  - 2개의 클래스로 책임을 분리

------

### The Open / Closed Principle (OCP)

- 확장에는 열려있고 변경에는 닫혀 있어야 한다
  - Open - 기능을 변경하거나 확장 가능하도록 한다.
  - Closed - 그 기능을 사용하는 코드는 수정하지 않는다
- ![img](https://velog.velcdn.com/images/3eung_h10n/post/f111ea5d-d400-4f61-85e9-dbd1a42b869a/image.png)
- 상속을 활용해 상위 클래스의 기능을 그대로 사용하면서 하위 클래스에서 일부 구현을 오버 라이딩 하는 방법을 제공
  - ![img](https://velog.velcdn.com/images/3eung_h10n/post/6afbd318-75fd-4cad-8d60-fca57a99fe59/image.png)
  - 데이터를 압축해서 보내고 싶을때 하위 클래스에서 sendHeader, sendBody를 압축해서 보내는 기능으로 오버라이딩
  - responseSender 클래스는 확장에는 열려있으면서 변경에는 닫혀있게됨
- 개방 폐쇄 원칙을 어기는 코드
  - 다운 캐스팅
    - ![img](https://velog.velcdn.com/images/3eung_h10n/post/63e5f93a-cc01-470c-ba5d-4642a45b06f4/image.png)
    - character 파라미터의 타입이 Missile인 경우 별로 처리하는데 이 함수는 Character 클래스가 확장될 때 함께 수정되어야 함
    - 변경에 닫혀 있지 않다
  - 비슷한 if-else 블록이 존재
    - ![img](https://velog.velcdn.com/images/3eung_h10n/post/9837b507-a6dc-491e-a9af-1eebda5533ff/image.png)
    - 새로운 경로를 추가할 경우 draw 메서드에 새로운 if블록이 추가됨 -> 경로를 추가하는데 Enemy 클래스가 닫혀 있지 않다.
    - ![img](https://velog.velcdn.com/images/3eung_h10n/post/83136a4d-8659-4cb3-8e18-5e54678b2af2/image.png)
    - pathpatter의 추상화 타입을 사용해 새로운 경로를 추가할때 Enemy의 draw메서드는 변경되지 않고 pathpattern 클래스만 추가해주면 됨

------

### The Liskov Substitution Principle (LSP)

- 리스코프 치환 원칙
- 개방 폐쇄 원칙을 받쳐주는 다형성에 관한 원칙 제공
- 상위 타입의 객체를 하위 타입의 객체로 치환해도 상위 타입을 사용하는 프로그램은 정상적으로 동작해야한다

------

- ![img](https://velog.velcdn.com/images/3eung_h10n/post/8e292443-7e83-48cc-ba2a-b9fb10e1a1f7/image.png)
- ![img](https://velog.velcdn.com/images/3eung_h10n/post/19b4c932-9e5e-460e-8f7a-1e5cb1f7f976/image.png)
- addTaxes()함수가 ITaxCalculatorAdapter의 구체적인 구현에 의존하지 않고, 어떤 종류의 세금 계산기 구현체를 전달하더라도 올바르게 동작해야 한다는 것을 의미

------

#### 리스코프 치환 원칙 위배 사례

- 직사각형, 정사각형
  - ![img](https://velog.velcdn.com/images/3eung_h10n/post/7a146843-6fb0-4e5b-bdf9-cd9d47b501a9/image.png)
  - 여기서 직사각형에 width와 height를 비교해 높이를 더 길게 만드는 기능을 제공하면 정사각형의 setheight는 두 값을 같게 만들기 떄문에 해당 헤더스를 실행하더라도 높이가 더 길어지지 않는다
  - ![img](https://velog.velcdn.com/images/3eung_h10n/post/40f39fd4-ea2d-4399-a64c-9cd4d5d30c3d/image.png)
  - 이를 해결하기 위해 정사각형에 해당하는 타입이 들어오면 새롭게 구현하는 것은 리스코프 치환원칙을 위반하면서도 Rectangle의 확장에 열려있지 않게 됨
  - 실제 구현에서는 정사각형을 직사각형의 상속을 받기보다 별개의 타입으로 구현해주는 것이 좋음
- 상위 타입에서 지정한 리턴 값의 범위에 해당하지 않는 값을 리턴하는 것
  - ![img](https://velog.velcdn.com/images/3eung_h10n/post/2eb0701d-ff28-4b7b-afa7-a631710ac805/image.png)
  - 입력 데이터를 읽어 출력 스트림에 복사하는 기능 구현
  - ![img](https://velog.velcdn.com/images/3eung_h10n/post/014ca00b-0690-4aff-b583-4e3926c9d3bb/image.png)
  - CopyUtil.copy()는 inputstream의 read()가 -1일때 반복문을 멈춤
  - SatanlnputStream의 read() 메서드는 데이터가 없을때 0을 리턴하기 때문에 실행이 끝나지 않는다
- 특정 타입을 사용하는 코드에서는 다른 타입이 존재하는지 알 필요 없이 상위타입만 사용해야 한다
  - ![img](https://velog.velcdn.com/images/3eung_h10n/post/66c279b7-f95e-4904-8836-ddaee1e75187/image.png)
  - 코드에서 SpecialItem의 존재여부를 알 필요가 없어야함
  - ![img](https://velog.velcdn.com/images/3eung_h10n/post/1253f754-b877-4fe6-920d-5e174f5bc096/image.png)
  - 아이템 클래스에서 구현
  - ![img](https://velog.velcdn.com/images/3eung_h10n/post/293264bf-64ab-42dd-8bdd-17b06cb1c784/image.png)
  - 코드에서는 instanceof 연산자를 제거하고 메서드만 사용
- 리스코프 치환 원칙 정리
  - ![img](https://velog.velcdn.com/images/3eung_h10n/post/02ea0fce-7ba1-4dbb-b71e-dc4f7a8a0ba3/image.png)

------

### The Interface Segregation Principle (ISP)

- 인터페이스는 사용하는 클라이언트를 기준으로 분리해야 한다
- 클라이언트는 자신이 사용하는 메서드에만 의존해야 함

------

- ![img](https://velog.velcdn.com/images/3eung_h10n/post/9f258c0f-56ec-432a-9b07-dab85deb3598/image.png)
- 단일 책임 원칙이 지켜지면 인터페이스와 클래스의 재사용 가능성이 향상됨
- 클라이언트 입장에서 인터페이스를 분리한다는 것이 중요한 관점
  - ![img](https://velog.velcdn.com/images/3eung_h10n/post/05246656-6243-41f3-956c-a7b7cdedc543/image.png)

------

### The Dependency Inversion Principle (DIP)

- 고수준 모듈은 저수준 모듈의 구현에 의존하면 안됨
- 저수준 모듈이 고수준 모듈에 의한 추상 타입에 의존해야함

------

- ![img](https://velog.velcdn.com/images/3eung_h10n/post/9249f7ce-162d-4edf-8126-eef09f5fdf9d/image.png)
- 의존 역전 원칙을 적용해 클래스가 추상화 타입에 의존하게 만듬
  - ![img](https://velog.velcdn.com/images/3eung_h10n/post/b3f3b3a2-5f47-4d5d-988d-712fa7ca9ab3/image.png)
- 코드에서의 의존은 역전 되었지만 런타임에서의 의존은 고수준에서 저수준으로 향함
- 런타임이 아닌 코드에서 의존을 역전시킴으로써 변경의 유연함을 확보
- ![img](https://velog.velcdn.com/images/3eung_h10n/post/b16a6fb1-5db9-488a-bb56-6ef67f5032f3/image.png)
- 타입의 소유도 역전 시킴
  - ![img](https://velog.velcdn.com/images/3eung_h10n/post/23c13397-3f53-49c7-a79b-4cf0361a55d3/image.png)
  - 각 패키지를 독립적으로 배포할 수 있도록 만들어준다
- 개방 폐쇄 원칙을 클래스 수준뿐만 아니라 패키지 수준까지 확장시켜준다
  - ![img](https://velog.velcdn.com/images/3eung_h10n/post/6ebd46e2-397b-4af4-87cb-a1cdece4a6e5/image.png)



# 소프트웨어 아키텍처 - 10(Master-Slave Architecture Style)

> ## Master-Slave Architecture Style

------

### Hierarchical Software Architecture

- 개요
  - 시스템 전체를 계층 구조로 생각
  - 소프트웨어 시스템은 계층 구조의 다른 수준에서 논리적인 모듈로 분해
- 구조
  - 서로 다른 수준의 모듈은 메서드의 호출을 통해 연결
  - 낮은 수준은 인접한 상위 수준 모듈에 서비스를 제공하고 상위 수준 모듈은 낮은 수준의 모듈에서 메서드를 호출
  - ![img](https://velog.velcdn.com/images/3eung_h10n/post/1692a586-427d-4b5a-a822-a46122a1706b/image.png)
- 계층 구조는 다른 스타일과 결합되는 가장 인기 있는 스타일 중 하나
- Four kinds of architecture styles
  - Master-slave
  - Layered
  - Virtual machine & Container
  - Plug-In & Microkernel

------

### Master-Slave Architecture Style

- 개요
  - main-sub스타일의 변형, supports fault tolerance and system reliability(장애 허용, 시스템 신뢰성)
- 구조
  - slave들은 master에게 복제된 서비스를 제공하며, 마스터는 복제된 서비스의 호출을 구성, 슬레이브중 전략에 따라 하나의 결과(슬레이브)를 선택
  - 슬레이브들은 동일한 기능을 서로 다른 알고리즘과 방법 또는 완전히 다른 기능성(다른 역할을할 수도 있음)으로 수행할 수 있음
  - ![img](https://velog.velcdn.com/images/3eung_h10n/post/3e9a974d-8725-4977-9084-fe2f74fc484b/image.png)
  - ![img](https://velog.velcdn.com/images/3eung_h10n/post/91873bd0-1660-4b5d-85f1-bd9a1fe0a53f/image.png)
  - ![img](https://velog.velcdn.com/images/3eung_h10n/post/9bcddaa1-c7d2-4bc7-8ebb-f214b0bd8d57/image.png)

------

### Master-Slaver 특성

- 이 아키텍처는 병렬 컴퓨팅과 계산 정확도가 특성에 포함
- 모든 슬레이브는 병렬로 실행될 수 있음
- 동일한 작업이 여러 다른 구현에 위임되기 때문에 다수 투표 전략 또는 다른 알고리즘을 사용하여 부정확한 결과를 방지할 수 있음

------

- 신뢰성이 중요한 소프트웨어 시스템에서 사용
- 서버의 복제 때문에 가능함

#### *서버를 복제하여 시스템 내의 장애 발생 시 시스템을 계속 운영할 수 있도록 해주고 동일한 작업에 대한 여러 처리결과를 통해 신뢰성이 향상된다*

