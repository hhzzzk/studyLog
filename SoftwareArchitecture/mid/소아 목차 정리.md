# 소아 목차 정리

1. 소아 정의, 모듈, 
2. 소아 구조, 소아 목표(목표성능, 설계변수, 제약조건)>최적설계안
3. 소아 views, C&C, UML, 4+1 View model(logical / process/ implementation / deployment + usecase)
4. 소아 디자인, SDLC에 속함, SRS(솦요구사항명세_요구사항의모델링/설명(uml, dfd, std)/두가지측면(기능,비기능)), 
5. 소아 디자인 가이드라인, 

- 소아 tasks, 아키텍처 스타일, Key components of an architecture style(ECCA : 엘리먼트,커넥터,제약,어트리븉)
- 가이드라인 : how보다what먼저 / 구상x추상먼저 / 초기비기능적요구사항고려 / 재사용성,확장성 / 요소내높은응집도요소간느슨결합 / 설계수정허용 / 모호설계x, 너무 상세한 설계x
- 소아describe 방법 4가지__box and line다이어그램 / UML / 아키텍처뷰모델(4+1뷰모델) / ADL

6. Quility Attributes

- Quality Attributes in Implementation__런타임시 관측x 구현 특성에서 QA 6가지(상호운용성 / 유지보수및 확장성 /테스트 / 이식성 / 확장성 / 유연성)
- Quality Attributes in Runtime__런타임시 QA 6가지 (가용성,보안,성능,사용성,신뢰성,유지보수성)
- 비즈니스 니드 QA__출시시간,비용,수명
- QA 상충관계 : 신뢰성과 성능, 확장성과 성능



7. 퀼리티, 품질모델구조(퀼리티, 퀼리티팩터, 퀼리티서브팩터,metric)


8. GRASP:객지솦디자인의범용적원칙패턴

- 책임을 메소드로 구현 : 책임은 doing, knowing


- GRASP패턴 6가지(낮은커플,높은응집,전문가,크리에이터,컨트롤러,Don’t talk to Stranger)

9. SOLID (SRP, OCP, LSP, ISP, DIP) 코드예제
10. 마스터-슬레이브 아키텍처 스타일 : 복제된 서비스, 동일기능다른방법/다른기능, 병렬, 서버복제=신뢰성

- 4종류 아키텍처 스타일 : master-slave, layered, vm&container, plug-in&microkernel



11. MS-HDFS

- HDFS는 하둠 앱에서 사용되는 주요 분산 저장 시스템 (네임노드가관리, 데이터노드데이터저장)
- HDFS아키텍처 (네임노드,데이터노드,블록,Rack)
- Hadoop 플랫폼 : 대규모노드,데이터 병렬처리하기 위한 솦 프레임워크
- YARN :  전역 리소스 매니저 + 앱매니저(AM):작업스케줄링, 리소스 할당
- YARN아키텍처 : 리소스 매니저/노드매니저/앱마스터/컨테이너

12. Layered아키텍처스타일 : 여러레이어로분해,각레이어 역할+책임/추상화형성(분리,격리), 레이어간 요청 = 메소드호출반환

- two layers 솦시스템 : 인터랙션레이어/프로세싱 레이어
- 레이어아키텍처 클래스 다이어그램 : high,middle,low
- 장점: 하위레이어변경 상위레이어 영향x, 유연성up:재사용성,교환가능성,이식성
- 단점: 클라이언트 요청/응답이 여러 레이어 통과 = 런타임성능낮음, 데드락, 브리지 연결 높은 결합도, 한 레이어 결함이 모든 호출 레이어로 전파

13. VM 아키텍처 스타일 : 예시(unix 운영체제, microsotr.NET, JVM)

- 장점 : 이식성 및 기계 플랫폼 독립성, SW개발 간단, 오류작동 모델 시뮬레이션
- 단점 : 인터프리터의 느린 실행, 새로운 레이어로 인한 오버헤드

14. 플러그인 아키텍처 스타일 : 플로그인으로 추가 기능 제공, 확장성과 기능 분리

- 구조 : 기본 핵심 시스템(운영상최소한의기능) + 플러그인 모듈(독립적구성요소,확장)
- 고려사항 : 플러그인사이통신 최소화 = 종속성문제피함, 플러그인 레지스트리
- 예시 : 이클립스IDE에 플러그인 추가, 인터넷 브라우저, Claims processing, chromiun, firefox, chrome등
- 특성 : 이식성, 유연성, 정책과 매커니즘의 분리

15. Microkernel 아키텍처 스타일 : 이식good, 변화수용good

- 구조 : 마이크로커널, 내부서버, 외부서버, 클라이언트&어댑터
  - 마이크로커널: 중앙서비스구현, 시스템 특정 종속성은 여기 안에 캡슐화, 원자적 서비스 구현, 시스템 리소스 유지
  - 내부 : 기능 확장, 일부 의존성 캡슐화///어댑터 : 클라이언트와 외부 서버 간의 인터페이스 대표
- 장점: 휴대성, 유연성, 정책과 매커니즘의 분리
- 분산 마이크로커널의 이점 : 확장성, 신뢰성, 투명성, 성능, 설계 및 구현 복잡성

~계층구조스타일end

16. Distributed 아키텍처 : 통신! 네트워크 통해 연결된 계산 및 저장 장치의 모음이 분산 시스템

- 구조 : 중요2가지 네트워크 통신망(엔티티 연결된 네트워크 형성법), 통신모드(구성 요소가 서로 통신방법)
- 특징 : 서비스 위치 투명성 : 호출자의 물리적 위치나 지식 없이도 서비스 요청하고 사용 가능//서비스 신뢰성과 가용성
- 분산 아키텍처 스타일 : 클라리언트 서버 / multitier / proxy / dispatcher(load balancer) / p2p / broker / SOA / Microservice

17. client-server 아키텍처 스타일 : 가장 일반적인 분산 아키텍처, 다른 프로세서에서 실행되는 2개의 통신 프로세스 //////구조 : 시스템 = (클라이언트+서버)

- 장점 : 책임의 분리, 서버 컴포넌트의 재사용 /// 단점 : 요구사항 변경처리위한 인프라 부재, 보안 복잡성, 서버 가용성과 신뢰성, 테스트 용이성과 확장성, 두꺼운 클라이언트(ppt및비즈니스로직 포함된)

18. Multi-tiers아키텍처 스타일 

- One-tier아키텍처 : 메인프레임 기반 및 덤터미널(클라이언트 역할) 간의 상호작용 / 메인프레임 시스템 리소스 효율적 사용이 관심사  / 시스템 모든 구성 요소 메인프레임 내에 위치+모든처리 해당 메인프레임에서이뤄짐 / 덤 터미널은 주로 입력받고 메인프레임에서 처리된 결과를 화면에 단순표시장치
  - 프레젠테이션 계층전체가 메인프레임에 위치. 클라이언트 주로 입력과 출력만 담당
- two-tier아키텍처 : 대형컴퓨터(메인프레임 및 서버) 그룹과 소형컴퓨터(PC및 워크 스테이션) 그룹으로 구분
  - 프레젠테이션 계층은 클라이언트와 PC에서 수행 / 관리 목적 및 일반 사용자 위한 목적으로 사용
  - 응용 프로그램 로직 계층 및 리소스 관리 계층
- three-tier아키텍처 : 추상레벨 - 삼계층 아키텍처는 명확한 분리를 기반
  - 프레젠테이션 계층 : 클라이언트에 위치 사용자 인터페이스 관련 역할, 사용자와 상호작용 정보 시각화
  - 앱로직계층 : 중간계층, middleware를 포함한 추상화와 인프라 제공, 앱 핵심 비즈니스 로직 여기 구현
  - 리소스 관리 계층 : 서버 리소스 및 DB 등 백엔드 시스템 관리, 클라이언트 및 앱로직계층과 상호작용해 데이터 처리
- 2,3티어 비교 : 2티어는 앱 로직이 주로 클라이언트의 사용자 인터페이스 / 서버 DB / 혹은 둘 다에 위치함@@@ 3티어는 중간계층에 위치하고 확장가능, 견고하고 유연하다.
- 멀티티어장점 : 중간계층 추가로 재사용성 및 확장성up, 비즈니스변경사항(로직)은 중간계층에만 적용=클라이언트,서버 트랙픽 줄어 네트워크 효율 향상, 플랫폼 독립적 개발 가능, 확장성을 위한 멀티스레딩지원(병렬처리), 서버 신뢰성 및 가용성 향상 = 중간계층 장애발생해도 서버통해 작동유지
- 멀티티어단점 : 테스트어려움, 시스템에 여러 서버 추가하면 유지보수 어려움



19. Proxy 아키텍처 스타일

- 메소드 호출을 객체에 직접적 발생x 프록시 객체 이용 간접발생 / 프록시 객체는 일반적으로 서비스 제공객체와 공통 인터페이스나 슈퍼클래스 공유
- 프록시패턴(다른객체서비스 투명하게 관리하기 위해 프록시사용)
  - 즉시리턴 : 프록시작업 메서드실행시간long한 경우에도 즉시 리턴효과(클라이언트보기에)주는 프록시
  - 원격프록시 : 다른 기계의 객체가 로컬 객체처럼 보이게 하는 프록시
  - 액세스프록시 : 서비스 제공 객체에 대한 접근제어, 클라이언트의 접근통제, 보안및권한관리 제어
  - 가상프록시 : 서비스객체 실제 생성 이전에 이미 객체 존재하는 것처럼 보이게 하는(클라에게) 프록시
- 투명한서비스제공 : 클라이언트에게 서비스가 제공되는 것처럼 보이면서 실제로 어떻게 제공되는지에 대한 세부 정보 숨기는 것, 서비스가 어디에서 실행되고 어떻게 제공되는지에 대해 사용자가 인식x
- 클라이언트는 서비스에 접근하기 위해 프록시 사용
- 장점 : 원본객체에 대한 엑세스 제어(클라직접접근제어) / 메모리 절약(원본객체 필요할때만 생성or초기화) / 성능향상(캐시프록시) / 기능과 관리의 분리(비즈니스로직같은 핵심작업 분리, 유지보수+확장up)
- 단점 : 과도한 복잡성의 위험 / 간접성 수준







20. Dispatcher(load balancer) 아키텍처 스타일 : 분산컴퓨팅에서 사용되는 미들웨어 아키텍처

- 서버 팜farm을 클라이언트에게 단일 서버처럼 보이도록 만들 / 서버팜이 고도로 확장 가능성과 고가용성 달성 / 서버 부하 분산을 통한 높은 확장성 가용성
- 이러한 미들웨어 아키텍처는 대규모 분산 시스템에서 서버팜의 관리,부하분산,확장성등을 개선하고 클라이언트와 서버 간의 투명한 상호작용을 지원
- 맥락 : 모든요청 처리 단일서버 > 트래픽many, 용량부족 / 스케일업(용량증가) 고비용,단기적해결책
  - 응용 프로그램 구성요소는 저렴한 하드웨어와 운영체제 기반으로 한 서버 팜의 여러 인스턴스로 처리
- 강제사항 : 응용프로그램은 다양한 서버에서 여러 인스턴스로 실행되도록 설계 / 처리부하는 서버 그룹간 분산(서버 로드 밸런싱)
- 구조 : 요청은 클라이언트에게 투명한 전용 서버 로드 밸런서로 전달
  - 로드밸런서 : 가용성, 현재 서버 부하 등 매개변수 기반으로 서버 선택 후 요청 전달 > 트래픽 분산
    - 로드밸런싱알고리즘 : 로드밸런서는 서버 상태 및 부하 정보 검색해 트래픽 응답가능여부 확인
- 가용성 vs 확장성(scalability) : 가용성은 장애발생~정상작동시간(업타임)으로 정의, 고가용성=시스탬내의중복성(한서버실패하면 다른서버가 작업부하 투명하게(클라는안보임) 이어받음)
  - 고가용성을 달성하려면 로드밸런서가 서버를 모니터링해 과부하나 다운된 서버 거르기, 로드밸런서도 중복
  - 확장성 : 시스템이 수천개의 동시 클라이언트 서비스 가능 능력, 고확장성=서버로들어오는요청을 서버들 사이에 분산, 높은 가용성 달성하기
- 구현 : 서버 로드 밸런싱 솔루션 2가지__전송로드밸런싱transport-level / 응용프로그램로드밸런싱app-level
  - 전송로드밸런싱:dns기반orTCP/IP수준로드밸런싱과 같이 응용프로그램과 독립적으로 동작
  - 응용프로그램로드밸런싱: 응용프로그램 페이로드 사용해 로드밸런싱 결정
  - 로드밸런싱 솔루션2
    - 하드웨어기반로드밸런서 :transport level 로드밸런싱에 사용 / sw시간로밸보다 빠르지만비용 높
    - SW기반로드밸런서 : 표준os및 개인컴에서 실행, 전용로드밸런서 하드웨어 노드 내에서 실행 or 응용프로그램 내에서 직접 실행
- 예시 : dns기반로드밸런싱, tcp/ip서버 로드밸런싱



21. P2P 아키텍처 스타일 : 작업을 피어간 분할하는 분산아키텍처 / 공유자원, 참가자는 제공자+요청자

- 장점 : 중앙 단일 장애점 없음 / 확장성 / 전용응용프로그램 및 DB서버 필요X
- 단점 : 분산된 조정(전역상태일관유지어렵) / 모든노드 동등X / 보안부족
- 예시 : CPU사이크(GIMPS), PPStram, Oceanstore, murex, torrent, 친구찾기 등
- 분류 : 순수 p2p 시스템(중앙서비스x, 피어간모든통신서버도움x,소규모) / 혼합형(중앙서버부분의존=일부클라-서버아키텍처 보존=중앙서버가클라간연결관여) / 비구조화 / 구조화
- bitTorrent : 대용량파일전송에사용, 트래커,시드
- 장점 : 기능리소스의 확장성, 서버이식성, 리소스 활용
- 단점 : 보안, 익명연결위험성, 서비스 중복, 테스트 어렵





22. broker 아키텍처 스타일 : 등록된 서버와 클라간 통신 조정,용이하게 하기 분산컴퓨팅에서 사용되는 미들웨어 아키텍처 / 호출기반or클라가호출요청 서비스 / 문서나메시지지향or클라가메시지보내는XML로동작하는브로커


- 브로커를 통해 클라및서버구성요소가 분리돼 상호작용 / 브로커시스템==프록시기반시스템
- 서버는 브로커에 자신의 인터페이스 등록해 클라에 서비스 제공 / 클라는 브로커에서 서버서비스 정적동적 조회해 요청 / 브로커 구성 요소는 통신조정역할
- 서버:브로커에등록, 클라에 메서드 인터페이스 제공
- 클라: 브로커를 통해 서버 메소드에 엑세스
- 브로커 : 적절한서버찾기Location, 요청서버로전달forwarding, 결과및예외처리클라에 전달 transmitting
- 참여컴포넌트의 6가지 유형 : 클라(요청), 서버(응답,서비스제공), 브로커(통신중재), 브리지(서로다른넽/프로토콜사이 통신 연결/변환), 클라/서버프록시(통신지원)
- 하위구성요소 : 브로커 / 스텁(클라프록시) / 스켈레톤(섭프록시) / 브릿지 / 네트워크
  - 브로커 : 통신조정, 요청전달응답반환, 모든서버 등록정보(서버기능,서비스,위치정보)저장, 서버구성요소 등록및해제 지원
  - 스텁 : 클라와브로커간의 중재역할,둘사이 투명성 제공(프로토콜수준에서 프로세스간 통신 숨김), 정적컴파일시 생성, 매개변수값 marshaling, 서버결과 언마샬링
  - 스켈레톤 : 서비스 인터페이스 컴파일시 정적생성, 메서드인수 언마샬링하고 적절한서비스 호출, 서버로부터 결과수신>겨로가클라로 마샬링해서 보냄
  - 브릿지 : 두개의 브로커가 상호운영할때 구현정보 숨기는데 사용(선택적구성요소), 네트워크 세부 정보 캡슐화, 요청및매개변수를 다른형식으로 번역, 서로다른 통신 프로토콜인 두 네트워크 연결가능
  - 네트워크 : 지정된 프로토콜 사용해 구성요소 연결
- CORBA : Object Request, 플랫폼 및 언어에 독립적인 미들웨어 제공 / 코바객체가 제공하는 서비스및작업은 IDL인터페이스정의언어를 사용해 명시되므로 클라는 코바 객체의 구체적인 구현과 위치 알필요없이 요청수행=투명성
- 장점 : 서버 구성요소의 구현 및 위치 투명성 / 브로커 브릿지를 통한 상호운영(브릿지를통해 서로다른브로커시스템동시운용가능)
- 단점 : 프록시사용으로인한 성능저하 / low-fault tolerance(오류대응력낮음) / 프록시사용많아 테스트어렵



23. Message브로커 아키텍처 스타일 : 메시지 브로커 : m지향 분산 시스템에서 m중심 미들웨어(MOM) 서버

- m내용 기반해 라우팅 / 브로커는 m 형식 변경해 a,b(발/수신자)의다른 요구사항충족, 브로커 m변환가능
- m브로커sw : AWS MQ, 아파치 ActiveMQ, Kafka, 이클립스 MQTT브로커, IBM MQ...
- sol : a,b사이에 중개queue(m영구저장,다른큐와 협력해 m라우팅)도입 / m은 a,b로 전송되는 객체 / m API 제공
- 장점 : 재사용성및 유지관리(클라서버 느슨한 결합) / 비동기메시지처리(작업간효율적분산=대량m처리효율) / 유연성(여러유형m지원,m도목적에맞게변경가능)
- 단점 : 오버헤드, 간접성 복잡성 및 디버깅, 테스트 어렵

끝이안나



24. SOA(ServieOriented아키텍처)스타일 - 클라는 서비스 디렉토리 통해 서비스 찾고 다음 서비스요청응답으로 서비스 접근

- 언어3 : 일부흐름제어 언어 사용 / 웹서비스 BPEL / 오케스트레이션언어는 비즈니스 로직기반으로 비즈시느 실행 순서와 논리적 순서 지정
- 장점 : 느슨한결합(각서비스 독립적), 상호운용(플랫폼,언어구현 관계없이 다른 서비스 액세스 가능), 재사용성(어떤서비스든 다른서비스에서 재사용가능), 확장성



25. SOA & XML based 웹서비스 

- 웹서비스에서 SOA : 웹서비스는 SOAP,XML,HTTP같은 표준 프로토콜과 기술사용해 다른 서비스나 클라와 통신 / 웹서비스는 M중심서비스 / XML기반메시지 반정형구조=웹서비스아키텍처 보편적 접근 가능
- 웹서비스아키텍처의 기반특성 : SOAP(웹서간 통신프로토콜, 서버클라상호작용가능하게함) / UDDI(웹서설명및검색프로토콜) / WSDL(웹서세부정보정의-XML기반,웹서사용설명서)
- 웹서비스 : 네트워크로 기계간상호작용 지원 / 기계처리가능한형식으로설명된 인터페이스 가짐(WSDL) > 다른 시스템은 WSDL설명에따라 SOAP메시지로 상호작용 > M들은 XML직렬화사용해 HTTP로 전달
- SOAP프로토콜의2가지해석법 : SOA프로토콜( soap메시지로 서비스 호출하고 결과표현) / SOAP(Simple Object Access)__SOAP메시지는 원격메서드호출구현,로컬환경에서 원격환경으로 이동해야함을 나타냄
- SOAP메시지: 헤더, 본문, XML기반문서=어떤플랫폼에서든 독립적 작동, 다양한프로토콜로 전송가능, HTTP or SMTP같은 다양한 통신 프로토콜로 전송가능
- WSDL: 웹서설명서, 웹서 작업,메서드,인터페이스 설명 / 클라가 서비스요청하고이해도움
- BPEL : 비즈니스프로세스exe언어__xml기반언어, 웹서간협업및 프로세스 관리 / 비즈니스프로세스 구성 웹서 기술(서비스간 작업흐름 및 상호작용)
- 분산아키텍처 요약
  - 멀티티어 아키텍처 : 데이터및업무를 계층으로 분산 / 각 계층 고유 역할+책임 / 트래픽감소및 신뢰성 증가
  - 클라서버 아키텍처 : 현재널리사용
  - 브로커 아키텍처 : 브로커는 원격 구성요소 or 다른 브로커간 메시지 전달
  - CORBA : 원시브로커 아키텍처, 초기브로커 아키텍처 구현중 하나, 구성요소중심 아키텍처
  - SOA 아키텍처 : 비즈니스 간 기업에서널리사용 / 각서비스가구성요소, 타서비스구성요소나비즈니스 프로세스 앱에서 재사용가능



26. MicroService아키텍처 스타일 : 서비스간 느슨한결합, 각 서비스가 자체적인 context,범위가짐 / 큰 응용프로그램 작은서비스로 분해, 각서비스 독립적실행

- ms간상호통신 : 일반적으로표준화됨 HTTP(s)(널리사용되는검증된전송프로토콜,신뢰성) / REST(인터페이스) / JSON(간단하고가벼운데이터 표현 형식)
- 특징 : 마이크로크기=단일개발팀도 관리가능한 크기 / 기능시스템분해는수직슬라이딩, 레이어기반 전통적수평분해와 대조됨 / 독립배포가능=공유상태나프로세스간 통신없어야함 / 각마이크로서비스독립적확장가능
- 클래식SOA와 비교 : SOA(다양한앱 일련의 서비스로 통합, 다른앱간에 상호작용) / 마이크로(하나의앱을 일련의 서비스로 아키텍처화, 앱자체를 여러 작은 서비스(특정기능수행)로 분해)
- 3가지Aspect: 아키텍처측면(bounded context, api gateways, single책임), technical측면(run on its own process, independently2개, is stateless), organizational측면(small teams, you build it you run it)
- challenges : 성능, 코드중복, 트랜잭션, 인프라 이상의 요소
- 고려사항 : 올바른 기능분해(모듈화), 분산통신, 팀규모, 인프라구조, 대체가능성, 트랜잭션



27. Implicit Asynchronous 커뮤니케이션 소프트웨어 아키텍처

- 구조 : 시스템2개의파트로분할__publisher발생자(이벤트나메시지발표,전송) / subscriber구독자(이벤트나메시지 관심등록,처리)
- 통신방식 : p랑s는 동기or비동기적 방식으로 통신(동기는 요청응답연결-응답받을때가지 대기 / 비동기는 연결x, 다른작업수행, 대기x)
  - 일대일 / 일대다 / 다대일 통신
- explicit명시적호출(프로그램or시스템이 직접 특정 함수메소드 호출)
- implicit암시적 호출(프로그램or시스템이 이벤트or메시지발생>이거처리할핸들러는 미리등록된 구독자or리스너 중 자동선택 / 버튼클릭이나데이터도착 이벤트 발생 > 이벤트핸들러자동호출)
- non-buffered event-based : 이벤트핸들러 or 구독자와 이벤트발생자or 발행자간의 통신/ 이벤트 발생자>바로핸들러호출,전달
- buffeded messaged0based : 이벤트나메시지 버퍼에 저장, 대기 후 처리, 일대일/일대다가 해당
- 이벤트 발생자-구독자패턴 : 이벤트=p,s간 주고받는 아키텍처 패턴
  - s가p의 이벤트나메시지에 관심 > s가 p에 자신을 등록 > p에서 이벤트생기면 모든 구독자 알림받음 > 각 구독자 조치, 실행작업결정



28. Non-buffered event-based implicit invocations 아키텍처 스타일

- 구조__두파트로 분리 : 이벤트 소스(이벤트 발생) / 이벤트 리스너(이벤트처리 객체or함수)
  - 이벤트 등록 프로세스 : 리스너는 특정 이벤트 처리하려할때 해당 이벤트소스에 등록 / 등록프로세스로 두파트연결
  - 버퍼없는 통신 : 이벤트 발생시 이벤트소스에서 직접 리스너에 전달
- Non-buffered event-based : 오라클, IDE for CASE도구, 디버깅처리, 재고관리시스템
- 장점__컴포넌트재사용, 시스템 유지보수 및 진화, 독립성 및 유연연결, 이벤트처리의 병렬실행
- 단점__이벤트소스와 리스너간의 응답및 응답순서 예측어렵>디버깅어렵
  - 버퍼없는이벤트기반시스템에서 메시지 큐or메시지토픽 사용하면 소스와 리스너간 결합강해짐



29. Buffered MessageBased 아키텍처 스타일

- 구조__메시지 프로듀서(m생성), 메시지consumer(수신및처리), 메시지 서비스 제공자(m중개,전달=버퍼이자 이들웨어)