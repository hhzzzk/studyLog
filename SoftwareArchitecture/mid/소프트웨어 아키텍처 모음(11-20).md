# 소프트웨어 아키텍처 - 11(MS-HDFS)

> ## Master-Slave Hadoop Platform

------

#### Hadoop Distributed File System (HDFS)

- HDFS는 Hadoop 애플리케이션에서 사용되는 주요 분산 저장 시스템
  - namenode는 파일 시스템의 메타데이터를 관리(서버)
  - datanode는 실제 데이터를 저장
  - ![img](https://velog.velcdn.com/images/3eung_h10n/post/87a5abe0-4638-4ce5-b12f-6315a24f06d6/image.png)

------

#### HDFS Architecture

- NameNode
  - 아키텍처의 중심 역할을 하는 마스터 노드
  - 파일 시스템의 메타 데이터를 관리, 파일 디렉토리 구조 및 파일의 소유자 권한 정보등을 포함
- DataNode
  - 실제 데이터를 저장하고 관리하는 slave노드
  - 데이터 블록을 분산 저장하고 주기적으로 블록 복사본을 다른 DataNode로 복제하여 손실 방지
  - NameNode와 통신하여 파일 생성 삭제 복사 등을 처리
- Blcok(데이터 블록)
  - 일정한 크기의 블록으로 분할하여 데이터를 저장
  - 각 데이터 블록은 여러 DataNode에 복제되어 손실을 방지함
- Rack
  - 물리적 머신 그룹을 나타내는 개념
  - 데이터 복제는 랙 간의 데이터 복제와 랙 내 데이터 복제를 조절하여 안정성을 향상시킴
- ![img](https://velog.velcdn.com/images/3eung_h10n/post/3980ea54-79a0-4a8a-a866-1674f0262e46/image.png)

------

#### Hadoop Platform

- ![img](https://velog.velcdn.com/images/3eung_h10n/post/df0924bf-4d53-4df3-823e-e39b3758663d/image.png)
- 대규모의 노드와 데이터를 병렬로 처리하기 위한 소프트웨어 프레임워크


- MapReduce레이어
  - 단일 ResourceManager : 클러스터 전체의 리소스를 관리
  - 클러스터 노드 당 하나의 Slave nodeManager : 각 클러스터 노드에서 실행, 해당 노드의 리소스 사용상태를 관리
  - 어플리케이션 당 하나의 MRAppMaster : 각 어플리케이션을 위해 실행되며 어플리케이션의 작업을 조정 및 관리
  - ![img](https://velog.velcdn.com/images/3eung_h10n/post/fb751745-b41c-4503-a8bc-b65964c2d90b/image.png)
  - ![img](https://velog.velcdn.com/images/3eung_h10n/post/d49194c3-6264-4f44-ae36-f05c1f58b249/image.png)

------

#### YARN

- 리소스 관리와 작업 스케줄링 기능을 분리하는 아이디어를 기반으로한 소프트웨어 시스템
- YARN은 전역 리소스 매니저와 어플리케이션별 ApplicationMaster(AM)로 구성 AM은 해당 어플리케이션의 작업 스케줄링과 리소스 할당을 관리
  - ![img](https://velog.velcdn.com/images/3eung_h10n/post/7186a754-ab8b-4615-bd9b-83adc077d836/image.png)
- ![img](https://velog.velcdn.com/images/3eung_h10n/post/0d4d66b6-2915-4a26-8954-1527752c7e9c/image.png)

------

#### YARN 아키텍처

- ![img](https://velog.velcdn.com/images/3eung_h10n/post/7325a9ec-84c1-4eec-95ff-5a083073fc13/image.png)
- ResourceManager : 시스템 내에서 모든 어플리케이션 간에 리소스를 조정하는 궁극적인 권한을 가지며, 모든 어플리케이션에 할당되는 리소스를 관리
- NodeManager : 각 머신에서 실행 컨테이너를 관리 해당 머신의 리소스 사용 상황을 관리 및 RM에게 보고
- ApplicationMaster : RM에게 필요한 리소스를 얻고 NodeManager와 협력하여 작업을 실행
- Container : 각 노드에 대한 자원의 정보를 저장 및 관리

------

#### Application Submission in YARN

- ![img](https://velog.velcdn.com/images/3eung_h10n/post/29402b08-b15a-4094-a768-32a7c550d4c2/image.png)

#### Application Workflow in Hadoop YARN

- ![img](https://velog.velcdn.com/images/3eung_h10n/post/97f81dc3-a0d0-46aa-926b-83ffdccfd4c0/image.png)



# 소프트웨어 아키텍처 - 12(Layered Architecture Style)

> ## Layered Architecture Style

------

- 개요
  - 여러개의 상위 및 하위 레이어로 분해
  - 각 레이어는 패키지로 캡슐화된 관련 클래스 그룹으로 구성, 각 레이어는 시스템 내에서 고유한 역할을 수행
- 구조
  - 레이어 i+1로의 요청은 레이어 i의 인터페이스를 통해 레이어 i의 에서 제공하는 서비스를 호출
  - 각 레이어의 인터페이스는 현재 레이어의 서비스 구현과 아래 레이어의 인터페이스를 갭슐화
  - 상위 레이어에서 하위 레이어로의 요청은 메소드 호출을 통해 이루어지며 응답은 메소드 반환을 통해 이루어짐
  - ex)![img](https://velog.velcdn.com/images/3eung_h10n/post/15a886dc-095a-4287-a681-a8771824f834/image.png)
- Layered 아키텍처의 각 레이어는 프로그램 내에서 특정한 역할과 책임을 가짐
- 각 레이어는 추상화를 형성
  - 구성 요소간의 관심사 분리
  - 격리 레이어 개념
- 아키텍처의 한 레이어에서 수행된 변경은 일반적으로 다른 레이어의 구성 요소에 영향을 미치거나 주지 않는다
- ![img](https://velog.velcdn.com/images/3eung_h10n/post/1cbcf4cb-2873-474b-9c94-0688fa97d4bd/image.png)
- 한 고객의 정보를 요청할때의 과정
  - ![img](https://velog.velcdn.com/images/3eung_h10n/post/5306f268-603e-4020-8daf-ba826b2a54b1/image.png)

------

#### 구조 정리

- 각 레이어는 상위 레이어에만 서비스를 제공 바로 아래 레이어에서만 서비스를 요청
- 특별한 경우 상위 레이어가 더 멀리 아래에 있는 레이어에서 서비스를 받고, 하위 레이어가 상위 레이어에서 서비스를 받는 브리치 연결을 사용가능
- 높은 레이어는 더 일반적이거나 응용 서비스 중심, 더 추상적이고 낮은 레이어는 더 구체적인 유틸리티 유형의 서비스와 공통 서비스 제공

------

#### 사용자 상호작용이 포함된 Layered 아키텍처

- ![img](https://velog.velcdn.com/images/3eung_h10n/post/7426b028-3296-4b87-8fdd-0ee593ac3bf0/image.png)
- 실선은 서비스 요청, 점선은 응답
- 레이어가 높아질수록 서비스가 추상화되고 상위 레이어에서는 인터페이스만 볼수 있고 구체적인 구현 내용은 볼 수 없음

------

#### 구현

- 각 레이어를 jar파일과 같은 컴포넌트 형식으로 배포할 수 있음(패키지의 구성 요소로 배포되는 압축 파일)
- jar파일에는 하위 레벨에서 제공된 서비스 클래스와 동일한 레이어에서 제공된 다른 클래스가 포함될 수 있다
- jar파일 내의 모든 클래스에 엑세스 가능(클래스 경로 환경 변수에 있을 경우)

------

- ![img](https://velog.velcdn.com/images/3eung_h10n/post/ebb7440e-234c-4af1-8097-758542f0a94d/image.png)
- ![img](https://velog.velcdn.com/images/3eung_h10n/post/79bbd024-7bf3-4d3d-af11-94629fd4a203/image.png)

------

#### Two layers software system

- Interaction layer
  - 클라이언트에게 사용자 인터페이스 제공
  - 요청 수신
  - 요청의 유효성 검사, Processing레이어로 전달
  - 클라이언트에게 응답
- Processing layer
  - 전달된 요청 수신
  - 로직 처리
  - 데이터베이스 엑세스
  - 결과를 상위 레이어에 반환
  - 상위 레이어가 GUI인터페이스를 갖고 있기 떄문에 상위 레이어가 클라이언트에게 응답하도록 함

------

#### Class diagram for layered architecture

- ![img](https://velog.velcdn.com/images/3eung_h10n/post/a47d6e95-3ffb-49a5-b00e-81eee4d8ebd2/image.png)

------

#### 적용 사례

- 프로그램별 구성 요소와 프로그램의 일반 서비스를 제공하는 플랫폼별 구성요소로 나눌 수 있는 모든 시스템
- 핵심 서비스, 중요한 서비스, 사용자 인터페이스 서비스 등의 항목 사이에 명확한 구분이 있는 응용 프로그램.
- 서로 관련이 깊은 여러 클래스가 있어 다른 사람들에게 서비스를 제공하기 위해 패키지로 묶을 수 있는 응용 프로그램
- ![img](https://velog.velcdn.com/images/3eung_h10n/post/97fa5c0e-1630-4ee3-b847-e39e4a580151/image.png)

------

#### 장점과 단점

- 장점
  - 점차적으로 추상화 수준을 높일 수 있음
  - 상위 레이어에서 하위 레이어로의 독립성 향상. 하위 레이어 서비스의 변경이 인터페이스가 변경되지 않는 한 상위 레이어에 영향을 미치지 않음.
  - 향상된 유연성: 표준 인터페이스와 그 구현을 분리하기 때문에 교환 가능성과 재사용성이 향상됨.
  - 컴포넌트 기반 기술은 계층화된 아키텍처를 구현하기에 적합한 기술이며, 이로 인해 새로운 컴포넌트의 플러그 앤 플레이를 시스템에서 훨씬 쉽게 허용할 수 있음.
  - 이식성 촉진: 각 레이어는 독립적으로 배포될 수 있는 추상적인 기계가 될 수 있음.
- 단점
  - 클라이언트의 요청 및 응답이 여러 레이어를 통과해야 하기 때문에 런타임 성능이 낮을 수 있음
  - 레이어간의 통신의 위반이 데드락을 일으킬수 있고 브리지 연결은 높은 결합도를 초래할 수 있음
  - 한 레이어에서의 결함은 모든 호출 레이어로 전파되어야 함

# 소프트웨어 아키텍처 - 13(Virtual Machine Architecture Style)

> ## Virtual Machine Architecture Style

- 개요
  - 가상 머신은 기존 시스템 위에 구축되며 가상 추상화, 속성 집합 및 작업을 제공
  - 대부분의 경우 가상 머신은 프로그래밍 언어나 응용 프로그램 환경을 실행 플랫폼으로부터 분리 가능
  - 가상머신은 에뮬레이션과 유사하게 보일 수 있음

------

#### 예시

- unix운영 체제 -> unix커널 위에 C셸, Korn셸등 여러 쉘을 제공
  - ![img](https://velog.velcdn.com/images/3eung_h10n/post/b5a23343-db0e-41dc-a2a1-0ffd92bba306/image.png)
- Microsoft .NET 플랫폼의 공용 언어 런타임 (CLR) -> 단일 중간 언어를 사용하여 VB.NET, VC.NET 및 C#과 같은 여러 모듈을 통합하는 가상 머신의 역할을 수행
  - ![img](https://velog.velcdn.com/images/3eung_h10n/post/d9913e0e-5313-460b-b1e6-d9e0ef3aa15e/image.png)
- Java Virtual Machine (JVM) -> 컴파일 시스템 (javac)에서 생성된 Java 바이트코드와 기타 Java 내부 코드는 JVM을 지원하는 모든 운영 체제에서 실행할 수 있음
  - ![img](https://velog.velcdn.com/images/3eung_h10n/post/c9015a6a-ddd0-4a7f-968e-f6bcc87880b9/image.png)
  - ![img](https://velog.velcdn.com/images/3eung_h10n/post/81220701-2363-417c-bd92-febb975580fc/image.png)

------

#### 적용 사례

- 직접적인 해결책이 없을 경우 시뮬레이션이나 번역을 통해 문제를 해결하는데 적합
- ![img](https://velog.velcdn.com/images/3eung_h10n/post/35bf0255-2882-47f6-b34c-2ef158909dfb/image.png)
- ![img](https://velog.velcdn.com/images/3eung_h10n/post/35511860-9096-4610-8edb-f8b10199d996/image.png)

------

#### 장점, 단점

- 장점
  - 이식성 및 기계 플랫폼 독립성
  - 소프트웨어 개발의 간단함
  - 오류 작동 모델의 시뮬레이션
- 단점
  - 인터프리터의 느린 실행
  - 새로운 레이어로 인한 오버헤드



# 소프트웨어 아키텍처 - 14(Plug-In Architecture Style)

> ## Plug-In Architecture Style

- 개요
  - 변화하는 시스템 요구 사항에 적응
  - 확장기능을 연결하고 기능간의 협력을 조율하기 위한 소켓 역할을 수행
  - 핵심 응용 프로그램에 대한 플러그인으로 추가 응용 프로그램 기능을 제공하여 확장성과 기능 분리를 제공
- 구조
  - 응용 프로그램 구조는 독립적인 플러그인 모듈과 기본 핵심 시스템 사이에 나누어짐
  - 핵심 시스템
    - 시스템을 운영 가능하게 하는 데 필요한 최소한의 기능만 포함
  - 플러그인 모듈
    - 독립적인 구성 요소
    - 전문 처리, 추가 기능 및 사용자 정의 코드를 포함
    - 핵심 시스템을 향상하거나 확장하여 추가 비즈니스 기능을 생성

------

- 고려사항
  - 플러그인 간의 통신은 최소화하여 종속성 문제를 피함
  - 플러그인 레지스트리
    - 각 플러그인 모듈에 대한 정보
    - 이름, 데이터 계약 및 원격 엑세스 프로토콜 세부 정보와 같은 정보를 포함
  - ![img](https://velog.velcdn.com/images/3eung_h10n/post/de2e17c9-1dbf-4d3d-a51e-1a68d5f45c5e/image.png)

------

- 예시
  - Eclipse IDE
    - 기본 eclipse에 플러그인 추가
  - Internet browsers
    - 기본 브라우저
    - 뷰어 및 기타 플러그인
  - Claims processing
    - 청구 처리를 위한 핵심 시스템
    - 특정 주(지역)의 규칙을 포함하는 플러그인 모듈
    - ![img](https://velog.velcdn.com/images/3eung_h10n/post/d038e057-f0d6-4cfa-bb84-34241e165ed0/image.png)
  - ![img](https://velog.velcdn.com/images/3eung_h10n/post/879419ec-1d6e-4334-803a-a1372eac46b2/image.png)

------

- Eclipse 아키텍처
  - ![img](https://velog.velcdn.com/images/3eung_h10n/post/460ebdf6-a7d9-42c3-a5fc-eb72b197a371/image.png)
  - 플러그인은 java로 작성
  - 플러그인은 jar라이브러리에 있는 java코드, 읽기정용 파일, 이미지등의 다른 리소스로 구성
  - 각 플러그인에는 다른 플러그인과 상호 연결을 선언하는 메니페스트 파일이 있음
  - ![img](https://velog.velcdn.com/images/3eung_h10n/post/93427844-39ca-452e-a95c-a927f17db37e/image.png)
  - ![img](https://velog.velcdn.com/images/3eung_h10n/post/0b4d355d-005e-43e4-9d0c-ec0c98a8b061/image.png)

------

- 예시 너무 많아서 ppt로 보기
  - web browser, chromium, firefox, chrome등이 있음

------

#### Plug in 아키텍처 특징

- 이식성 : 플러그인은 핵심 시스템과 독립적으로 개발되어 특정 플랫폼에 종속되지 않고 여러 환경에서 사용 가능
- 유연성 : 핵심시스템에 기능을 추가하거나 변경하면서 변화하는 요구사항에 쉽게 대응할 수 있음
- 정책과 메커니즘의 분리 : 핵심 로직(정책)과 확장 기능(메커니즘)을 분리할 수 있고 이는 유지 관리 및 설계를 단순화하고 정책과 메커니즘의 변경을 독립적으로 다룰 수 있도록 함



# 소프트웨어 아키텍처 - 15(Microkernel Architecture Style)

> ## Microkernel Architecture Style

- 관련 하드웨어 플랫폼으로 쉽게 이식 가능
- 미래의 발전을 쉽게 수용
- 다른 인기 있는 운영 체제로 작성된 응용 프로그램 실행 가능

------

- 맥락
  - 동일한 핵심 기능을 기반으로 하는 유사한 프로그래밍 인터페이스를 사용하는 여러 프로그램의 개발
- 문제
  - 응용 플랫폼과 그래픽 GUI는 긴 수명 주기를 가지고 있음
    - 응용 플랫폼이 지속적인 하드웨어 및 소프트웨어 발전에 대응해야함
    - 응용 플랫폼이 새로운 기술을 쉽게 통합할 수 있도록 이식 가능하고 확장 가능하며 적응 가능해야 함

------

- 마이크로 커널 구조
  - ![img](https://velog.velcdn.com/images/3eung_h10n/post/272c65e2-f92c-4006-b027-8554029cf9ed/image.png)
  - 애플리케이션 플랫폼의 기본 서비스를 마이크로 커널 컴포넌트에 캡슐화
  - 마이크로커널 내에서 크기나 복잡성을 불필요하게 증가시키지 않고 구현할 수 없는 핵심 기능은 내부 서버로 분리
  - 외부 서버는 내부 마이크로커널의 기본 모습을 구현
  - 클라이언트는 마이크로 커널이 제공하는 통신 시설을 사용하여 외부 서버와 통신

------

- 각 구성 요소 해석
  - 마이크로 커널
    - ![img](https://velog.velcdn.com/images/3eung_h10n/post/f146072e-c6b0-4212-96a3-771f5a650561/image.png)
    - 중앙 서비스를 구현
    - 시스템 특정 종속성은 마이크로 커널 내에 캡슐화
    - 마이크로커널은 시스템 리소스를 유지하는 역할도 함
    - 원자적 서비스 구현
  - 내부 서버
    - ![img](https://velog.velcdn.com/images/3eung_h10n/post/0598b97c-9e7e-4d51-8b26-04e34a6676f9/image.png)
    - 마이크로커널이 제공하는 기능을 확장
    - 기존 하드웨어나 소프트웨어 시스템에 대한 일부 의존성을 캡슐화
    - 마이크로커널은 내부 서버의 기능을 서비스 요청을 통해 호출
  - 외부 서버
    - ![img](https://velog.velcdn.com/images/3eung_h10n/post/02ddf7d3-1c73-4a5b-b914-3abeef7dcf8e/image.png)
    - 응용 프로그램 도메인에 대한 자체적인 시각을 구현하기 위해 마이크로커널을 사용하는 구성 요소
  - 클라리언트 & 어댑터
    - ![img](https://velog.velcdn.com/images/3eung_h10n/post/5b97ba74-37a7-4878-8e9e-f0759eee8162/image.png)
    - 어댑터는 클라이언트와 외부 서버 간의 인터페이스를 대표
    - 클라이언트가 외부 서버의 서비스를 휴대 가능한 방식으로(설치 없이) 액세스할 수 있게 함

------

- ![img](https://velog.velcdn.com/images/3eung_h10n/post/85401e5f-b9a2-4c35-9b80-4f669f326a74/image.png)
- ![img](https://velog.velcdn.com/images/3eung_h10n/post/f0afed45-c2d9-4473-8ce2-d6fba48581b9/image.png)

------

- 장점
  - 휴대성
  - 유엿너
  - 정책과 메커니즘의 분리
- 분산 마이크로커널의 이점
  - 확장성
  - 신뢰성
  - 투명성
  - 성능
  - 설계 및 구현 복잡성

------

#### 아키텍처 계층 구조 요약

- 여기까지가 계층 구조 스타일

------

- 응용 프로그램, 시스템 소프트웨어 설계, 네트워킹 프로토콜 설계 등 다른 비즈니스 데이터 처리와 같은 시스템 소프트웨어 설계에 매우 인기가 있으며 응용 프로그램 소프트웨어 설계에도 사용
- 구현
  - 구조 기술뿐만 아니라 현대적인 객체 지향 및 컴포넌트 지향 접근법을 사용하여 구현 가능
- 설계 지침
  - 분해 기준을 정의
    - 각 레이어는 하위 레이어에만 의존 각 레이어는 명확하고 구체적인 작업이 있다
  - 분할 기준을 기반으로 경계를 결정
  - 분해된 하위 시스템의 인터페이스를 정의
  - 분해된 하위 시스템의 각 서비스를 정의
  - 하위 시스템 간의 연결을 정의

# 소프트웨어 아키텍처 - 16(Distributed Architecture)

> ## Distributed Architecture

#### 분산 아키텍처

- 개요
  - 분산 시스템은 통신 네트워크를 통해 연결된 계산 및 저장 장치의 모음
  - 분산 시스템 내의 하위 시스템 또는 구성 요소는 메시지 전달, 원격 프로시저 호출 및 원격 메서드 호출을 포함한 여러 방법을 사용하여 서로 통신

------

- 구조(분산 시스템 설계의 중요한 2가지 요소)
  - 네트워크 통신망
    - 엔터티가 연결된 네트워크를 형성하는 방법
  - 통신 모드
    - 구성 요소가 서로 통신하는 방법
  - 분산 시스템은 클라이언트-서버 아키텍처를 기반으로 모델링할 수 있으며, 이는 멀티티어 아키텍처의 기초
  - CORBA와 같은 브로커 아키텍처, 웹 서비스 및 그리드 서비스와 같은 서비스 지향 아키텍처(SOA)도 있음
  - 분산 아키텍처의 주요 특징
    - 서비스 위치 투명성
      - 서비스 호출자가 서비스가 실행되는 실제 물리적 위치 또는 서버에 대한 지식 없이 서비스를 요청하고 사용할 수 있는 능력
      - 여러 서버 간 로드 밸런싱이 이루어질 때 클라이언트 코드 변경없이 서비스를 사용 가능 유연성 향상 및 가용성과 확장성을 향상
    - 서비스 신뢰성과 가용성
  - 분산 아키텍처를 지원하는 프레임워크
    - .NET, J2EE, CORBA, .NET 웹 서비스, AXIS Java 웹 서비스 및 GloBus 그리드 서비스.

------

- 분산 아키텍처 스타일
  - Client-server
  - Multitier
  - Proxy
  - Dispatcher (Load Balancer)
  - P2P
  - Broker
  - Service-oriented architecture
  - MicroService architecture

# 소프트웨어 아키텍처 - 17(Client-Server Architecture Style)

> ## Client-Server Architecture Style

- 개요
  - 가장 일반적인 분산 아키텍처
  - 일반적으로 다른 프로세서에서 실행되는 두 개의 통신 프로세스
- 구조
  - 시스템을 두 가지 주요 하위 시스템으로 분해
    - 클라이언트 및 서버
    - 클라이언트
      - 서버에 요청을 보냄
    - 서버
      - 요청을 수신하고(데이터베이스에서 데이터 제공, 문서 출력 등), 해당 작업을 수행한 후 클라이언트에 응답을 보냄
- 서버와 클라이언트
  - 서버
    - 특정 서비스를 구현하는 프로세스
  - 클라이언트
    - 서버에 요청을 보내고 응답을 대기하는 프로세스
  - 통신 과정
    - ![img](https://velog.velcdn.com/images/3eung_h10n/post/97c769ad-2128-41ec-a744-8b0a332969ae/image.png)
- 두 개의 컴퓨터 간의 관계를 하나는 클라이언트, 다른 하나를 서버라부름 클라이언트의 요청과 서버의 응답이 분산 시스템에서 서비스 요청과 제공의 기본적인 관계를 설명하는 방식 중 하나, 클라이언트와 서버는 네트워크를 통해 통신하고 클라이언트가 원격 서버에서 제공하는 서비스를 요청하고 응답을 받음
- ![img](https://velog.velcdn.com/images/3eung_h10n/post/a71315fe-f006-47ca-955c-8a9ba4e9465a/image.png)
- Two-tier client-server architecture
  - ![img](https://velog.velcdn.com/images/3eung_h10n/post/8cffca22-a06e-4bc3-91f0-46438c9b7fca/image.png)
  - 티어 : 분류의 횟수

------

- 장점
  - 사용자 인터페이스 표현과 비즈니스 로직 처리와 같은 책임의 분리
  - 서버 컴포넌트의 재사용
- 단점
  - 요구 사항 변경 처리를 위한 인프라 부재
  - 보안의 복잡성
  - 서버 가용성과 신뢰성
  - 테스트 용이성과 확장성
  - 프레젠테이션 및 비즈니스 로직이 함께 있는 두꺼운 클라이언트

# 소프트웨어 아키텍처 - 18(Multi-tiers Architecture Style)



> ## Multi-tiers Architecture Style

#### One-tire 아키텍처

- 메인프레임 기반 및 덤(dumb) 터미널 상호 작용을 나타냄
  - 메인프레임 기반 및 덤 터미널 상호 작용
    - 메인프레임 컴퓨터와 간단한 터미널 간의 상호작용을 나타냄, 클라이언트 역할을 하는 덤 터미널이 주로 키보드와 화면만을 가짐
  - 주요 관심사
    - CPU및 시스템의 효율적인 사용
    - 메인프레임 시스템의 리소스를 효율적으로 사용 하는 것
  - 단일 티어로 통합된 정보 시스템
    - 응용 프로그램 로직 및 리소스 관리 계층을 단일 티어로 통합, 이는 시스템의 모든 구성 요소가 메인프레임 내에 위치하고 모든 처리가 해당 메인프레임에서 이루어지는 방식을 의미
  - 덤 터미널(덤 클라이언트)
    - 클라이언트 역할을 하는 덤 터미널은 주로 입력을 받고 메인프레임에서 처리된 결과를 화면에 표시하는 단순한 장치
  - 프레젠테이션 계층의 전체가 메인프레임에 위치: 이 아키텍처에서는 프레젠테이션 계층의 전체가 메인프레임에 위치하며, 클라이언트에서는 주로 사용자 입력과 출력 표시만 담당
  - ![img](https://velog.velcdn.com/images/3eung_h10n/post/89c1b92c-94bc-4380-ab04-43b47cb534e0/image.png)

------

#### Two-tier 아키텍처

- 대형 컴퓨터(메인프레임 및 서버) 그룹과 소형 컴퓨터(PC 및 워크 스테이션) 그룹으로 구분
- 프레젠테이션 계층의 클라이언트와 PC
  - 프레젠테이션 계층은 클라이언트와 PC에서 수행
  - 프레젠테이션 계층은 PC에서 사용 가능한 계산 능력정도를 활용
  - 시스템의 복잡성을 증가 시키지 않고 다양한 목적에 맞게 프레젠테이션 계층을 맞춤화
  - 관리 목적 및 일반 사용자들을 위한 목적으로 사용
- 응용 프로그램 로직 계층 및 리소스 관리 계층
  - 응용 프로그램 로직 실행 및 리소스 관리
- ![img](https://velog.velcdn.com/images/3eung_h10n/post/b0413c1f-37d3-4691-9fc3-fe3891864bac/image.png)
- ![img](https://velog.velcdn.com/images/3eung_h10n/post/de78c526-5479-49fa-a993-66649965fb0a/image.png)
- Two-tier 정리
- 클라이언트/서버
  - 클라이언트 : 주로 시각적으로 표현되는 부분과 실제 클라이언트 소프트웨어를 의미, 사용자 인터페이스 담당, 사용자와 상호작용
  - 서버 : 서버는 애플리케이션의 논리적인 부분과 리소스 관리 계층, 클라이언트의 요청을 처리 데이터베이스와 같은 백엔드 시스템과 상호작용
- 클라이언트의 복잡성에 따라 2가지 유형의 클라이언트로 구분
  - Thin 클라이언트
    - 기능이 제한적인 클라이언트 기능이 적고 가벼움, 이식성이 높고 설치 및 유지 관리가 쉬움 서버에서 주로 데이터 및 작업을 관리 클라이언트는 화면 표시와 입력 처리에 관여
  - fat 클라이언트
    - 다양한 기능을 제공, 클라이언트 디바이스에서 실행되는 코드가 많이 포함되어 있으며 클라이언트 디바이스의 자원을 많이 사용 더 복잡한 작업을 수행 가능하지만 설치와 유지 관리가 복잡

#### Three-tier 아키텍처

- 추상 레벨 : 삼계층 아키텍처는 명확한 분리를 기반
  - 프레젠테이션 계층
    - 클라이언트에 위치 사용자 인터페이스와 관련된 역할, 사용자와 상호작용 정보를 시각화
  - 애플리케이션 로직 계층
    - 중간 계층에 위치, 애플리케이션 로직이 실행, 미드루에어를 포함한 추상화와 인프라를 제공, 에플리케이션의 핵심 비즈니스 로직이 이곳에 구현
  - 리소스 관리 계층
    - 서버 리소스 및 데이터베이스와 같은 벡엔드 시스템을 관리, 클라이언트 및 애플리케이션 로직 계층과 상호작용하여 데이터 처리
- ![img](https://velog.velcdn.com/images/3eung_h10n/post/23f06820-838c-4083-a095-6a97175666f7/image.png)

------

#### Application Layering

- ![img](https://velog.velcdn.com/images/3eung_h10n/post/0b4a4b53-5953-499b-933a-6c37db614447/image.png)

------

#### 2-tier vs 3-tier

- 2-tier
  - app로직이 주로 클라이언트의 사용자 인터페이스 내에 있거나 서버의 데이터베이스 내에 있거나 둘다에 위치할 수 있음
- 3-tier
  - app로직이 중간계층에 위치
  - 확장가능, 견고하고 유연
- ![img](https://velog.velcdn.com/images/3eung_h10n/post/6ddda7d9-ff03-40d0-9a87-a5a59ca49e14/image.png)

------

#### 3-tier Vertical Distribution

- ![img](https://velog.velcdn.com/images/3eung_h10n/post/a0f96cba-5177-4fb6-842c-9c470fef92d9/image.png)

------

#### Multi-tiers Architecture Style

- 개요
  - 프론트엔트 계층
    - 주로 사용자 인터페이스 표현 계층을 의미
    - 사용자와 상호작용, 사용자 인터페이스 담당
  - 중간 계층
    - 비즈니스 로직과 실행을 관리
    - 클라이언트와 백엔드 데이터베이스간의 중개 역할
  - 백엔드 계층
    - 주로 데이터베이스 관리를 처리
    - 데이터의 저장 및 관리를 담당 데이터베이스와 상호작용하여 필요한 데이터 반환
  - 다층 아키텍처는 시스템을 여러 계층으로 분할하여 확장성 유연성 및 유지 보수성을 향상

------

- 3-tier
  - ![img](https://velog.velcdn.com/images/3eung_h10n/post/ef2d3e28-179f-4e57-a4f9-7985e71d87bb/image.png)
- 4-tier
  - ![img](https://velog.velcdn.com/images/3eung_h10n/post/6b510253-7221-4974-80bb-f4fd2cce67b0/image.png)

------

#### 멀티 티어 아키텍처 장,단점

- 장점
  - 중간 계층 추가로 재사용성 및 확장성 향상
  - 비즈니스 변경사항은 중간계층에만 적용
  - 플랫폼 독립적으로 개발가능 특정 공급업체에 의존하지 않음
  - 확장성을 위한 멀티스레딩 지원(병렬처리)
  - 중간 계층이 비즈니스 로직을 처리하므로 클라이언트, 서버간의 트래픽이 줄어 네트워크 효율 향상
  - 서버 신뢰성 및 가용성 향상 : 중간계층이 장애 발생 시 서버를 통해 계속 작동할 수 있음
- 단점
  - 테스트의 어려움 : 테스트 도구의 부족
  - 시스템에 여러 서버를 추가하는 경우 유지보수가 어려움 : 서버 수의 증가는 시스템이 복잡해지고 유지보수가 어려워짐

# 소프트웨어 아키텍처 - 19(Proxy Architecture Style)

> ## Proxy Architecture Style

- 개요
  - 프록시는 메서드 호출을 객체에 직접적으로 일어나게 하는 대신 프록시 객체를 통해 간접적으로 발생시키는 역할을 함
  - 프록시 객체들은 일반적으로 서비스를 제공하는 객체와 공통 인터페이스나 슈퍼클래스를 공유

------

- 프록시의 패턴(다른 객체의 서비스를 투명하게 관리하기 위해 프록시를 사용)
  - 메서드 실행 시간이 오래 걸리는 경우에도 즉시 반환하는 효과를 주는 프록시
    - 프록시가 메서드가 오래 걸리는 작업을 수행해도 클라이언트는 즉시 반환되는 것처럼 보이도록 만들 수 있음
    - 작업의 완료를 대기하지 않고 다른 작업을 수행할떄 유용
  - 다른 기계에 있는 객체가 로컬 객체처럼 보이게 하는 프록시(원격 프록시)
    - 원격 서버에 있는 객체가 로컬에서 있는 것처럼 사용될 수 있게 해줌
    - 원격 서비스 호출 및 분산 시스템에서 객체 통신을 관리할때 유용
  - 서비스 제공 객체에 대한 접근을 제어하는 프록시(액세스 프록시)
    - 클라이언트가 서비스 제공 객체에 직접 접근하는 것을 통제하며 보안 및 권한 관리를 제어
  - 서비스 객체가 실제로 생성되기 전에 그 객체가 존재하는 것처럼 보이게 하는 프록시(가상 프록시)
    - 실제 서비스 객체가 생성되기 전에 클라이언트에게 이미 존재하는 것처럼 보이게 하여 리소스를 효과적으로 관리하고 지연 초기화를 수행
- 프록시 패턴의 다양한 사용 사례를 통해 서비스 관리와 클라이언트-서버 상호작용을 개선하고 복잡한 시스템에서 투명한 서비스 제공을 지원
- 투명한 서비스란 클라이언트에게 서비스가 제공되는 것처럼 보이면서 클라이언트에게 실제로 서비스가 어떻게 제공되는지에 대한 세부 정보를 숨기는 것을 의미
  - 서비스가 어디에서 실행되고 어떻게 제공되는지에 대해 사용자가 인식하지 않을 수 있음

------

#### 프록시 구조

- ![img](https://velog.velcdn.com/images/3eung_h10n/post/543cb157-7e34-4459-86ec-7e32ad47bd78/image.png)
- 프록시 클래스 다이어그램
- ![img](https://velog.velcdn.com/images/3eung_h10n/post/333a8a02-d86c-4958-bcfe-c175f6eff364/image.png)
- Solution
  - 서비스는 직접적으로 접근할 수 없는 객체를 구현
  - 객체에 대한 직접적 접근 대신 접근을 위한 플레이스홀더를 제공
  - 프록시는 서비스를 대표하며 올바른 접근을 보장(프록시는 서비스와 동일한 인터페이스)
  - 클라이언트는 서비스에 접근하기 위해 프록시 사용
  - ![img](https://velog.velcdn.com/images/3eung_h10n/post/e79c4c6b-81d4-4113-968b-e2c6c8a4790e/image.png)
- ![img](https://velog.velcdn.com/images/3eung_h10n/post/e97a8c42-681d-40a6-949c-b96a649b977f/image.png)

------

#### 프록시의 장,단점

- 장점
  - 원본 객체에 대한 엑세스 제어
    - 클라이언트가 원본 객체에 직접 접근하는 것을 제어(보안 및 권한 제어 수행)
  - 메모리 절약
    - 원본 객체가 필요할 떄만 생성되거나 초기화
  - 성능 향상
    - 캐시 프록시와 같은 특정 유형의 프록시를 사용하면 결과를 캐시하고 중복된 계산을 피함
  - 기능과 관리의 분리
    - 프록시를 사용하면 핵심 비즈니스 로직과 기능과 같은 핵심 작업을 분리, 코드 유지보수와 확장이 쉬워짐
- 단점
  - 과도한 복잡성의 위험
    - 프록시가 너무 복잡한 기능을 갖고 있는 경우
  - 간접성 수준
    - 프록시를 사용하면 메서드 호출이 한 단계 추가로 간접적으로 이루어지므로 간접성이 발생

# 소프트웨어 아키텍처 - 20(Dispatcher(Load Balancer) Architecture Style

> ## Dispatcher(Load Balancer) Architecture Style

- 개요
  - 분산 컴퓨팅에서 사용되는 미들웨어 아키텍처
    - 분산 컴퓨팅 환경에서 사용되는 아키텍처이고 서버 팜(farm)을 클라이언트에게 단일 서버처럼 보이도록 만듬
  - 서버 팜이 고도로 확장 가능성과 고가용성을 달성
    - 이 아키텍처를 통해 서버 팜은 클라이언트에게 하나의 단일 서버처럼 보이며, 이를 통해 높은 확장 가능성과 고가용성 달성
  - 서버 부하 분산을 통한 높은 확장성과 가용성
- 이러한 미들웨어 아키텍처는 대규모 분산 시스템에서 서버 팜의 관리, 부하 분산, 확장성등을 개선하고 클라이언트와 서버 간의 투명한 상호작용을 지원
- ![img](https://velog.velcdn.com/images/3eung_h10n/post/0f411630-ab67-4a6c-b07c-28a1145c9045/image.png)

------

#### 로드 밸런서 아키텍처 맥락

- 모든 요청을 처리하는 단일 서버는 높은 트래픽 양을 처리하기에 용량이 부족할 수 있음
- 하지만 스케일업(용량의 증가등)은 단기적인 해결책에 불과 서버 성능 향상에 비해 비용이 불균형적으로 높다
- 응용 프로그램 구성 요소는 저렴한 하드웨어와 운영체제를 기반으로 한 서버 팜의 여러 인스턴스로 처리

------

#### 디스패처 아키텍처 스타일의 강제 사항

- 소프트웨어 측면에서 응용 프로그램은 다양한 서버에서 여러 인스턴스로 실행될 수 있도록 설계해야 함
- 응용 프로그램의 상태를 관리해야 하는 경우 분산 환경에서 관리가 어려울 수 있음
- 인프라 측면에서 처리 부하는 서버 그룹 간에 분산되어야 함(서버 로드 밸런싱)

------

#### 디스패처 아키텍처 스타일 - Solition

- 구조
  - 들어오는 요청은 클라이언트에게 투명한 전용 서버 로드 밸런서로 전달됨
  - 가용성 또는 현재 서버 부하와 같은 매개변수를 기반으로 로드 밸런서는 어떤 서버가 해당 요청을 처리해야 하는지를 결정하고 선택된 서버로 요청을 전달
  - 로드 밸런싱 알고리즘이 필요한 입력 데이터를 제공하기 위해 로드 밸런서는 서버의 상태 및 부하 정보를 검색하여 트래픽에 응답할 수 있는지 확인
  - ![img](https://velog.velcdn.com/images/3eung_h10n/post/c032324a-4704-4e1b-9679-53e81233e6af/image.png)

------

#### Availability vs. Scalability(가용성과 확장성)

- 가용성(Availability)
  - 가용성은 장애간 시간에 의해 정의
    - 장애가 발생한 시간부터 다시 정상적으로 작동하기까지 걸리는 시간으로 판단(업타임_
    - 업타임 기간 동안 시스템은 미리 정의된 명확한 시간 내에 각 요청에 응답해야함
    - 고가용성은 기본적으로 시스템 내에서의 중복성이다 : 하나의 서버가 실패하는 경우 다른 서버가 해당 서버의 작업 부하를 투명하게 이어받음 이는 클라이언트에게 보이지 않는다
    - 높은 가용성을 달성하기 위해서는 로드 밸런서가 서버를 모니터링하여 과부하나 다운된 서버로 요청을 보내지 않아야 함 추가로 로드 밸런서 자체도 중복이 되어야 함
- 확장성(Scalability)
  - 확장성은 시스템이 단일 클라이언트 뿐만 아니라 수천개의 동시 클라이언트를 서비스할 수 있는 능력을 의미
    - 고 학장성은 서버로 들어오는 요청을 서버들 사이에 분산함으로써 달성
    - 높은 가용성을 달성하기

------

#### 로드 밸런서 아키텍처 - Solution

- 구현
  - 서버 로드 밸런싱 솔루션은 두 가지 유형으로 나눌 수 있음
    - 전송 로드 밸런싱(Transport-level)
      - DNS 기반 접근 방식 또는 TCP/IP 수준 로드 밸런싱과 같이 응용 프로그램과 독립적으로 동작
    - 응용프로그램 로드 밸런싱(Application-level)
      - 응용 프로그램 페이로드를 사용하여 로드 밸런싱 결정
  - 로드 밸런싱 솔루션은 소프트웨어 기반 로드 밸런서와 하드웨어 기반 로드 밸런서로 더 구체적으로 분류 가능
    - 하드웨어 기반 로드 밸런서
      - 특정 용도로 사용하기 위해 커스터마이즈된 응용 프로그램 특화 통합 회로(ASICs)를 포함한 전문 하드웨어 상자
      - 주로 transport레벨의 로드 벨런싱을 위해 사용
      - 일발적으로 소프트웨어 기반 로드 밸런서보다 빠르지만 비용이 높음
    - 소프트웨어 기반 로드 밸런서
      - 표준 운영 체제 및 개인용 컴퓨터에서 실행
      - 주로 전용 로드 밸런서 하드웨어 노드 내에서 실행하거나 응용 프로그램 내에서 직접 실행

------

#### 디스패처(로드 밸런서) 아키텍처 예시

- DNS 기반 로드 밸런싱
  - 하나의 호스트 이름에 여러개의 IP주소를 할당할 수 있는 DNS의 특성을 기반
  - DNS는 각기 다른 위치에 있는 여러 데이터 센터 간에 로드를 분산해야 하는 전역 서버 로드 밸런싱에 효율적
  - 전용 데이터 센터 내에서 로드를 분산하기 위한 다른 서버 로드 밸런싱 솔루션과 결합
- TCP/IP 서버 로드 밸런싱
  - 낮은 수준의 레이어 스위칭에서 작동
  - Linux Virtual Server(LVS)가 있음
- ![img](https://velog.velcdn.com/images/3eung_h10n/post/d1f1aa1d-cf1c-49e3-a162-1c7122268e61/image.png)

------

#### 구현

- 캐싱
  - 낮은 수준의 서버 로드 밸런서 솔루션인 LVS와 같은 솔루션은 응용 프로그램의 상황에 따라 한계에 도달할 수 있음
  - 캐싱은 동일한 데이터를 반복적으로 가져오는 비용을 피하기위해 중요한 확장성 원칙
  - 캐시는 이전 데이터 검색 작업에서 발생한 중복 데이터를 일시적으로 보유하는 저장소
  - 서버 측에서 캐시를 사용하는 경우 캐시로 인한 잘못된 요청 문제가 발생할 수 있음
    - 캐시를 전역 공간에 배치하여 해결
  - memcached는 여러 대의 컴퓨터에 걸쳐 큰 캐시를 제공하는 분산 캐시 솔루션
- ![img](https://velog.velcdn.com/images/3eung_h10n/post/79b42155-cdd1-4560-9019-0270d37b199b/image.png)

