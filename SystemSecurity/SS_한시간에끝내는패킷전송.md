# SS_한시간에끝내는패킷전송

## LAN1강

LAN : Local Area Network, 특정 지리적 위치의 네트워크 장치들이 서로 통신하도록 연결된 네트워크

![image](https://github.com/hhzzzk/studyLog/assets/67236054/619f3f8d-8d72-4972-8750-8fd5e5d02d5f)

- 3개의 LAN이 연결, 123이라 하자
- 1LAN은 192.168.161의 24비트가 같다. 이는 IP주소의 서브넷 마스크이다.
  - IP 주소는 32비트로 구성, 24비트의 서브넷 마스크는 보통 클래스 C네트워크를 나타내면 주소의 처음 3바이트가 네트워크 주소를 나타내고 나머지 1바이트가 호스트의 주소이다.
  - 클래스 C 네트워크는 IPv4 주소 공간에서 특정한 주소 범위를 나타내며, 일반적으로 24비트로 구성된 서브넷 마스크를 가진다.

![image](https://github.com/hhzzzk/studyLog/assets/67236054/4fb02703-8854-4c43-b296-747e8ed8a5f6)

1LAN에서 클라이언트가 서버에게 메세지를 보내면 서버가 메세지를 다시 반환하는 과정이 어떻게 이루어지는지 살펴보자.

- 같은 LAN 내의 장치기리 데이터 패킷 전달 방법

## 라우팅 테이블 Routing table

라우터나 다른 네트워크 장비가 패킷을 보낼 때 어느 방향으로 보내야 하는지 결정하는데 사용된다.

윈도우 파워쉘에서 "netstat -rn" 명령어 입력

![image](https://github.com/hhzzzk/studyLog/assets/67236054/2ec44d68-b4ec-4ee1-84c9-06a945ca59fd)

네트워크 목적지, 넷마스크, 게이트웨이 등이 있다.

## IP Routing

IP라우팅은 데이터 패킷이 출발지에서 목적지로 이동할 때 경로를 결정하는 프로세스이다.

라우터가 패킷의 최적 경로를 결정한다. 

## 라우팅 테이블의 정렬

longest prefix matching 알고리즘은 주어진 IP 주소에 대해 라우팅 테이블의 항목을 검색할 때 사용된다. 

- 가장 구체적인 매칭을 찾기 위해 라우팅 테이블 항목을 연속된 1의 개수에 따라 정렬한다.
- 즉 서브넷 마스크가 더 많은 1을 포함하는 경우에 우선순위가 높아진다.

![image](https://github.com/hhzzzk/studyLog/assets/67236054/0314ad20-f33d-40d6-9f92-408f300a25b2)

- 넷마스크가 전부 1인 경우가 255.255.255.255이다. 



## Lognest prefix matching 알고리즘



알고리즘이 동작하는 방식은 이 목적지 ip 주소와 (서브)넷마스크를 bitwise and 연산을 한다.

1과 비트와이즈하면 자기자신이 나올 것이고 4번의 경우 연산을 하면 목적지 주소와 같다. 4번 당첨

`게이트웨이는 다음으로 패킷을 보낼 주소다.`

해당 게이트웨이는 161.230 즉 자기 자신이다. 결국 자기자신에게 던지라는 이야기다.



## 이더넷

지금 해당 LAN은 이더넷 방식 쓰고 있다. 

자기 자신에게 패킷을 전달하는 것은 해당 PC가 속한 LAN에 패킷을 무작위로 다 던져라

그럼 받는 사람이 알아서 해결한다.

받아서 받은 사람이 목적지 IP 주소를 보고 그게 내 IP면 패킷을 accept한다.

- 이렇게 패킷을 브로드캐스트 방식으로 내가 속한 LAN의 모든 장비에 전달하는 방식으로 패킷을 뿌리는게 이더넷 방식이다. 4번 규칙이 당점돼기 때문에 이런 방식을 한다.
- 만약 7번 규칙이었다면 해당 게이트웨이 161.1에게만 패킷을 하나 전달한다.

> 게이트웨이가 자기 자신의 IP 주소일 경우 이더넷 방식으로 패킷을 브로드캐스트한다.



## LAN2강

클라이언트가 패킷을 생성하는데 해당 패킷에는

SMAC | dMAC | SIP | dIP |...

앞의 4개의 정보가 필요하다. S는 출발지 source고 d는 목적지다.

그런데 목적지의 MAC 주소를 알아내기 위한 방법이 필요하다.

이 때 사용하는 것이 ARP 프로토콜이다.



## ARP 프로토콜

Address Resolution Protocol

이더넷이나 TCPIP 네트워크에서 IP 주소를 물리적인 MAC 주소로 매핑하는 프로토콜이다.

ARP 프로토콜은 호스트가 목적지의 MAC 주소를 모를 때 사용된다. 

호스트는 ARP Request 패킷을 브로드캐스트해 LAN 상의 모든 장치에게 물어본다.

## 이더넷 + ARP

이더넷 통신에서 패킷을 보낼 때 일단 dMAC를 1로 채워서 48비트를 보낸다. 

즉 48비트가 전부 1이면 ARP Request 패킷이다.

해당 패킷을 받은 장비는 누가 이더뎃 프로토콜 규약에 의해, ARP 프로토콜로 MAC 주소를 찾는 ARP Request 패킷을 보냈구나.

목적지 IP 주소가 자기가 맞는 장비만이 ARP Request에 대답하는 ARP Reply 패킷을 보낸다.

ARP Reply 패킷에는 dMAC값을 채워서 보낸다. 이제 클라이언트는 이터넷 패킷을 완성할 수 있다.



## LAN3강

클라이언트와 서버가 다른 LAN 소속인 경우에 대해 알아보자

![](https://velog.velcdn.com/images/vpdrnls/post/a1b73afd-641f-4857-a250-731b20bc6b54/image.png)

목적지 ip인 dIP는 192.169.162.230이다

![image](https://github.com/hhzzzk/studyLog/assets/67236054/0314ad20-f33d-40d6-9f92-408f300a25b2)

다시 라우팅 테이블을 통해 넷마스크와 목적지 IP를 연산한 결과와 게이트웨이와 같은 규칙을 찾는다.

없으므로 디폴트값이 7번을 선택한다. 7번 규칙은 항상 성립한다.

7번 규칙은 게이트웨이가 192.168.161.1이다. 즉 클라이언트와 동일한 LAN의 게이트웨이다.

클라이언트는 이더넷 프레임에서 SMAC | dMAC | Sip | dip 를 채워야 하는데

dMAC를 누구로 해야 하는가. 바로 위에서 찾는 7번 규칙의 게이트웨이의 MAC를 찾아야 한다.

그건 그림상 LAN의 라우터의 것이다. 



그럼 ARP 리퀘스트 패킷을 뿌리는데 목적지 맥 주소 dMAC를 1로 채워서 브로드캐스트로 뿌린다.

이를 통해 LAN 라우터의 맥 주소를 알게 된다. 

클라이언트는 이더넷 패킷을 잘 채워서 브로드캐스트 한다.



## 라우터까지 왔다

![](https://velog.velcdn.com/images/vpdrnls/post/a1b73afd-641f-4857-a250-731b20bc6b54/image.png)



161.1 라우터는 패킷을 받았다. 라우터는 자신의 라우팅 테이블을 뒤져서 다시 또 넷마스크와 목적지와 longest prefix matching해서 규칙을 찾는다. 그렇게 오른쪽의 라우터에게 전달하도록 될 것이고 또 arp 하고 반복하는 것이다.

결국 절차가

1. 라우팅 테이블에서 롱기스트 프리픽스 매칭하고
2. 다음 MAC 주소를 찾는다. 모르면 ARP 리퀘스트 뿌리고 리플라이 받고 한다.
3. 반복한다.

패킷, 이더넷 프레임에서 SMAC | dMAC | Sip | dip

**출발 IP 주소와 목적지 IP 주소는 변하지 않고 MAC 주소는 계속 바뀐다.**

---

---

---

① PC0은 자신의 라우팅 테이블([그림19] 참조)을 확인하고 7번 라우팅 규칙을 사용한다. 

즉, PC0는 패킷을 7번 규칙의 gateway(IP주소 192.168.161.1)인 Router0로 전송해야 한다는 것을 알았다. 

그 다음 패킷 전달의 책임은 전적으로 Router0에 귀속된다.



② PC0의 ARP Table에 192.168.161.1에 해당하는 MAC 주소가 없다고 가정하자. 

PC0는 192.168.161.1을 목적지 IP주소로 사용하여 ARP Request 패킷을 생성하여 브로드캐스트(Broadcast) 한다. 즉, 패킷내 목적지 MAC 주소를 0xFFFFFFFF로 설정한다(MAC주소는 48비트이므로 모든 비트를 1로 설정한 것과 동일함).



③ PC1과 PC2는 ARP Request 패킷의 목적지 MAC 주소가 0xFFFFFFFF임을 확인하고, 패킷의 목적지 주소IP가 자신의 IP주소와 동일한지 확인한다. 

자신이 아니므로 패킷을 버린다(promiscuous 모드로 설정된 경우는 패킷을 버리지 않는다. 와이어샤크 참조).



④ Router0는 ARP Request 패킷의 목적지 MAC 주소가 0xFFFFFFFF임을 확인하고, 패킷의 목적지 주소IP가 자신의 IP주소와 동일한지 확인한다. 

목적지 IP가 자신의 IP주소와 일치함을 확인하고 자신의 MAC주소를 적어서 PC0에게 ARP Response 패킷을 보내준다.



⑤ PC0는 ARP Response를 받은 후, 자신의 ARP Table에 Router0의 IP주소와 MAC주소를 맵핑(mapping)시킨 후에 Router0로 패킷을 전송한다.



⑥ 패킷을 받은 Router0는 자신의 라우팅 테이블을 참조하고 위와 동일한 절차를 반복해서 패킷을 Router1으로 전송한다.



⑦ 패킷을 받은 Router1은 자신의 라우팅 테이블을 참조하고 마찬가지 방식으로 패킷을 PC3으로 전송한다.

​     



## 4wireshark실습

와이어 샤크는 패킷의 이동을 보여주는 가장 유명한 오픈 소스 도구이다.

원래 목적지 ip 주소가 자신이 아니면 해당 클라이언트는 그 패킷을 버리는데 와이어샤크를 이용하면 해당 패킷을 잡을 수 있다. 이런 모드를 LAN 카드가 Promiscuous mode로 설정됐다고 한다.

**Promiscuous mode** : 목적지 ip 주소가 자신이 아닌 패킷도 잡아서 읽어드리는 모드

​					해당 모드는 관리자 권한 있어야 설치나 설정 가능하다. 

## 실습

Npcap 있어야, 패킷 캡처의 약자이다. 패킷 잡는 라이브러리

설치하면서 LAN 카드를 프로미스큐스 모드로 설정했다.

와이어 샤크 설치

머 암것도 안해도 패킷들이 엄청 왔다갔다 하고 있다.

![네트워크패킷전달 4wireshark실습 6-7 screenshot](https://github.com/hhzzzk/studyLog/assets/67236054/1a461287-1dbc-442e-b749-ffa3c711cf0f)



브라우저도 탐방해보자

사이트 들어가자 TLS 암호 프로토콜 패킷 등.패킷이 먼가 엄청 많아진다

​	이게 왜 뜨냐면 사이트가 기본적으로 자물쇠 표시. SSL 암호 통신하는



## 필터링해보자

ip.addr == 121.53.205.232

ip주소 중에 위가 포함된 것만 보여준다.

![네트워크패킷전달 4wireshark실습 9-42 screenshot](https://github.com/hhzzzk/studyLog/assets/67236054/32084031-247e-4f58-b341-c7412243e728)

해당 패킷 자세히 보자

![네트워크패킷전달 4wireshark실습 10-13 screenshot](https://github.com/hhzzzk/studyLog/assets/67236054/52685853-9c09-4723-a997-51eb98086b34)

프레임 아래 보면 이더넷 패킷이 잇다.

## 이더넷 부분

이더넷 헤더 부분을 보면 출발지, 도착지의 MAC 주소가 있다.

아마 목적지 MAC 주소가 자신의 주소일 것이다. 10.30.118.86이 지금 내 IP주소인데

30:24:32:fe:67:12가 내 MAC 주소겠지

![image](https://github.com/hhzzzk/studyLog/assets/67236054/c6c479e3-85da-42bb-8e83-158422359f5c)

source 주소는 국민대의 웹주소다. 접근은 안되는데 암튼

그럼 거기서 TLS로 패킷이 온 걸 내 노트북이 잡았다.

## 인터넷 프로토콜 부분

보면 출발지가 국민대 웹 위의 IP고 도착지가 내 노트북이다.

## TCP 부분

소스 포트번호 443, 디폴트

내 노트북이 쓰는 포트번호 58004, 

![image](https://github.com/hhzzzk/studyLog/assets/67236054/c6339abc-b3d5-4c95-a5d7-3d03d96ecda5)



## 웹주소 접속 절차 한 단계씩 다 보기

웹주소 접속하는 절차.

먼저 내 브라우저가 최초 접속을 시도한다.

![image](https://github.com/hhzzzk/studyLog/assets/67236054/969cdd3b-bd6f-4c6b-9c8a-2f6e05eb2d84)



1. TCP 3way 핸드쉐이크
   - 처음에 클라이언트가 서버에게 SYN 패킷을 보내고 서버가 SYN-ACK 패킷으로 답장한다. 그리고 클라이언트가 서버에게 다시 ACK 패킷을 보낸다.

- 이제 본격적으로 TLS 세션이 맺어질 단계

2. Client_hello

   - 사이퍼 수트, 지원 가능한 암호 알고리즘들
   - 실습 ~ 크롬 브라우저에서 16개 지원 가능하다! 서버는 이 중에 하나 골라라. 그걸로 암호화 통신하자
   - 랜덤 넘버도 하나 생성해 보낸다. 

   ---

   ![image](https://github.com/hhzzzk/studyLog/assets/67236054/d9e89cd5-bceb-4165-aaa5-3216ccc803cc)

   ​

3. Server_hello

   ![image](https://github.com/hhzzzk/studyLog/assets/67236054/0323ffbe-e6ee-4b89-becd-c711d1d8b4df)

   - 해당 사이퍼 수트가 선택됐다.
   - 서버가 생성?선택한 랜덤 넘버도 있다.

![image](https://github.com/hhzzzk/studyLog/assets/67236054/4a02600a-9500-4fc8-842d-2970e0e6e8c4)



서버 헬로우하고 패킷 주고 받고 ~

4. Certificate, Server Key Exchange 패킷도 있고..그렇다.

어우 화질이..

