# SS_4_cryptography_asymmetrickey

```
Asymmetric key cryptography
Diffie-Hellman
RSA
Korean crypto algorithms
```

## 개요

대칭키 암호화는 On^2이었는데 이걸 O(n)으로 줄였다 엄청난

한 사람만 2개의 키를 가지고 시작한다. 개인키 공개키

공개키는 공개되도 상관없다. 공개하자~ 대충 이메일로 보냈다 치면

앨리스가 밥의 공개키 받아서 메시지를 Kb+로 암호화해서 보내면

해당 암호화 메시지는 밥의 개인키로만 풀 수 있다.



이게 어떻게 가능?

## RSA, 디피헬만 등..

RSA 같은 경우는 기밀성을 유지하려면 앨리스가 밥에게 키를 보낼 때 밥의 공개키로 암호화해서 보내면 기밀성이 지켜진다.

앨리스의 개인키로 메시지를 암호화하면 서명이 된다. 서명은 부인 봉쇄가 된다.

그렇다고 모든 공개키 암호화 알고리즘이 기밀성과 부인 봉쇄를 만족하는 건 아니다.



최초의 공개키 암호화 알고리즘 디피헬만은 서명 기능이 없다. 기밀성만 유지된다.

RSA는 기밀성과 부인봉쇄를 둘 다 보장한다.



![image](https://github.com/hhzzzk/studyLog/assets/67236054/a72c5422-8583-4777-92fc-7ca77403e16c)

그림에서 밥은 조이, 마이크, 앨리스, 테드의 공개키를 가지고 있다.

즉 밥은 공개키를 가지고 있는 상대들에게 기밀성이 보장되게 암호화해서 메시지를 보낼 수 있다.



## 공개키 등록 위험성

인터넷에서 인증서는 검증되지 않았습니다. 그래도 접속하시겠습니까? 종종 뜬다.

여기서 예스를 하면 해당 사이트의 공개키를 내 브라우저?에 등록하겠다는 뜻이다.

이는 이후 테드의 공개키라 하면 테드가 개인키로 메시지를 서명해서 보내면

우리는 그걸 믿고 그냥 쓰게 된다. 위험! 공개키 등록하면서 생기는 위험성 다 본인이 감내해야 된다.



## 공개키의 한계

공개키 알고리즘이 다 좋은데 계산이 느리다는 단점이 있다.

대칭키보다 수백 배 이상 느리다. 

그래서 생각해낸게 공개키 알고리즘과 대칭키 알고리즘을 함께 쓰자.



## 공개키 + 대칭키 알고리즘

앨리스와 밥이 통신할 때 Kab를 생성해야 하는데

이 때 앨리스가 밥의 공개키로 공유키를 암호화해서 보낸다.

그럼 밥은 자신의 개인키로 복호화해서 공유키를 얻을 수 있다.

공유키(대칭키) 공유 성공!

![image](https://github.com/hhzzzk/studyLog/assets/67236054/ce895ea9-e2d7-4ad5-8f8d-6d08442e9e8d)



이후 대칭키로 암호화해서 메시지를 보내자. 공개키보다 훨씬 빠르다.

## 여기에 부인 봉쇄까지?

부인 봉쇄까지 하고 싶다하면 해시함수를 써서 메시지를 한 번 암호화한다. h(m)

그리고 그걸 앨리스의 개인키로 서명한다.! 서명하면 부인 봉쇄 Ka-(h(m))

나중에 밥이 앨리스의 공개키로 풀리는 거 보고 앨리스 부인 봉쇄 된다.



*기밀성+무결성+부인봉쇄* 베리베리굿

시험나와요. 그래서 또 정리해보면

## 위 내용 복습 중요부분!!! 시험 나옴

앨리스와 밥이 통신하려고 한다. 앨리스 밥은 각자 개인키 공개키 쌍을 가지고 있다.

둘이 공유할 공유키, Kab를 공유하기 위해

1. 앨리스가 밥의 공개키로 공유키를 암호화해서 전송. 
   - 밥은 개인키로 복호화해서 공유키 공유 성공!
2. 이제 공유키 사용가능. 메시지를 공유키로 암호화. Kab(m) == 기밀성 확보
3. 여기에 메시지를 해시함수하고 앨리스의 개인키로 서명. Ka-(h(m)) == 부인 봉쇄
   - 앨리스가 위 3개를 밥에게 보낸다.

---

1. 밥은 1을 개인키로 복호화해서 공유키 얻었다.
2. 공유키를 얻었으니 메시지를 복호화해서 메시지를 얻었다.
   - 메시지를 밥도 해시함수 처리한 값을 얻었다!!
3. 앨리스의 공개키는 공개되어 있으니 공개키로 서명을 복호화하니까 풀리더라. 해시처리한 메시지 얻음
   - 해당 값과 2에서 계산한 값을 비교해보니 같다면 *무결성 체크 + 부인 봉쇄 확인!!!*

- 앨리스가 서명을 메시지에 바로 하는 것보다 해시처리하면 효율성이, 속도가 훨씬 빨라서! 해시처리한 것에 서명을 한다.

<img src="https://github.com/hhzzzk/studyLog/assets/67236054/652b3415-4489-4fb8-b7ba-c29af1e2cfcc" alt="이미지" width="500">

이 부분 무조건 시험에 나옵니다

![image](https://github.com/hhzzzk/studyLog/assets/67236054/bf950ae2-3d6f-41bd-a0d8-970fa3de3b52)

이 그림은 또 다른 시나리오임 위랑 같은 케이스 아님

![The Neglected Garden](https://github.com/hhzzzk/studyLog/assets/67236054/2e056363-e8f2-4531-8b41-009974449f09)



## Diffie-Hellman

과연 서로 다른 키 두 쌍이 어떤 성질이 있길래 공개키로 암호화하면 개인키로 복호화가 가능하느냐

디피 헬만, RSA 순서로 발전했는지 디피 헬만부터 보자.



## 디피 헬만 목표

앨리스와 밥이 공유키 Kab를 공유하고 싶다.

대칭키로 암호화해서 보낼 수도 있고 해쉬 함수를 써서 MAC할 수도 있는데

안전하게 공유키를 공유하자해서 등장한게 디피 헬만이다. 최초의 공개키 암호화 알고리즘



디피 헬만은 서명 기능은 없지만 안전하게 양쪽이 키를 공유할 수 있다. 기밀성만 보장

## 디피 헬만 동작과정

![image](https://github.com/hhzzzk/studyLog/assets/67236054/2bd172ba-5ae9-4305-a2b2-d2e422fd768a)

---

공개키가 항상 하나의 값인 건 아니고 벡터가 될 수도 있다. 

여기서는 p와 g의 벡터?리스트? 암튼 두 개의 값을 사용한다.

1. 앨리스와 밥은 공유키 p와 g를 공유한다. 어떻게 공유하냐?

- 누가 알아도 상관없다. 그냥 인터넷 세상이나 만천하에 공개
- p와 g는 숫자. 양의 정수. 양쪽이 공유했다.

2. 앨리스는 자기만 아는 비밀값, 양의 정수 x를 생성한다.
   - 그리고 g를 x승한다. 그리고 p로 모듈러(나머지 연산)한다. 
     - 나머지는 p보다 작은 값만 가능, p가 7이면 나머지는 0~6
   - X = g^x mod p, 라지 X값을 구했다.
3. 밥도 같은 과정을 해서 라지 Y를 구했다.
4. 앨리스와 밥이 라지 X,Y값을 서로 전달한다. 준비끝.
5. 앨리스는 라지 Y를 x승한다. 라지 Y도 알고 x도 알고 있으니 연산이 된다. 거듭제곱 계산
   - 그렇게 계산한 값은 g를 xy승한 건 p로 모듈러한 값과 같다.
6. 밥도 라지 X를 y승해서 위의 값과 비교한다. 두 개의 값이 같아야 한다.
7. 그럼 이제 양쪽이 같은 숫자가 공유가 됐다. 해당 값을 Kab로 공유키로 사용한다.

## 해커입장

해커입장에서 보면 p,g를 알고 라지 X,Y도 알 수 있다. 

그러나 작은 x,y를 모르기 때문에 수학적으로 키 값을 해킹할 수가 없다.

해시함수에서 m > h(m)은 쉬워도 반대 방향은 불가능한 것처럼

---

@

## RSA

RSA를 쓰면 기밀성과 부인봉쇄까지 보장한다.

![image](https://github.com/hhzzzk/studyLog/assets/67236054/3c720e10-1b84-45eb-a469-dc6c40519550)

---

각모연모는 각연모..

![image](https://github.com/hhzzzk/studyLog/assets/67236054/54503fde-0b59-4a72-b888-409154a2497a)



![Movement On A Flooded Forest](https://github.com/hhzzzk/studyLog/assets/67236054/f32a1e3d-6fd0-482e-8772-ec7e9019889f)



다음시간시작

## RSA 공개키 개인키 쌍 생성과정

앨리스와 밥이 있다. RSA 키 생성해보자

![image](https://github.com/hhzzzk/studyLog/assets/67236054/b170413d-3e69-4414-8863-482bdaf29855)

---



1. 앨리스는 큰 소수 p, q를 생성한다.

   n을 계산, p와 q를 곱한다. n = p * q

   - 오일러 파이 함수는 (p-1)(q-1)로 ㅈ정의.

2. e를 생성! e의 조건, gcd(e, 오일러파이(n) = 1이어야 한다.

   - 즉 e와 파이는 서로 최대공약수가 1뿐인 서로소 관계여야 한다.

3. e를 생성했으면 d를 생성해야 한다.

   - e * d를 파이n으로 나눴을 때 나머지가 1 == [ e * d mod 파이(n) = 1 ]

4.  이제 Ka- 앨리스의 개인키는 {d,n}이고 앨리스의 공개키는 {e,n}이다.

   - n값은 공개되니 개인키의 d가 유출되면 끝장. d가 중요하다.

## RSA 메시지 암호화

![image](https://github.com/hhzzzk/studyLog/assets/67236054/f5a02128-6d10-4a0d-b79b-8e4a3edc57d1)

---

메시지를 앨리스의 공개키로 암호화해보자.

공개키는 {e,n}이었다.

그럼 메시지를 e승해서 n으로 모듈러한다. C = (M^e mod n)

 - n은 p * q 였다. C는 결국 n보다 작은 정수일 것이다.
 - 앨리스가 공개키로 메시지를 암호화했다.

## RSA 메시지 복호화

개인키는 {d,n}이었다.

암호화한 C를 d승해서 n으로 모듈러한다.



## 페르마의 소정리

등...

[참고](https://miho273.tistory.com/40)

![image](https://github.com/hhzzzk/studyLog/assets/67236054/54a7ee39-bbbe-488d-a8e8-62c8620ce3a2)



## RSA의 보안

RSA에서 n과 e는 공개된다. 개인키의 d가 비밀로 유지되면서 보안을 유지한다.

d를 알아내려면 

e*d = k(p-1)(q-1)+1 이다. 그러나 이걸로 d를 알아낼 수는 없고 서로소인 두 쌍(p-1, q-1)은 무수히 많다.

결국 부르트포스로 p,q 알아내는 방법뿐인데 굉장히 어렵다.

이런 소인수분해의 난해함으로 RSA는 보안이 유지된다.



담시간~

## RSA의 서명

RSA는 디피헬만과는 다르게 기밀성과 부인봉쇄=전자서명까지 가능하다.

앨리스는 공개키 (ea, na)와 개인키 (da,na)가지고 밥도 가진다.

![image](https://github.com/hhzzzk/studyLog/assets/67236054/6e3b720d-9d92-4699-8200-91deebf99e00)

암호화하고 복호화하는 과정~

![image](https://github.com/hhzzzk/studyLog/assets/67236054/3f8b1c5e-8b2b-45e4-a186-7942b04896b3)

전자서명은 암호화와 다르게 앨리스가 개인키로 암호화한다.



## 전체적으로 비대칭키=공개키 정리

13페이지

공개키는 연산량이 많기 때문에 대칭키와 메시지 다이제스트, 해시 함수 처리해서 이렇게 3가지를 함께 쓰는 경우가 많다.

![image](https://github.com/hhzzzk/studyLog/assets/67236054/5209b008-73b8-4fef-92a2-abf07aedccc4)

1. 앨리스는 세션키, 공유키를 생성한다.
   - 대칭키 암호 알고리즘에서 사용되는 키를 세션키라고 한다.
2. 앨리스는 세션키를 밥의 공개키로 암호화해서 보낸다. 밥 개인키로 복화해서 세션키 공유 완
3. 앨리스는 큰파일인 m을 세션키로 암호화, AES 알고리즘을 사용해 암호화한다 = 기밀성확보
4. 밥은 세션키를 AES 알고리즘으로 복호화해서 메시지를 얻는다.



![image](https://github.com/hhzzzk/studyLog/assets/67236054/8b9443e7-5234-4752-8ed7-0044c596f12a)

전자서명

메시지가 굉장히 큰 동영상이다 하면 개인키로 서명하려면 너무 오래 걸린다. (공개키 계산 많고 느림)

그래서 해시함수, 메시지 다이제스트를 사용한다.

- K-(m) == K-(h(m))한 것이 거의 동일하다. 
- 해시함수의 일방향성 때문에서명한 해시m에서 m을 찾는 것도 불가능하다.

검증은

앨리스가 검증하려고 한다. 원본 m을 밥에게 보내달라 한다.

앨리스는 해시m을 계산 가능하다. 계산하고 밥의 공개키로 서명을 푼다.

밥이 서명한 값과 앨리스가 계산한 두 값을 비교해서 서명을 확인한다.

+해당 그림에서는 기밀성은 고려하지 않기 때문에 메시지 m을 암호화하지 않고 보내고 있다.

## RSA 프로토콜의 약점

지금까지 메시지 m을 공개키로 암호화하고 대칭키로 암호화했다.

그런데 메시지가 아니라 메시지에 대한 해쉬값을 서명했다. 효율적이나 여기서 해커가 침입할 여지가 있다.



앨리스가 접속한 사이트 자체가 해커 맬러리의 가짜 사이트라고 한다면 

앨리스가 해당 사이트에 접속해 맬러리의 공개키를 받으면 앞으로 다 속는다.



문제는 공개키가 진짜 찾던 밥의 공개키가 아니였던 것이다.

이를 해결하려면 *공개키를 믿을 수 있는지 확인하는 절차*가 필요하다.



## CA의 등장

인증기관의 등장.

밥이 자신의 공개키 생성할 때 CA를 방문해서 밥인지 검증하는 과정 거치고

CA에서 인증서를 발급한다 == CA의 개인키로 서명을 받는다. Kc-(Kb+)

서명받을 때 밥의 공개키와 밥의 신원을 식별할 수 있는 정보를 concat해서 서명한다. 이게 인증서





아래는 걍참고~

![Frosted Citadel, Anton Fadeev](https://github.com/hhzzzk/studyLog/assets/67236054/e64c7bdf-514c-4c94-bab6-2bac926faed0)

## [Asymmetric vs Symmetric] key cryptography 비교

### 🐯Symmetric key cryptography🐯

대칭키 암호화

- 송수신자가 공유 비밀키를 알고 있다.
- 키 관리와 배포의 어려움이 있고 통신 규모가 커질수록 더 어려워진다.
- O(n^2)

### 🐯Asymmetric key cryptography🐯

비대칭키 암호화

- 공개 키 암호화라고도 한다.
- 송수신자가 동일한 비밀키를 공유하지 않는다.
- 모든 사람이 아는 공개 암호화 키가 존재한다. 이 키를 사용해 메시지를 암호화한다.
- 공개키로 암호화한 메시지를 복호화하려면 공개키에 맞는 페어인 개인키가 필요하다.
- 대칭키 암호화와 비교해 키 관리가 쉽고 키 배포가 효율적이다.
- O(n)



## Asymmetric key cryptography

두 개의 키를 사용한다. 공개키와 개인키.

공개키로 암호화한 메시지를 개인키로만 복호화가 가능하다.

![image](https://github.com/hhzzzk/studyLog/assets/67236054/b1375f41-5872-425b-abca-92a70a574ffb)

## Digital signature

메시지 m에 개인키를 사용해 암호화해 디지털 서명을 생성할 수 있다. 

디지털 서명은 정보의 송신자, 개인키로 암호화한 사람을 확인할 수 있다.

다른 이들은 공개키를 통해 디지털 서명을 복호화할 수 있다. 

그리고 정보의 해시를 다시 계산해 해시가 서명과 일치하면 정보의 무결성과 출처를 확인할 수 있다.

![image](https://github.com/hhzzzk/studyLog/assets/67236054/25005ab1-9012-4517-ab2e-6065cd1ea0df)



## 암호화와 서명 비교

암호화 encryption은 공개키로 암호화하고 개인키로 복호화한다.

서명, 디지털 시그니쳐는 개인키로 암호화하고 개인키로 복호화한다.



## Asymmetric key cryptography 특징

일반적으로 비대칭키 암호화는 비용이 많이 소요된다. 무겁고 느리다.

1. 대칭키 설정에 사용된다.
2. 메시지 다이제스트에 서명하는데 사용된다.



### 1. Used for establishing “symmetric key"

대칭키를 설정하는데 사용된다.

대칭키 암호화는 하나의 공통 키를 사용해 데이터를 암호화하고 복호화하므로 대칭키를 안전하게 교환하기 어려움이 있다.

비대칭키 암호화는 이러한 문제를 해결하는데 사용된다. 송수신자는 각자 개인키를 가지고 있고 공개키는 공개되어 있다.

송신자는 수신자의 공개키를 사용해 대칭키를 암호화하고 전송한다.

수신자는 개인키를 사용해 복호화해 대칭키를 얻는다. 

![image](https://github.com/hhzzzk/studyLog/assets/67236054/ce895ea9-e2d7-4ad5-8f8d-6d08442e9e8d)

---

### 2. Used for signing “message digest”

비대칭 키 암호화를 사용해 디지털 서명을 생성하고 확인한다.

송신자는 메시지의 해시를 생성하고 해시를 개인키를 사용해 암호화해 디지털 서명을 생성한다.

수신자는 서명된 메시지에서 디지털 서명을 복호화하여 송신자가 얻은 해시 값을 확인하고, 

​	동시에 수신한 메시지에서 직접 계산한 해시 값을 확인한다. 

​	두 해시 값이 일치하는지에 따라 메시지의 무결성을 확인한다.

![image](https://github.com/hhzzzk/studyLog/assets/67236054/bf950ae2-3d6f-41bd-a0d8-970fa3de3b52)



## 비대칭키 암호화 알고리즘의 종류

1. Diffie-Hellman
2. RSA
3. Elliptic curve



## Diffie-Hellman

공개키 암호화 및 비대칭 키 교환의 초기 개념이다. 두 사람 사이에 안전하게 *비밀 대칭키를 공유*할 수 있는 방법을 제공한다.

- 각 사람은 두 개의 키 한 쌍을 생성한다. [공개키, 개인키]
- 두 사람 사이의 비밀 대칭키를 공유하는 과정
  - 앨리스가 밥의 공개키로 대칭키를 암호화 (B+m)
  - 밥이 개인키B-로 복호화, 대칭키 공유 성공

### 🐯기본 원리🐯

앨리스와 밥은 큰 소수 p와 g( p보다 작은 수 )를 합의한다. p와 g는 공개된다.

- 개인 키 생성 ~ *개인 숫자*
  - 앨리스는 비밀 개인키 x를 선택한다. x는 1 ~ p-2 사이의 임의의 정수다
  - 밥은 비밀 개인키 y를 선택한다. y도 1 ~ p-2 사이의 임의의 정수다.
- 공개 키 생성 ~ *X,Y는 공개 숫자*
  - 앨리스는 g^x mod p를 계산해 공개키 X를 생성한다. X를 밥에게 보낸다.
  - 밥은 g^y mod p를 계산해 공개키 Y를 생성하고 앨리스에게 보낸다.
- 공통 키 계산
  - 앨리스는 밥으로부터 받은 Y를 사용해 K = Y^x mod p를 계산한다.
  - 밥은 앨리스에게 받은 X를 사용해 K = X^y mod p를 계산한다.

**정리**💖💖💖

앨리스와 밥은 공통 키 K를 안전하게 교환했다. 

---

---



## RSA

- 가장 잘 알려진 공개키 암호화 알고리즘이다. 
- 개인키/공개키를 사용해 암호화 복호화를 수행한다.
- 주로 짧은 메시지 암호화, 디지털 서명 및 비밀 키 교환에 사용된다.
- 보안은 큰 숫자의 소인수분해가 어렵다는 점에 의존한다.



## 모듈러 산술

모듈러 산술은 정수 연산에서 나머지를 사용해 수를 제한하는 수학적 개념이다.

- x mod n = x를 n으로 나눌 때 나머지를 의미한다.

- 덧셈 : 두 개의 수 a,b를 각각 n으로 모듈러하고 더한 뒤 그 결과를 다시 n으로 모듈러한 값은 == 

  ​	`[(a mod n) + (b mod n)] mod n`

  ​	두 수를 더하고 n으로 모듈러한 값과 같다. 

  ​	`(a+b) mod n`

- 뺄셈 : 두 수를 각 모듈러하고 뺄셈하고 모듈러한 값은  == 두 수를 빼고 모듈러한 값과 같다.

  ​	`[(a mod n) - (b mod n)] mod n = (a-b) mod n`

- 곱셈 : 두 수를 각 모듈러하고 곱셈하고 다시 모듈러한 값은 == 두 수를 곱하고 모듈러한 값과 같다.

  ​	`[(a mod n) * (b mod n)] mod n = (a*b) mod n`


> 두 수 각 모듈러해서 연산해서 모듈러한 값은 두 수 연산하고 모듈러한 값과 같다.
>
> 각모연모 는 각연모


## 모듈러 지수 연산, 제곱 연산의 성질 thus 교환법칙

모듈러 곱셈의 성질 : [(a mod n) * (b mod n)] mod n = (a * b) mod n

- **모듈러 지수 연산의 성질**
  - a를 모듈러하고 d 제곱한 값을 다시 모듈러한 값은 == a를 d제곱한 값을 모듈러한 값과 같다. 
  - `(a mod n)^d mod n = a^d mod n`

- a와 b가 같은 값이면 모듈러한 값도 같다. 

- 제곱의 모듈러 연산

  - a를 모듈러한 뒤 제곱한 값을 모듈러한 값은 == a를 제곱한 값을 모듈러한 것과 같다. 
  - `[(a mod n) * (a mod n)] mod n = (a*a) mod n`

- 예제

  ![image](https://github.com/hhzzzk/studyLog/assets/67236054/1c8aa463-af60-41b0-8170-f5ee63ea491e)

  ​

## RSA : 공개/개인키 쌍 생성 과정

- 앨리스와 밥은 무작위로 큰 소수인  p와 q를 선택한다.
- **모듈러 계산**
  - 이 두 소수를 사용해 시스템 모듈러 n을 계산한다. n은 p와 q를 곱한 값이다.
- **오일러 파이 함수 계산**
  - ø(n)는 파이 함수로 n보다 작고 n과 서로소인 양의 정수의 개수이다.
  - ø(n) = (p-1)(q-1)이다. 
- **공개 키 생성(e와 n 사용)**
  - 무작위로 암호화 키인 e를 선택한다.  
    - e의 조건 : 1 < e < ø(n) 여야 하고 e와 ø(n)은 서로소여야 한다.
- **개인 키 생성(d)**
  - 암호화 키 e와 모듈러 n을 사용해 복호화 키 d를 찾는다.
    - d의 조건 : e * d ≡ 1 (mod ø(n))이며, 0 ≤ d ≤ n
- 키 공개합니다.
  - 공개키 PU = {e,n}
  - 개인키 PR = {d,n}
    - 개인키 d는 비밀로 유지한다.



## RSA : 메시지를 암호화/복호화하기

(앨리스 - 전송자, 밥 - 수신자)

**앨리스** : 암호화

- 밥의 공개키 PU={e,n}을 얻는다
- C = M^e mod n 을 계산한다. 0 ≤ M < n이다.

**밥** : 복호화

- 밥의 개인키 PR={d,n}을 사용한다.
- M = C^d mod n 을 계산한다.
- 메시지 M은 모듈러 n보다 작아야 하며 그렇지 않다면 블록으로 나눠야 한다.



## 오일러의 ø파이 함수

주어진 정수 n까지의 양의 정수 중에 n과 서로소인 개수를 세는 함수이다. 

즉 n으로 나누었을 때 나머지가 1인 양의 정수의 개수를 나타낸다. 

예시로 ø(5)는 4이다 (1,2,3,4가 5와 서로소이다.) 

*즉 p가 소수인 경우 ø(p) = p-1이 된다.*

### 💖페르마의 소정리💖

소수 p와 양의 정수 a에서

a^(p-1)을 p로 나눈 나머지는 1이다. 

a^(p-1) mod p = 1

### 💖RSA에서의 활용💖

RSA 암호 시스템에서 공개키와 개인키를 생성할 때 소수 p와 q를 사용해 모듈러 n을 계산한다. 

​	그리고 ø(n)은 (p-1)(q-1)로 계산된다.

공개키 e와 개인키 d는 ø(n)에 대한 역수 관계를 가져야 한다.

​	즉 e * d ≡ 1 + k * ø(n)여야 한다. 

- **메시지 암호화 및 복호화**
  - RSA에서 메시지 M을 암호화할 때 C = M^e mod n를 사용한다.
  - 복호화할 때는 C^d mod n을 사용해 원래 메시지 M을 복원한다.
  - 페르마의 소정리와 ø(파이) 함수의 성질을 활용해 암호화와 복호화를 수행한다.

```
Cd = Me * d = M^(1 + k * ø(n)) = M^1 * (M^ø(n))^k = M^1 * 1^k = M^1 = M mod n
```



## 페르마의 소정리

소수 p와 그와 서로소인 양의 정수 a에 대한 정리이다.

- a^(p-1) ≡ 1 (mod p), 여기서 gcd(a, p) = 1
- 이것은 a를 p로 나눈 나머지를 p로 모듈러한 결과가 1이 되는 것

### 💖증명💖

1. 먼저, a를 a, 2a, 3a, ..., (p-1)a와 같이 서로 다른 p-1개의 정수로 곱한 집합을 생각합니다. 이 집합의 모든 원소를 p로 나눈 나머지를 계산하면, 모두 서로 다른 값을 가져야 합니다. 왜냐하면 귀류법(reductio ad absurdum)을 사용하여 이를 입증할 수 있습니다.
2. 귀류법을 사용하여, 두 서로 다른 원소 ia와 ja가 같은 나머지를 가질 때 (0 < i < j < p), 두 수의 차는 p로 나눠질 것입니다. 즉, (j-i)a는 p의 배수여야 합니다. 그러나 a는 p와 서로소이므로, a와 p는 어떤 공통된 인수를 가지지 않습니다. 따라서 j-i는 p의 배수가 아니며, a는 p와 서로소이므로 두 수는 서로 다른 나머지를 가져야 합니다. 따라서 집합 {1, 2, ..., p-1}의 원소들은 모두 서로 다른 나머지를 가집니다.
3. 이제 a * 2a * 3a * ... * (p-1)a를 mod p 연산한 결과는 1 * 2 * 3 * ... * (p-1)을 mod p 연산한 결과와 같습니다.
4. 양변을 (p-1)!로 나누면, a^(p-1) mod p = 1 * 2 * 3 * ... * (p-1) mod p가 됩니다.
5. 따라서 a^(p-1) mod p = 1이 되며, 페르마의 소정리가 증명됩니다.



## 문제 예시

![image](https://github.com/hhzzzk/studyLog/assets/67236054/420b1e4b-91f3-4aa8-b92b-f087bb5534c8)

