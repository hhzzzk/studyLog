# SS_4_cryptography_asymmetrickey

```
Asymmetric key cryptography
Diffie-Hellman
RSA
Korean crypto algorithms
```



## [Asymmetric vs Symmetric] key cryptography 비교

### 🐯Symmetric key cryptography🐯

대칭키 암호화

- 송수신자가 공유 비밀키를 알고 있다.
- 키 관리와 배포의 어려움이 있고 통신 규모가 커질수록 더 어려워진다.
- O(n^2)

### 🐯Asymmetric key cryptography🐯

비대칭키 암호화

- 공개 키 암호화라고도 한다.
- 송수신자가 동일한 비밀키를 공유하지 않는다.
- 모든 사람이 아는 공개 암호화 키가 존재한다. 이 키를 사용해 메시지를 암호화한다.
- 공개키로 암호화한 메시지를 복호화하려면 공개키에 맞는 페어인 개인키가 필요하다.
- 대칭키 암호화와 비교해 키 관리가 쉽고 키 배포가 효율적이다.
- O(n)



## Asymmetric key cryptography

두 개의 키를 사용한다. 공개키와 개인키.

공개키로 암호화한 메시지를 개인키로만 복호화가 가능하다.

![image](https://github.com/hhzzzk/studyLog/assets/67236054/b1375f41-5872-425b-abca-92a70a574ffb)

## Digital signature

메시지 m에 개인키를 사용해 암호화해 디지털 서명을 생성할 수 있다. 

디지털 서명은 정보의 송신자, 개인키로 암호화한 사람을 확인할 수 있다.

다른 이들은 공개키를 통해 디지털 서명을 복호화할 수 있다. 

그리고 정보의 해시를 다시 계산해 해시가 서명과 일치하면 정보의 무결성과 출처를 확인할 수 있다.

![image](https://github.com/hhzzzk/studyLog/assets/67236054/25005ab1-9012-4517-ab2e-6065cd1ea0df)



## 암호화와 서명 비교

암호화 encryption은 공개키로 암호화하고 개인키로 복호화한다.

서명, 디지털 시그니쳐는 개인키로 암호화하고 개인키로 복호화한다.



## Asymmetric key cryptography 특징

일반적으로 비대칭키 암호화는 비용이 많이 소요된다. 무겁고 느리다.

1. 대칭키 설정에 사용된다.
2. 메시지 다이제스트에 서명하는데 사용된다.



### 1. Used for establishing “symmetric key"

대칭키를 설정하는데 사용된다.

대칭키 암호화는 하나의 공통 키를 사용해 데이터를 암호화하고 복호화하므로 대칭키를 안전하게 교환하기 어려움이 있다.

비대칭키 암호화는 이러한 문제를 해결하는데 사용된다. 송수신자는 각자 개인키를 가지고 있고 공개키는 공개되어 있다.

송신자는 수신자의 공개키를 사용해 대칭키를 암호화하고 전송한다.

수신자는 개인키를 사용해 복호화해 대칭키를 얻는다. 

![image](https://github.com/hhzzzk/studyLog/assets/67236054/ce895ea9-e2d7-4ad5-8f8d-6d08442e9e8d)

---

### 2. Used for signing “message digest”

비대칭 키 암호화를 사용해 디지털 서명을 생성하고 확인한다.

송신자는 메시지의 해시를 생성하고 해시를 개인키를 사용해 암호화해 디지털 서명을 생성한다.

수신자는 서명된 메시지에서 디지털 서명을 복호화하여 송신자가 얻은 해시 값을 확인하고, 

​	동시에 수신한 메시지에서 직접 계산한 해시 값을 확인한다. 

​	두 해시 값이 일치하는지에 따라 메시지의 무결성을 확인한다.

![image](https://github.com/hhzzzk/studyLog/assets/67236054/bf950ae2-3d6f-41bd-a0d8-970fa3de3b52)



## 비대칭키 암호화 알고리즘의 종류

1. Diffie-Hellman
2. RSA
3. Elliptic curve



## Diffie-Hellman

공개키 암호화 및 비대칭 키 교환의 초기 개념이다. 두 사람 사이에 안전하게 *비밀 대칭키를 공유*할 수 있는 방법을 제공한다.

- 각 사람은 두 개의 키 한 쌍을 생성한다. [공개키, 개인키]
- 두 사람 사이의 비밀 대칭키를 공유하는 과정
  - 앨리스가 밥의 공개키로 대칭키를 암호화 (B+m)
  - 밥이 개인키B-로 복호화, 대칭키 공유 성공

### 🐯기본 원리🐯

앨리스와 밥은 큰 소수 p와 g( p보다 작은 수 )를 합의한다. p와 g는 공개된다.

- 개인 키 생성 ~ *개인 숫자*
  - 앨리스는 비밀 개인키 x를 선택한다. x는 1 ~ p-2 사이의 임의의 정수다
  - 밥은 비밀 개인키 y를 선택한다. y도 1 ~ p-2 사이의 임의의 정수다.
- 공개 키 생성 ~ *X,Y는 공개 숫자*
  - 앨리스는 g^x mod p를 계산해 공개키 X를 생성한다. X를 밥에게 보낸다.
  - 밥은 g^y mod p를 계산해 공개키 Y를 생성하고 앨리스에게 보낸다.
- 공통 키 계산
  - 앨리스는 밥으로부터 받은 Y를 사용해 K = Y^x mod p를 계산한다.
  - 밥은 앨리스에게 받은 X를 사용해 K = X^y mod p를 계산한다.

**정리**💖💖💖

앨리스와 밥은 공통 키 K를 안전하게 교환했다. 

---

---



## RSA

- 가장 잘 알려진 공개키 암호화 알고리즘이다. 
- 개인키/공개키를 사용해 암호화 복호화를 수행한다.
- 주로 짧은 메시지 암호화, 디지털 서명 및 비밀 키 교환에 사용된다.
- 보안은 큰 숫자의 소인수분해가 어렵다는 점에 의존한다.



## 모듈러 산술

모듈러 산술은 정수 연산에서 나머지를 사용해 수를 제한하는 수학적 개념이다.

- x mod n = x를 n으로 나눌 때 나머지를 의미한다.

- 덧셈 : 두 개의 수 a,b를 각각 n으로 모듈러하고 더한 뒤 그 결과를 다시 n으로 모듈러한 값은 == 

  ​	`[(a mod n) + (b mod n)] mod n`

  ​	두 수를 더하고 n으로 모듈러한 값과 같다. 

  ​	`(a+b) mod n`

- 뺄셈 : 두 수를 각 모듈러하고 뺄셈하고 모듈러한 값은  == 두 수를 빼고 모듈러한 값과 같다.

  ​	`[(a mod n) - (b mod n)] mod n = (a-b) mod n`

- 곱셈 : 두 수를 각 모듈러하고 곱셈하고 다시 모듈러한 값은 == 두 수를 곱하고 모듈러한 값과 같다.

  ​	`[(a mod n) * (b mod n)] mod n = (a*b) mod n`



## 모듈러 지수 연산, 제곱 연산의 성질 thus 교환법칙

모듈러 곱셈의 성질 : [(a mod n) * (b mod n)] mod n = (a * b) mod n

- **모듈러 지수 연산의 성질**
  - a를 모듈러하고 d 제곱한 값을 다시 모듈러한 값은 == a를 d제곱한 값을 모듈러한 값과 같다. 
  - `(a mod n)^d mod n = a^d mod n`

- a와 b가 같은 값이면 모듈러한 값도 같다. 

- 제곱의 모듈러 연산

  - a를 모듈러한 뒤 제곱한 값을 모듈러한 값은 == a를 제곱한 값을 모듈러한 것과 같다. 
  - `[(a mod n) * (a mod n)] mod n = (a*a) mod n`

- 예제

  ![image](https://github.com/hhzzzk/studyLog/assets/67236054/1c8aa463-af60-41b0-8170-f5ee63ea491e)

  ​

## RSA : 공개/개인키 쌍 생성 과정

- 앨리스와 밥은 무작위로 큰 소수인  p와 q를 선택한다.
- **모듈러 계산**
  - 이 두 소수를 사용해 시스템 모듈러 n을 계산한다. n은 p와 q를 곱한 값이다.
- **오일러 파이 함수 계산**
  - ø(n)는 파이 함수로 n보다 작고 n과 서로소인 양의 정수의 개수이다.
  - ø(n) = (p-1)(q-1)이다. 
- **공개 키 생성(e와 n 사용)**
  - 무작위로 암호화 키인 e를 선택한다.  
    - e의 조건 : 1 < e < ø(n) 여야 하고 e와 ø(n)은 서로소여야 한다.
- **개인 키 생성(d)**
  - 암호화 키 e와 모듈러 n을 사용해 복호화 키 d를 찾는다.
    - d의 조건 : e * d ≡ 1 (mod ø(n))이며, 0 ≤ d ≤ n
- 키 공개합니다.
  - 공개키 PU = {e,n}
  - 개인키 PR = {d,n}
    - 개인키 d는 비밀로 유지한다.



## RSA : 메시지를 암호화/복호화하기

(앨리스 - 전송자, 밥 - 수신자)

**앨리스** : 암호화

- 밥의 공개키 PU={e,n}을 얻는다
- C = M^e mod n 을 계산한다. 0 ≤ M < n이다.

**밥** : 복호화

- 밥의 개인키 PR={d,n}을 사용한다.
- M = C^d mod n 을 계산한다.
- 메시지 M은 모듈러 n보다 작아야 하며 그렇지 않다면 블록으로 나눠야 한다.



## 오일러의 ø파이 함수

주어진 정수 n까지의 양의 정수 중에 n과 서로소인 개수를 세는 함수이다. 

즉 n으로 나누었을 때 나머지가 1인 양의 정수의 개수를 나타낸다. 

예시로 ø(5)는 4이다 (1,2,3,4가 5와 서로소이다.) 

*즉 p가 소수인 경우 ø(p) = p-1이 된다.*

### 💖페르마의 소정리💖

소수 p와 양의 정수 a에서

a^(p-1)을 p로 나눈 나머지는 1이다.

### 💖RSA에서의 활용💖

RSA 암호 시스템에서 공개키와 개인키를 생성할 때 소수 p와 q를 사용해 모듈러 n을 계산한다. 

​	그리고 ø(n)은 (p-1)(q-1)로 계산된다.

공개키 e와 개인키 d는 ø(n)에 대한 역수 관계를 가져야 한다.

​	즉 e * d ≡ 1 + k * ø(n)여야 한다. 

- **메시지 암호화 및 복호화**
  - RSA에서 메시지 M을 암호화할 때 C = M^e mod n를 사용한다.
  - 복호화할 때는 C^d mod n을 사용해 원래 메시지 M을 복원한다.
  - 페르마의 소정리와 ø(파이) 함수의 성질을 활용해 암호화와 복호화를 수행한다.

```
Cd = Me * d = M^(1 + k * ø(n)) = M^1 * (M^ø(n))^k = M^1 * 1^k = M^1 = M mod n
```



## 페르마의 소정리

소수 p와 그와 서로소인 양의 정수 a에 대한 정리이다.

- a^(p-1) ≡ 1 (mod p), 여기서 gcd(a, p) = 1
- 이것은 a를 p로 나눈 나머지를 p로 모듈러한 결과가 1이 되는 것

### 💖증명💖

1. 먼저, a를 a, 2a, 3a, ..., (p-1)a와 같이 서로 다른 p-1개의 정수로 곱한 집합을 생각합니다. 이 집합의 모든 원소를 p로 나눈 나머지를 계산하면, 모두 서로 다른 값을 가져야 합니다. 왜냐하면 귀류법(reductio ad absurdum)을 사용하여 이를 입증할 수 있습니다.
2. 귀류법을 사용하여, 두 서로 다른 원소 ia와 ja가 같은 나머지를 가질 때 (0 < i < j < p), 두 수의 차는 p로 나눠질 것입니다. 즉, (j-i)a는 p의 배수여야 합니다. 그러나 a는 p와 서로소이므로, a와 p는 어떤 공통된 인수를 가지지 않습니다. 따라서 j-i는 p의 배수가 아니며, a는 p와 서로소이므로 두 수는 서로 다른 나머지를 가져야 합니다. 따라서 집합 {1, 2, ..., p-1}의 원소들은 모두 서로 다른 나머지를 가집니다.
3. 이제 a * 2a * 3a * ... * (p-1)a를 mod p 연산한 결과는 1 * 2 * 3 * ... * (p-1)을 mod p 연산한 결과와 같습니다.
4. 양변을 (p-1)!로 나누면, a^(p-1) mod p = 1 * 2 * 3 * ... * (p-1) mod p가 됩니다.
5. 따라서 a^(p-1) mod p = 1이 되며, 페르마의 소정리가 증명됩니다.



## 문제 예시

![image](https://github.com/hhzzzk/studyLog/assets/67236054/420b1e4b-91f3-4aa8-b92b-f087bb5534c8)

