# SS_hash_(ch3-1)

```
Cryptographic hash function
Birthday attack
Message Authentication Code
One Time Password
```



## Cryptographic hash function

메시지 digest function

- 임의의 길이의 메시지를 고정 길이의 출력으로 매핑하는 함수이다.
- digest는 해쉬와 비슷한 개념이다. 엄밀히 말하면 해시는 임의의 입력 데이터를 고정 길이의 출력 데이터로 매핑하는 알고리즘이다(해싱) 다이제스트는 해시 함수를 통해 생성된 고정된 길이의 출력 데이터를 가리킨다.

일방향 함수

- 암호화된 H(m)에서 m을 유추할 수 없다.

입력 변경에 대한 반응

- 입력 내용을 한 개 비트만 변경해도 출력의 모든 비트가 50프로 확률로 변경된다.
- 입력의 작은 변화가 출력에 큰 영향을 미친다.

충돌 저항성

- 메세지가 서로 다를 때 H(m1) != H(m2)  다이제스트는 달라야한다.



​	🍞**해시 함수의 종류**🍞

- MD5
  - message digest 5
  - 입력은 임의 비트 n개고 출력은 128비트이다. (원본 메시지를 고정 길이의 다이제스트로 매핑)
  - 그 밖에도 MD2, MD4가 있다. 보안 수준은 더 낮다.



- SHA-1
  - secure hash algorithm-1
  - 입력의 임의 비트 n개고 출력은 160비트이다.
  - SHA-256, SHA-384, SHA-512 등으로 발전해서 사용된다.



-  RIPEMD-160, Whirlpool 



​	🍞**해시함수의 단계**🍞

- 1단계 : 메시지 패딩
  - 입력 메시지를 특정 길이로 패딩해 *고정된 길이의 블록*으로 만든다.
  - 일반적으로 512비트의 *배수*로 메시지를 채운다. 이를 통해 메시지가 정확한 크기의 블록으로 나눠진다.
  - 16워드, 64옥텟은 16개의 워드로 구성된 데이터 블록과 64개의 바이트로 구성된 데이터 블록이다. 옥텟은 바이트라고도 한다.
- 2단계 : 메시지 처리
  - 패딩된 메시지는 512비트씩 블록으로 나눠진다. 각 블록은 해시 함수에 의해 처리되어 고정된 길이의 메시지 다이제스트를 생성한다. 


💌💌💌💌💌💌💌💌💌💌💌💌💌💌💌💌💌💌💌💌💌💌💌💌💌💌💌💌💌💌💌💌💌💌💌💌


## Birthday attack

생일 공격은 생일 역설 개념에 기반한 공격 기법이다. 생일 역설은 ''서로 다른 사람들 사이에서 두 사람의 생일 동일한 확률이 언제인가?'' 에 대한 개념이다.

- 생일 역설
  - 예상보다 더 적은 사람 수가 동일한 생일을 가지고 있다.
  - 두 명의 사람이 동일한 생일을 가질 확률은 365일 중의 하나이므로 0.27프로이다.
  - 그러나 사람 수가 증가함에 따라 중복생일이 발생할 확률은 급격히 증가한다.
- 생일 공격
  - 생일 역설을 활용해 해시 함수나 랜덤 생성 알고리즘의 충돌(두 개의 서로 다른 입력이 동일한 출력을 생성하는 상황)을 찾는데 사용된다.
  - 이러한 충돌은 해시 함수의 취약성을 나타낸다.
- 결론
  - 해시 충돌(두 개의 다른 입력이 같은 해시로 매핑되는 상황)이 예상보다 더 자주 발생한다. 
  - 64비트 암호는 메시지 다이제스트로 선택하기에 좋지 않다.
  - 해시 함수의 출력은 128비트로 커야 한다.


💌💌💌💌💌💌💌💌💌💌💌💌💌💌💌💌💌💌💌💌💌💌💌💌💌💌💌💌💌💌💌💌💌💌💌💌


## Message Authentication Code - MAC

>  메세지 인증 코드. 메시지를 보낼 때 메시지와 함께 메시지의 무결성, 변조되지 않았음을 확인할 수 있는 추가적인 정보를 함께 보낸다.

전제 ; 공유 비밀키 Kab

1. 메시지와 키를 연결하고 거기에 해시 함수를 적용한 H(m || Kab)를 계산. 이게 인증태그!
2. 메시지와 인증태그를 함께 전송한다.
3. 받은 사람은 받은 메시지와 키를 연결해 마찬가지로 인증태그를 계산하여 값을 비교한다.
4. 값이 다르다면 메시지가 변조된 것이다.

---



- 메시지 인증
  - 메시지의 intergrity 무결성 보호 > 방송같은 경우 보안보다 내용 변조 여부가 중요
  - 송신자의 신원 확인
  - 송신자의 non-repudiation 부인 봉쇄
- 메시지 인증 코드 MAC
  - 어떤 메시지에 대한 고정 크기의 인증자
  - 메시지에 대한 인증 제공
  - 블록 암호 모드나 해시 함수 사용
- Keyed hash function
  - 메시지와 비밀키를 입력 받는다.
  - 메시지와 키를 이용해 안전한 해시 값을 생성한다. - 인증태그!
    - 키와 메시지의 결합으로 MAC가 생성되므로 메시지와 키가 모두 필요하다.
  - 초기에는 H(Key | m) 형태의 키와 메시지 결합이 제안되었으나 취약점이 있어 HMAC가 개발되었다.
  - 🍞*HMAC(해시 기반 메시지 인증 코드)*🍞
    - H(m | Key) 형태로 해시 함수와 키를 결합해 MAC를 생성한다.
    - MAC보다 안전한 해시 함수(SHA-256)를 사용한다.
    - 내부적으로 키를 확장하는 알고리즘을 사용해 보안성을 높인다.

💌💌💌💌💌💌💌💌💌💌💌💌💌💌💌💌💌💌💌💌💌💌💌💌💌💌💌💌💌💌💌💌💌💌💌💌

## One Time Password

>  일회용 비밀번호는 각 로그인 시마다 새로운 비밀번호를 사용하는 보안 기술이다. 생성하는데 해시 함수를 사용할 수 있다.

- **해시 함수를 사용한 일회용 비밀번호**

  - 각 로그인 시마다 새로운 비밀번호를 사용해 보안을 강화한다.

- **Time-synchronized 시간 동기화 필요**

  - 시간 동기화가 필요한 OTP 시스템에서는 사용자와 서버 간의 시간을 동일하게 유지해야 한다.
  - 시간 동기화는 보안시스템에서 사용되는 중요한 개념으로 주로 보안 토큰(보안카드 또는 하드웨어)을 사용하는 인터넷 뱅킹과 같은 응용 프로그램에서 사용됩니다.

- **수학적 알고리즘 사용**

  - 일회용 비밀번호를 생성하기 위해 여러 수학적 알고리즘을 사용하는데 그 중 하나이다.

  - *Hash Chain*

    - 초기 시드값을 해시 함수에 입력으로 제공하고 그 결과를 다음 비밀번호롤 사용한다. 시간이 지나면 일련의 비밀번호를 생성할 수 있다.

    - ```
      1 준비단계
      클라이언트는 비밀s를 생성한다.
      f(s), f(f(s))...와 같이 연속된 해시 값을 계산한다.
      클라이언트는 가장 마지막에 계산된 해시값 Fn(s)를 서버와 공유한다. 서버는 값을 저장한다.

      2 로그인 단계
      클라이언트는 Fn-1(s)를 계산하고 서버에게 제시한다.
      클라이언트만! s를 알고 있다. 서버는 Fn(s)에서 해당 값 계산이 불가능하다.
      서버는 제시된 Fn-1을 사용해 F(Fn-1)을 계산하고 저장된 Fn과 비교한다. 값이 일치하면 인증이 성공한 것이다!

      서버는 Fn-1을 저장하고 다음 로그인을 위해 클라이언트는 Fn-2를 제시한다.

      >>> 해시체인을 거꾸로 따라가면서 반복한다.
      ```

  ​

  - *Challenge-response* 

    - 서버가 사용자에게 도전을 제시하면 사용자는 응답으로 일회용 비밀번호를 생성한다.

    - ```
      클라이언트와 서버가 공유 비밀키 s를 가진다.
      클라이언트는 서버에 로그인을 시도한다.
      서버는 무작위 숫자 R을 클라이언트에게 제시한다.
      클라이언트는 H(R|s)를 계산하고 서버에 제시한다.
      서버는 H(R|s)를 다시 계산하고 값이 일치하면 로그인이 허용된다.
      ```

      - 무작위 도전값 R을 사용해 중간자 공격을 방지한다.



💌💌💌💌💌💌💌💌💌💌💌💌💌💌💌💌💌💌💌💌💌💌💌💌💌💌💌💌💌💌💌💌💌💌💌💌

## Security strength

- MD5 << 		SHA-1 < 		SHA-224/256/384/512