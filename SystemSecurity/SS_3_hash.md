# SS_3_hash

```
Cryptographic hash function
Birthday attack
Message Authentication Code
One Time Password
```

## 개요

메시지 m이 주어졌는데 길이를 모른다. 

여기에 암호학적 해쉬를 적용하면 매~우 빠르게 연산이 끝난다.

**또 해쉬처리한 암호화된 메시지 H(m)를 알고 있다고 해도 원본 m을 복원할 수 없어야 한다.**

**또 서로 다른 메시지 m1, m2가 있다면 해쉬처리한 두 결과는 달라야 한다.**

**또 m1과 m2가 같다면 암호처리한 두 결과는 같아야 한다.**



예시로 동영상이 10기가고 해쉬처리한 것이 h(v)라고 하자.

동영상에서 1비트만 달라진다면 해쉬처리하면 h(v')

이렇게 되면 h(v) != h(v') 완전히 달라져야 한다. 특정 영역 같은 것도 안된다.



## 해쉬 함수 장점

> 해쉬 함수 장점 : 무결성!!! HMAC...

이렇게 하면 얻을 수 있는 것이!

무결성 체크가 된다.! integrity

위처럼 10기가 동영상이 있다고 하면 무결성 체크하려면 10기가 비포랑 애프터 두 개를 첨부터 다 1비트씩 비교하면 시간 굉장히 걸린다. 데이터가 더 크면 거의 불가능할 수도

이 때 해쉬함수를 이용한다.



10기가 동영상을 들고 체크하는게 아니라 이거에 해당하는 256비트를 체크해서

원본의 무결성을 체크할 수 있게 된다.



예시로 메시지에 해당하는 h(m)을 내가 가지고 있다.

어떤 사람이 m'를 가져와서 m이랑 같다고 주장.

해시함수가 있으니 h(m')해서 결과를 비교하면 256비트 두 개의 비교

매우 빨라진다! 굿



## MD5의 한계

원래는 MD5가 해시함수 중 가장 대중적인 알고리즘이였는데 취약점이 발견됐다.

## 대칭키의 DES 기억하니

대칭키 구조의 DES구조, 대칭키에서 쓰는 해시 함수도 같다.

> DES는 64비트의 키를 56비트로 축소하고 입력 블록 비트를 섞는다. 순열 및 치환 작업. 암호화....등....

해시 함수도 원본 10기가가 주어진다면

처음에 몇 바이트를 뽑아와서 순서를 바꾸고 줄이고 반복해서

256비트로 만든다. 

십년 동안 이런 방식으로 쓰다가

h(m)으로부터 가운데 100비트 정도가 추측이 되더라. 어떡하지.

그래서 안쓰게 됐다. MD5가 가장 대표적



MD5는 원본 메시지 길이에 상관없이 128비트를 생성한다.

DES는 56비트다. 얘는 심지어 MD5보다 더 짧아서 더 위험하겠지...?



## 공개키 알고리즘은 취약한가? 어떤가?

공개키 알고리즘은 수학적인 소인수 분해가 큰 수는 어렵더라. 하는 부분으로 보안을 유지한다.

RSA가 공개키 알고리즘 중 대표적이다.



## SHA256

h( m)이 256비트로 표현된다. 

DES처럼 여러 라운드로 구성되고 각 라운드 지날 때마다 기존에서 몇 개를 가지고 와서 처리하는...그런. 패딩도 피요하다.

중요한건

>  원본 메시지가 어떤 길이로 들어오든지 간에 여러 라운드를 거쳐 동일한 길이의 비트 값으로 생성한다.

![bts](https://github.com/hhzzzk/studyLog/assets/67236054/dbe09a76-a619-46ee-915d-58564b2289f9)

## hash function - MD5, SHA256

메시지 digest function

- 임의의 길이의 메시지를 고정 길이의 출력으로 매핑하는 함수이다.
- digest는 해쉬와 비슷한 개념이다. 엄밀히 말하면 해시는 임의의 입력 데이터를 고정 길이의 출력 데이터로 매핑하는 알고리즘이다(해싱) 다이제스트는 해시 함수를 통해 생성된 고정된 길이의 출력 데이터를 가리킨다.

일방향 함수

- 암호화된 H(m)에서 m을 유추할 수 없다.

입력 변경에 대한 반응

- 입력 내용을 *한 개 비트만 변경해도 출력의 모든 비트가 50프로 확률로 변경*된다.
- 입력의 작은 변화가 출력에 큰 영향을 미친다.

충돌 저항성

- 메세지가 서로 다를 때 H(m1) != H(m2)  다이제스트는 달라야한다.



​	🍞**해시 함수의 종류**🍞

- MD5
  - message digest 5
  - 입력은 임의 비트 n개고 출력은 128비트이다. (원본 메시지를 고정 길이의 다이제스트로 매핑)
  - 그 밖에도 MD2, MD4가 있다. 보안 수준은 더 낮다.



- SHA-1
  - secure hash algorithm-1
  - 입력의 임의 비트 n개고 출력은 160비트이다.
  - SHA-256, SHA-384, SHA-512 등으로 발전해서 사용된다.



-  RIPEMD-160, Whirlpool 



​	🍞**해시함수의 단계**🍞

- 1단계 : 메시지 패딩
  - 입력 메시지를 특정 길이로 패딩해 *고정된 길이의 블록*으로 만든다.
  - 일반적으로 512비트의 *배수*로 메시지를 채운다. 이를 통해 메시지가 정확한 크기의 블록으로 나눠진다.
  - 16워드, 64옥텟은 16개의 워드로 구성된 데이터 블록과 64개의 바이트로 구성된 데이터 블록이다. 옥텟은 바이트라고도 한다.
- 2단계 : 메시지 처리
  - 패딩된 메시지는 512비트씩 블록으로 나눠진다. 각 블록은 해시 함수에 의해 처리되어 고정된 길이의 메시지 다이제스트를 생성한다. 


![🎐 (1)](https://github.com/hhzzzk/studyLog/assets/67236054/60176014-f120-4653-b6ab-c011f386974c)




## Birthday attack

생일 공격은 생일 역설 개념에 기반한 공격 기법이다. 생일 역설은 ''서로 다른 사람들 사이에서 두 사람의 생일 동일한 확률이 언제인가?'' 에 대한 개념이다.

- 생일 역설
  - 예상보다 더 적은 사람 수가 동일한 생일을 가지고 있다.
  - 두 명의 사람이 동일한 생일을 가질 확률은 365일 중의 하나이므로 0.27프로이다.
  - 그러나 사람 수가 증가함에 따라 중복생일이 발생할 확률은 급격히 증가한다.
- 생일 공격
  - 생일 역설을 활용해 해시 함수나 랜덤 생성 알고리즘의 충돌(두 개의 서로 다른 입력이 동일한 출력을 생성하는 상황)을 찾는데 사용된다.
  - 이러한 충돌은 해시 함수의 취약성을 나타낸다.
- 결론
  - 해시 충돌(두 개의 다른 입력이 같은 해시로 매핑되는 상황)이 예상보다 더 자주 발생한다. 
  - 64비트 암호는 메시지 다이제스트로 선택하기에 좋지 않다.
  - 해시 함수의 출력은 128비트로 커야 한다.


![🎐](https://github.com/hhzzzk/studyLog/assets/67236054/497710d2-c1d3-4b48-b412-236f8ef7c984)



## Integrity 확인 가능한 수단 3가지!!!!!!!!!

1. 대칭키 알고리즘의 CDC
2. 키드 해쉬함수, MAC, HMAC!!!
3. ~



## 키드 해쉬함수 - MAC 개요

앨리스와 밥. 밥이 메시지 m을 전달하려고 한다.

여기서는 기밀성은 관심 없음 즉 메시지를 중간에 해커가 봐도 별 관계 없다.

무결성에 엄청난 관심이 있다.

뉴스라고 한다면 브로드캐스트, 방송할 때 중간에 뉴스내용을 해커가 가로채서 수정해서 내보낸다. 이런 걸 방지하는데 관심

맥은 키드 해쉬함수로 구현한다.

## 절차

앨리스와 밥이 K키를 공유한다. Kab라고 하자. 해당 키는 앨리스와 밥만 안다!

1. 앨리스가 메시지 m와 Kab, 키도 256바이트므로 string을 합쳐서 해시 함수 처리해서 봰다.
   - 원본메시지 [  m과 H(m || Kab) ]를 앨리스가 밥에게 보낸다.
2. 밥은 이제 원본 메시지과 인증태그를 받았다. 공유키는 공유했으므로 안다.
   - 밥이 자기가 다시 계산. 계산한 값 인증태그가 같은지 확인해서 무결성 체크

## 추가

위는 기밀성은 없는데 기밀성까지 추가하려면 메시지를 그냥 보내지말고

키로 암호화해서 보내기하면 됨.

가장 많이 쓰고 좋은 방법은 MAC용으로 쓰는 Kab키 값과 (무결성 체크 용도)

AES 알고리즘(대칭키 암호화)을 위한 Kab (기밀성 용도)로 두 개의 키를 쓰는 게 좋다.



@

@

@


## MAC - Message Authentication Code

>  메세지 인증 코드. 메시지를 보낼 때 메시지와 함께 메시지의 무결성, 변조되지 않았음을 확인할 수 있는 추가적인 정보를 함께 보낸다.

전제 ; 공유 비밀키 Kab

1. 메시지와 키를 연결하고 거기에 해시 함수를 적용한 H(m || Kab)를 계산. 이게 인증태그!
2. 메시지와 인증태그를 함께 전송한다.
3. 받은 사람은 받은 메시지와 키를 연결해 마찬가지로 인증태그를 계산하여 값을 비교한다.
4. 값이 다르다면 메시지가 변조된 것이다.

---



- 메시지 인증
  - 메시지의 intergrity 무결성 보호 > 방송같은 경우 보안보다 내용 변조 여부가 중요
  - 송신자의 신원 확인
  - 송신자의 non-repudiation 부인 봉쇄
- 메시지 인증 코드 MAC
  - 어떤 메시지에 대한 고정 크기의 인증자
  - 메시지에 대한 인증 제공
  - 블록 암호 모드나 해시 함수 사용
- Keyed hash function
  - 메시지와 비밀키를 입력 받는다.
  - 메시지와 키를 이용해 안전한 해시 값을 생성한다. - 인증태그!
    - 키와 메시지의 결합으로 MAC가 생성되므로 메시지와 키가 모두 필요하다.
  - 초기에는 H(Key | m) 형태의 키와 메시지 결합이 제안되었으나 취약점이 있어 HMAC가 개발되었다.
  - 🍞*HMAC(해시 기반 메시지 인증 코드)*🍞
    - H(m | Key) 형태로 해시 함수와 키를 결합해 MAC를 생성한다.
    - MAC보다 안전한 해시 함수(SHA-256)를 사용한다.
    - 내부적으로 키를 확장하는 알고리즘을 사용해 보안성을 높인다.

💌💌💌💌💌💌💌💌💌💌💌💌💌💌💌💌💌💌💌💌💌💌💌💌💌💌💌💌💌💌💌💌💌💌💌💌

##  OTP - OneTimePassword 개요

은행가서 OTP하나 주세요 하면 작은 기계를 준다.

시리얼 번호도 있고 기계 안에는 키 값도 있다. 키를 Kab라고 하자.

그럼 이제 은행과 개인은 2개의 정보를 공유했다.

원타임 패스워드 방식은 여러 가지가 있는데 먼저

## OTR1 - Time-synchronized

타임 싱크로 방식은 OTP 기계 안에 작은 시계가 있어서 시간 정보까지 애가 출력할 수 있다.

앨리스가 밥(은행)에게 가서 아이디 패스워드로 먼저 로그인.

그리고 이제 계좌이체를 하겠다하면



은행 "OTP 번호를 입력하세요"하는데 기계 버튼 누르면 6자리 숫자 생김

이 여섯자리 숫자는 시리얼 번호와 키값을 concat해서 해시함수 처리해서 나온다.



타임 싱크로 방식에서는 여기에 현재 시간 정보도 concat을 해서 해시 처리한다. h(K | SN | time)

그럼 이렇게 은행에서는 해시처리해서 나온 6자리 숫자를 받았다.



**인증하기**

아까 앨리스가 아이디 패스워드로 로그인했으니 앨리스임이 인증됐다.

은행의 OTP 서버에는 위의 키값과 시리얼 번호와 현재 시간 정보가 다 있다.

은행도 은행의 정보들을 이용해 해시함수 계산을 자기가 해본다.

그래서 결과가 같으면 인증이 성공했다.



## Replay attack

아이디 패스워드로 로그인할 때 너무 오랜시간 입력하지 않으면 세션이 expire, 세션이 만료된다.

이런 시간이 너무 길어지면 공격자들이 있을 수 있다.

---

나머지 담시간~

원타임패드 타임싱크로 말고도 있당~

![323](https://github.com/hhzzzk/studyLog/assets/67236054/517dc55f-e7a4-4de1-869f-5deafe92dbb8)

담시간 왔다

전시간 요약

원타임 패스워드의 3가지 종류 있다. 첫번째 타임 싱크로 방식.

기본적으로 공유 비밀키라는 건 대칭키에서만 나오는 거 아니다.

해시 함수 운영할 때도 클라와 서버가 둘만 알고 있는 대칭키값 존재한다!

## OTP2 - Challenge response

챌린지는 이제 너에 대해 증명해라 하면 리스펀스, 그에 대한 응답으로 내가 니가 찾던 사람 맞다 증명하는 절차이다.

앨리스와 밥, 그리고 인터넷 뱅킹의 예시를 또 쓰자.

타임 싱크로에서 앨리스와 밥 Kab라고 하는 비밀키를 공유하고 있다고 가정하자.

1. 앨리스가 로그인을 시도한다.
2. 밥이 그럼 너가 앨리스인지 증명해라라고 챌린지를 하기 위해 랜덤 넘버 R을 생성해 앨리스에게 보낸다.
   - 이 랜덤넘버 R은 해킹당해도 상관없다.
3. 앨리스는 해시 함수 계산을 한다. h( R|Kab ) 이 값을 밥에게 보낸다. = 리스펀스
4. 밥은 R도 알고 비밀키도 알고 있으니 밥도 해시를 또 계산해서 값을 비교한다.

포인트

- 타임 싱크로랑 거의 유사한데 랜덤 넘버 R의 역할을 타임 싱크로에서는 시간이 했다.

## 부인 봉쇄

부인 봉쇄를 구현하는 완벽한 방법은 공개키 암호화 알고리즘을 사용하는 것이다.

공개키 암호화 알고리즘에서 앨리스가 자신의 개인키로 메시지에 서명을 하면 부인 봉쇄가 된다!

​	앨리스의 개인키는 앨리스만 알고 있기 때문에

## 다시 OTP 챌린지 리스펀스

위의 랜덤넘버 R에 대해, 메시지 M이라고 쳐도 된다. 

일단 기밀성은 관심이 없고 해시가 부인 봉쇄를 제공할 수 있을까?

결론만 하면 안된다. 



R에 대해 h( R |Kab )를 생성할 수 있는 사람이 세상에 앨리스 뿐이라면 부인 봉쇄가 구현된 것이다.

그러나 밥도 만들 수 있기 때문에 부인 봉쇄가 안된다.



## OTP3 - Hash chain

앨리스 밥은 똑같다. Kab를 앨리스와 밥이 공유했다.

그런데 해시함수로 h( R |Kab ) 를 만들 수 있는게 앨리스와 밥 2명 다 가능한 문제

그걸 해결하자

이전의 Kab는 앨리스와 밥이 공유한! 키였다.



해시체인에서는 시크릿키 S가 존재. 해당 키는 공유되지 않았다. 랜덤넘버 한 256비트나 512라고 보면 된다.

1. 앨리스가 S를 생성. 해시 함수 처리 h(S)

![image](https://github.com/hhzzzk/studyLog/assets/67236054/94f74e05-5966-4d96-9d71-dd9f82aa6122)

그렇게 처리한 거에 또 해시 함수 처리를 적용하고 적용하고 반복한다. Hn(S), n번 해시 함수처리

​	이렇게 캐시함수를 많이 적용한 값을 밥에게 알려준다. == 등록단계

2. 앨리스가 나 접속 좀 하자라고 하면서 아이디가 앨리스라고 알려준다. 그럼 밥은 패스워드를 대라고 한다. 그럼 앨리스는 n-1번 해시함수 처리한 S값을 계산해서 알려준다.! == Hn-1(S)

3. 밥은 받은 n-1번 해시함수 처리한 값에 해시를 한 번 더해서 Hn(S)를 계산한다.

   그리고 등록할 때 받은 값과 비교한다. 같으면 인증 성공이다



## 이게 가능한 이유?

해시함수의 전제. m에 해시함수를 적용한 h(m)은 쉽게 된다.

그러나 h(m)에서 m을 얻는 것은 불가능하다!

해시 함수가 일방향성 one wayness?의 특징을 가진 것을 이용한 것!



어떤 값에 해시함수 처리하는 것은 쉬우나

해시함수 처리한 값에서 해시함수 이전 값 얻기 불가능 == *Hn-1차는 앨리스만 알 수 있다!!!*



## 해시체인 이어서 후속 절차

밥은 앨리스임을 확인했다. 인증 성공

4. 밥은 이제 DB를 업데이트한다. 앨리스가 다음에 인증할 때는 Hn-1(S)로 인증해야 한다.
5. 그 다음번은 Hn-2로 인증한다. 반복



## 해시체인의 한계

결국 n번밖에 못 쓴다.

해결법?

어느 수준까지 내려가면 재등록하는 절차를 만든다.





@

@

@

## One Time Password

>  일회용 비밀번호는 각 로그인 시마다 새로운 비밀번호를 사용하는 보안 기술이다. 생성하는데 해시 함수를 사용할 수 있다.

- *Challenge-response* 
  - 서버가 사용자에게 도전을 제시하면 사용자는 응답으로 일회용 비밀번호를 생성한다.

  - ```
    클라이언트와 서버가 공유 비밀키 s를 가진다.
    클라이언트는 서버에 로그인을 시도한다.
    서버는 무작위 숫자 R을 클라이언트에게 제시한다.
    클라이언트는 H(R|s)를 계산하고 서버에 제시한다.
    서버는 H(R|s)를 다시 계산하고 값이 일치하면 로그인이 허용된다.
    ```

    - 무작위 도전값 R을 사용해 중간자 공격을 방지한다.


- *Hash Chain*

  - 초기 시드값을 해시 함수에 입력으로 제공하고 그 결과를 다음 비밀번호롤 사용한다. 시간이 지나면 일련의 비밀번호를 생성할 수 있다.

  - ```
    1 준비단계
    클라이언트는 비밀s를 생성한다.
    f(s), f(f(s))...와 같이 연속된 해시 값을 계산한다.
    클라이언트는 가장 마지막에 계산된 해시값 Fn(s)를 서버와 공유한다. 서버는 값을 저장한다.

    2 로그인 단계
    클라이언트는 Fn-1(s)를 계산하고 서버에게 제시한다.
    클라이언트만! s를 알고 있다. 서버는 Fn(s)에서 해당 값 계산이 불가능하다.
    서버는 제시된 Fn-1을 사용해 F(Fn-1)을 계산하고 저장된 Fn과 비교한다. 값이 일치하면 인증이 성공한 것이다!

    서버는 Fn-1을 저장하고 다음 로그인을 위해 클라이언트는 Fn-2를 제시한다.

    >>> 해시체인을 거꾸로 따라가면서 반복한다.
    ```




## Security strength

- MD5 << 		SHA-1 < 		SHA-224/256/384/512

MD5 쓰지마라~

