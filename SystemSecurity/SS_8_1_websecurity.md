# SS_8_1_websecurity

쿠키전까지 todo

start

14w1_12.5화 ~ 웹2에서 18p전까지함 sql인젝션 좀 하다가

## Cookie

- 쿠키는 사용자의 웹 브라우저에 저장된 텍스트 조작이다.
- 웹서버와 브라우저 간의 상호작용에서 정보를 유지하고 전달하는데 사용된다.
- *기본적으로 stateless인 http 트랜잭션에 상태state를 도입하는 역할을 한다!*
  - state는 이전 이벤트의 기억!
  - 쿠키가 없으면 각 웹페이지에서의 모든 상호작용이 이어지지 않는다.

![image](https://github.com/hhzzzk/studyLog/assets/67236054/f1d083bf-cd3b-4573-92e7-2510d514ddd6)

- 클라이언트가 웹페이지에 요청을 보내면 웹서버는 응답으로 html문서와 함께  http 헤더를 전송한다.
  - 이 헤더에 여러 정보가 있는데 쿠키도 있다.
- 브라우저, 클라이언트는 쿠키를 저장하고 이후의 요청에서는 해당 쿠키를 함께 서버에 전송한다.

---



![image](https://github.com/hhzzzk/studyLog/assets/67236054/44c5b81d-130b-4de0-bbc4-2f9fb556f8d6)

- 쿠키는 일반적으로 key-value 쌍으로 이루어져 있다. 이 페어는 사용자의 브라우저에 저장된다.
- 각 쿠키는 도메인과 경로에 바인딩되어 있으며 설정된 만료 날짜나 세션 종료시 삭제될 수 있다.
- 쿠키에 포함되는 정보
  - Name, value, domain, path, expire 등의 내용이 포함된다.

## Cookie : 예제

쿠키는 (name, domain, path)로 식별된다.

쿠키는 브라우저의 "cookie.jar"에 저장된다.

![image](https://github.com/hhzzzk/studyLog/assets/67236054/fa104ae0-6768-45ac-900b-b86c84f92167)

예제는 이름과 경로가 같지만 도메인이 다르므로 서로 다른 쿠키다.



## Cookie : 문제

1. SSL로 보호되지 않으면 공격자는 쿠키를 읽고 조작할 수 있다.
   - 실제로 성능 등의 이유로 많은 사이트에서 모든 파일에 SSL을 적용하지 않는다.
2. 서버는 클라이언트의 브라우저에 저장된 쿠키를 확인할 수 있지만 쿠키의 세부 속성은 볼 수 없다.
   - 서버는 오직 “cookie name=value”만 확인할 수 있다.
3. 클라이언트는 쿠키를 조작할 수 있다.
   - 그러므로 중요한 정보는 쿠키에 저장하면 안된다. 위험

## Cookie : 공격 사례

@로그인 서버 문제

Alice는 login.site.com에서 로그인합니다.
login.site.com은 .site.com에 대한 세션 ID 쿠키를 설정합니다.
Alice는 evil.site.com을 방문합니다.
evil.site.com은 .site.com의 세션 ID 쿠키를 사용자 "badguy"의 세션 ID로 덮어씁니다.
Alice는 숙제를 제출하기 위해 cs142hw.site.com을 방문합니다.
cs142hw.site.com은 자신이 "badguy"와 통신하고 있다고 착각합니다.

@클라이언트는 임의로 쿠키를 조작할 수 있으므로 쇼핑사이트에서 가격을 변경해 문제 생긴 사례 존재



## Cookie : Countermeasure 대책

안전한 쿠키를 만들쟈

1. 브라우징 후에는 쿠키 설정/쓰기 및 삭제를 차단한다.

2. 모든 페이지에 SSL 사용하기

   - TLS, SSL 쓰면 중간자 공격 방지 및 기밀성 보호에 효과적이다.

3. Cryptographic checksum : integrity💖💖💖

   - 서버키 K를 사용한 암호화 체크섬을 도입!! 

   ![image](https://github.com/hhzzzk/studyLog/assets/67236054/d66df25d-2f13-4bb1-b587-83e1eab9b794)

   중요!!!!

   서버에서 새성한 비밀키 k와 value를 concat하고 F라는 해시함수를 씌워서 T를 만든다!

   T를 value값에 합쳐서 같이 보냄



## Session Management

세션 관리는 웹 개발자가 stateless인 http 프로토콜에서 session state를 지원하기 위해 사용하는 기술이다.

- http는 stateless이다. 
- 사용자가 웹서버에 자신을 인증하면 이후 요청에서는 계정과 비밀번호를 재요청하면 안된다. == 로그인하면 유지되어야 함
- 세션 정보는 세션 식별자 SID(세션 ID)를 사용해 웹서버에 저장된다.
  - 세션 데이터(사용자 이름, 계정 번호 등)의 저장은 다양한 기술로 웹서버에서 수행된다.



## Session Management : Session tokens

![image](https://github.com/hhzzzk/studyLog/assets/67236054/45a4496c-1624-452e-8191-31ff34633de3)

이부분 했나? 나중에 다시보셈



세션 토큰은 웹세션이나 사용자 세션을 식별하는데 사용되는 고유한 식별자이다.

세션 토큰은 클라이언트와 서버 간의 통신에서 세션 상태를 유지하고 관리하는데 중요한 역할을 한다.





##  Session tokens - Problems

Referer 헤더를 통한 토큰 누출

- 레퍼러 헤더가 url에 세션 토큰을 포함하고 있다면 해당 url이 제3자에게 누출될 가능성이 있다.
  - 보안 강화하는 기능도 있다

![image](https://github.com/hhzzzk/studyLog/assets/67236054/8f67cc4c-e1a9-491f-bbd9-a60e4a196c48)



## Session hijacking

- 세션 하이재킹은 공격자가 사용자의 로그인을 기다린 후, 사용자의 세션 토큰을 획득하고 세션을 "하이재킹"하는 공격이다.
- Predictable tokens, cookie theft, sessionfixation attacks가 있다.



**Predictable tokens :** 예시 verizon wireless used counter - 사용자가 로그인하면 카운터 값이 제공되고 이를 통해 다른 사용자의 세션을 볼 수 있다.

**cookie theft :** 쿠키 도난은 사용자의 쿠키 정보가 누출되는 것이다. 공격자가 사용자의 쿠키를 훔쳐 해당 사용자의 세션에 접근할 수 있다. 대표적으로 XSS

- cross site scripting은 공격자가 웹페이지에 악의적인 스크립트를 삽입해 사용자 브라우저에서 실행되게 하는 공격이다. 이를 통해 공격자는 세션 쿠키를 훔치거나 다른 사용자의 세션을 조작한다. 나중에 더 함



![🎐 (1)](https://github.com/hhzzzk/studyLog/assets/67236054/3a965f38-b623-48a8-9ede-37e07b876c0d)



**sessionfixation attacks :** 공격자가 사용자의 세션 토큰을 설정할 수 있다고 가정한다.

- url 토큰일 경우 사용자를 url에 클릭하도록 속일 수 있다.
- 쿠키 토큰일 경우 xss 공격을 통해 설정할 수 있다. 나중에 더 함

*URL 토큰의 공격과정*

1. **공격자가 site.com의 익명 세션 토큰을 획득**
2. **URL 토큰을 사용한 속임수:**
   - 공격자는 사용자에게 자신의 세션 토큰이 포함된 URL을 전송합니다.
3. **사용자가 URL을 클릭하고 site.com에 로그인:**
   - 사용자가 URL을 클릭하면, site.com에 로그인합니다. 이로 인해 사용자는 attacker의 토큰을 현재 로그인된 토큰으로 업그레이드시킵니다.
4. **공격자가 상승된 토큰을 사용하여 세션 탈취:**
   - 이제 공격자는 사용자의 상승된 토큰을 사용하여 사용자의 세션을 탈취할 수 있습니다.

*Countermeasure 대책*

1. 사용자를 익명에서 로그인 상태로 업그레이드할 때 항상 새로운 세션 토큰을 발근한다.

   - 사용자가 로그인하면 토큰이 공격자에게 알려지지 않는 새로운 값으로 변경된다. 이로써 공격자의 토큰은 업그레이드되지 않는다.

2. 강력한 세션 토큰

   ![image](https://github.com/hhzzzk/studyLog/assets/67236054/15177ae3-2b53-40b5-b579-20a083527878)

   SessionToken = HMAC ( K, SID )

   - 세션토큰은 SID를 HMAC 함수를 사용해 K키로 서명한 것이다. 이를 통해 토큰의 무결성이 보장된다.


   - K는 웹서버에서 생성한 비밀키이다. 더 강력한 SID, 세션 아이디를 위해 여러 데이터를 SID에 포함한다. 클클라이언트의 ip주소 등...



## XSS : Cross-site scripting

XSS는 악의적인 스크립트를 웹페이지에 삽입해 사용자의 브라우저에서 실행되도록 하는 공격이다.

정식이름

CWE-79 Improper Neutralization of Input During Web Page Generation : 웹페이지 생성 중의 입력 무력화 부적절

== 즉 웹페이지를 생성할 때 사용자로부터 입력받은 데이터를 제대로 처리하지 않음

== 보안 조치가 제대로 이루어지지 않음. 나쁜 공격이견 무력해야 하는데 그러지 않음. 반대 경우도 가능



- XSS는 code injection의 유형이다.
  - 코드 인젝션은 악의적인 코드를 주입해 실행시키는 공격
  - SQL인젝션도 코드 인젝션임





## XSS : 유형

1. Persistent XSS (or stored XSS)
2. Non-persistent XSS (or reflected XSS)



## Persistent XSS(stored XSS)

사용자 입력을 필터링 없이 표시하면 XSS를 발생시킬 수 있다.

공격자가 악의적인 스크립트를 서버에 저장시키고 다른 사용자가 이를 조회할 때 실행되는 공격 유형이다. 공격이서버에 persistent하게 저장되어 persistent xss이다.

![image](https://github.com/hhzzzk/studyLog/assets/67236054/fc10ae54-a2b3-4134-bc51-4c3a43d0a5a9)

1. 공격자가 악의적인 코드가 있는 게시물을 서버에게 전송
   - 해당 게시물에는 사용자들이 클릭하거나 열면 실행되는 악성코드가 포함되어 있다.
2. 서버는 악의적인 코드가 있는 게시물을 저장한다.
3. 서버가 클라이언트에게 해당 게시물 내용을 보내 클라이언트가 게시물을 읽는다.
   - 다른 사용자가 해당 게시물을 열거나 조회하면 서버는 내용을 전달한다.
   - 이 때 악의적인 코드가 클라이언트 측에서 실행된다. 이로써 XSS 공격이 발생!
4. 클라이언트가 쿠키값을 공격자에게 전송
   - XSS 공격을 통해 악성 코드가 실행되면 공격자는 이를 이용해 클라이언트의 쿠키 정보를 탈취하거나 조작할 수 있다.



## Non-persistent XSS (reflected XSS)

사용자의 입력이 즉시 서버에 저장되지 않고 해당 입력이 웹페이지 반사되어 실행되는 상황이다.

예시로 검색 엔진이나 입력폼 등이 있다.

웹사이트의 검색 엔진을 예시로 들면 사용자가 검색을 수행하면 검색어가 결과 페이지에 그대로 표시되어 어떤 내용을 검색했는지 나타낸다. 그러나 이 응답이 HTML 제어 문자를 적절하게 처리하지 않으면 악의적인 스크립트가 검색어에 포함될 경우 XXS 취약점이 발생할 수 있다.



예제

1. 앨리스는 밥이 호스팅하는 특정 웹사이트를 자주 방문한다. 밥의 사이트는 앨리스가 사용자 이름/상호 쌍으로 로그인하고 민감한 데이터 저장한다.
2. 멜러리는밥의 웹사이트에 반사된 XSS 취약점 있음을 발견
3. 멜러리는 취약점을 악용할 수 있는 URL 작성, 앨리스에게 해당 URL 클릭하도록 유도하는 이메일을 보낸다.
   - 해당 url은 밥의 웹사이트를 가리키지만 멜러리의 악성 코드가 포함된 url로 웹사이트가 반사된다.
4. 앨리스는 밥의 웹사이트에 로그인한 상태에서 멜러리가 제공한 url 방문한다. 
   - url에 포함된 악성 스크립트가 앨리스의 브라우저에서 실행, 마치 그것이 밥의 서버에 직접 온 것처럼 작동한다. 악성 스크립트는 앨리스의 세션 쿠키를 멜러리에게 보낼 수 있다.
5. 멜러리는 세션 쿠키를 사용해 앨리스의 정보를 훔치고 악용할 수 있다.



## XSS의 대책 Countermeasure

**HTML sanitization**

- html 산화는 사용자 입력에서 잠재적으로 악성인 html 코드나 스크립트를 제거하거나 무력화하는 과정이다.
- 이를 통해 xss 공격을 방지할 수 있다.

1. 입력 필드에서 불필요한 문자의 유효성을 검사하고 거부
2. substitution 치환
   - 특정 문자나 코드를 안전한 값으로 대체한다.
     - 잠재적인 악성 문자나 코드를 대체시킨다.



**스크립트 비활성화**

- 웹페이지에서 스크립트 실행을 비활성화시킨다.

```


38p
예시로 사이트에 네이버 카페 이런 곳에 글쓸때 예쁘게 꾸미기?
이런 것도 사용자 컨트롤러 input임
alert도 컨트롤러

쿠키를 다른 사이트로 날리는 컨트롤러가 해커가하는

```





