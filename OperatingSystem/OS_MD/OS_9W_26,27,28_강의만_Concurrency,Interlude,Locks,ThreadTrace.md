[TOC]

# OS_9W_26,27,28_Concurrency,Interlude,Locks,ThreadTrace

https://www.youtube.com/watch?v=d2xRtWJ8U-Y&list=PLGgVuvaPty_13HJiJU6nhMMTDfB0thX0t

한글교재 348페이지

# 26 Concurrency - Intro(1/5)

강의

![image](https://github.com/hhzzzk/capstone-2023-20/assets/67236054/4ab44c42-fbd5-411a-bcbe-eeba5d211e98)



여러개의 실행흐름

address space가 있고 오픈파일 디스크립터 존재, io 처리

프로그램을 실행하면 스택에 흔적이 남음, 익스큐션 스택

프로그램 실행흐름은 스택과 관련

여러개의 실행흐름은 여러개의 스택 필요

각 쓰레드별로 스택 존재

문맥교환도 쓰레드에서 일어남

쓰레드에도 필요한 공간들 있다.







# 26 Concurrency - Intro(2) (2/5)





# 26 Concurrency - Race Condition (3/5)



# 26 Concurrency - Multi Processing(4/5)



# 26 Concurrency - Multi Threading (5/5)







# 28 Locks_book summery

376페이지

지금까지 한 것

- 병행성
- 병행 프로그램의 문제들
- 여러 개의 명령어들을 원자적으로 실행해보고 싶지만 단일 프로세서의 인터럽트, 또는 멀티 쓰레드를 여러 프로세서에 병행성하려고 해서 그렇게 할 수 없었음
- 여기서는 락을 이용해 이 문제를 직접적으로 해결해보자
- 프로그래머들은 소스 코드의 임계 영역을 락으로 둘러서 그 임계 영역이 마치 하나의 원자 단위 명령어인 것처럼 실행되도록 한다.

```markdown
# 28.1 락 : 기본 개념
- 락은 일종의 변수임
- 락을 사용하기 위해서는 락 변수를 먼저 선언해야 함
- 락 변수는 락의 상태 나타냄
- 락의 사용 가능 available 상태(unlocked/free) 또는 사용 중 acquired 상태 둘 중 하나의 상태 가짐
- 사용 가능 상태는 어떤 쓰레드도 락을 가지고 있지 않음
- 사용 중 상태는 임계 영역에서 정확히 하나의 쓰레드가 락을 획득한 상태임
      (이 락 자료 구조에 락을 보유한 쓰레드에 대한 정보나 
      락을 대기하는 쓰레드들에 대한 정보를 저장할 수도 있다.
      물론, 락 사용자는 이러한 정보를 알 수 없다.)
      
# lock()
락 획득을 시도함
- 만약 어떤 쓰레드도 락을 가지고 있지 않으면 그 쓰레드는 락을 획득하여 임계영역으로 진입
- 이렇게 락을 획득한 쓰레드를 락 소유자 owner라고 함
- 락이 사용 중인 동안에서 lock() 함수는 리턴하지 않는다.
- 락을 소유한 쓰레드가 임계 영역에 존재하는 상태에서는 다른 쓰레드들이 임계 영역으로 진입할 수 없음

# unlock()
락 소유자가 unlock()을 호출하면 락은 다시 사용가능한 상태가 됨
- 어떤 쓰레드도 락을 대기하고 있지 않았다면 == 어떤 쓰레드도 lock()을 호출해 멈춰있던 상태가 아니라면
	락의 상태는 사용 가능으로 유지됨
- 대기 중인 쓰레드가 있었다면(락호출해 멈춰있던 쓰레드가 있었다면)
	락의 상태가 변경되었다는 것을 인지하고 락을 획득해 임계 영역으로 지입함
	
>>>
락은 프로그래머에게 스케줄링에 대한 최소한의 제어권을 제공함
일반적으로 쓰레드는 프로그래머가 생성하고 운영체제가 제어함
락은 쓰레드에 대한 제어권을 일부 받을 수 있게 해줌
락으로 코드를 감싸서 프로그래머는 그 코드 내에서는 하나의 쓰레드만 동작하도록 보장 가능

```



```markdown
# 28.2 Pthread Lock
쓰레드 간에 상호 배체 mutual exclusion 기능을 제공하기 때문에 POSIX 라이브러리는 락을 mutex라고 함

상호배제는 한 쓰레드가 임계 영역 내에 있다면
이 쓰레드의 동작이 끝날 때까지 다른 쓰레드가 임계 영역에 들어올 수 없도록 제한한다는 의미
- 래퍼를 사용해 락과 언락 시에 에러를 확인함

- 락/언락 함수에 락의 변수명을 인자로 전달함
	다른 변수를 보호하기 위해 다른 락을 사용할 수도 있기 때문임
__coarse-grained 락 사용 전략__은 하나의 락으로 모든 임계 영역들을 보호
__fine-grained 락 사용 전략__은 다수의 쓰레드가 서로 다른 락으로 보호된 코드를 실행가능

# 28.3 락의 구현
어떤 하드웨어와 운영체제의 도움을 받아서 구현할까?

# 28.4 락의 평가
락의 정상동작 여부 판단을 위한 평가기준 3가지
__상호 배제를 제대로 지원하는가__,
__공정성__, 쓰레드들이 락 획득에 대한 공정한 기회가 주어지는가, 
	락을 전혀 얻지 못하는 starve 굶는 상황 발생하는가?
__성능__, 락 사용 시간적 오버헤드를 평가
	1. 경쟁이 전혀 없는 경우의 성능 >>> 하나의 쓰레드가 실행 중 락을 획득/해제하는 과정의 성능
	2. 여러 쓰레드가 단일 cpu상에서 락을 획득하려고 경쟁할 때의 성능
	3. 멀티 cpu 상황에서 락 경쟁 시의 성능
	
# 28.5 인터럽트 제어
단일 프로세스 시스템에서는 상호배제 지원을 위해 
임계 영역 내에서는 아예 인터럽트를 비활성화 하는 방법 사용함


__임계 영역 진입 전에 하드웨어 명령어를 사용해 인터럽트 비활성화하는 방법__
> 임계 영역 내의 명령어 원자적으로 실행 가능해짐
> 모든 동작 후 다시 하드웨어 명령어를 통해 인터럽트 활성화해서 정상화
## 장점
단순함
인터럽트가 발생하지 않으면 코드 실행 중에 다른 쓰레드가 중간에 끼어들지 않는것 보장가능함
## 단점
1. 인터럽트 비활성화 요청은 privileged 특권 명령이라 요청한 쓰레드에게 허가를 해줘야함
	허가를 해줘야해서 특권 명령을 다른 목적으로 사용하지 않음을 신뢰가능해야 함
	__greedy 프로그램 예시__
	탐욕기법 사용한 프로그램이 시작과 동시에 락을 호출해 프로세서를 독점해 사용가능
	더해서 악의적인 프로그램이 락을 호출하고 무한 반복문에 들어가면
	운영체제는 시스템의 제어권을 다시 얻을 수가 없음
	>>> 응용 프로그램을 매우 신뢰해야 한다는 문제!!!
	
2. 멀티프로세서에서는 적용 불가능
	여러 쓰레드가 여러 cpu에서 실행 중이면
	각 쓰레드가 동일한 임계 영역을 진입하려고 시도할 수 있음
	이 때 특정 프로세서에서의 인터럽트 비활성화는 
	다른 프로세서에서 실행 중인 프로그램에 영향 없음
	>>> 즉 임계영역에 진입가능함

3. 중요한 인터럽트의 시점을 놓칠 수 있음
4. 비효율적임, 인터럽트 비활성화시키는 코드들은 느리게 실행되는 편

>>>
상호 배제를 위해 인터럽트 비활성화하는 방법은 제한된 범위에서만 사용되어야 함
예시
	운영체제 내부에서는 신뢰라는 문제가 사라지기 때문에
	용인 가능함

```



```markdown
# 28.6 락 구현 : 실패한 시도 오직 LD/ST 명령어만 사용하기
락을 구현하는데 인터럽트 비활성화는 별로고
락 구현의 기본 아이디어를 파악하고 LD, ST 명령어만으로는 락의 구현이 불가능한 이유 알기
```

![image](https://user-images.githubusercontent.com/67236054/235367415-0646d38b-a5fe-4dbc-a071-e744cae4a802.png)

```markdown
기본 아이디어는 간단한 변수 flag를 사용해 쓰레드가 락을 획득하였는가 표시

- 임계 영역에 진입하는 첫 스레드가 락()을 호출해 플래그 값을 검사
- 플래그 값을 1로 설정해 이 쓰레드가 락을 보유 hold하고 있다고 표시
- 임계 영역에서 나오면 쓰레드가 언락()을 호출해 플래그 값 초기화, 더이상 락 미보유 표시

__만약 쓰레드1이 임계 영역 내에 있을 때 다른 쓰레드가 락()호출하면__
그 쓰레드는 while문으로 spin-wait하며 처음 쓰레드가 언락()호출해 플래그 초기화를 기다림
쓰레드1이 플래그 초기화하면 대기하던 쓰레드는 while문 빠져나와 플래그 1로 설정하고 임계영역 진입

# 이 코드의 2가지 문제
1. 제대로 작동하는가? correctness
2. 성능

1 > 인터럽트 때문에 두 쓰레드 모두 플래그 1로 설정하는 경우 발생 가능, 그럼 임계 영역에 두 쓰레드 전부 진입 가능
상호 배제 제공 실패!!! 작동 실패
2 > 사용 중인 락을 대기하는 방법에 문제 있음
spin-wait 방법은 다른 쓰레드가 락을 해제할 때까지 시간 낭비, 단일 프로세서에서는 엄청난 손해!
문맥교환전까지는 락을 소유한 쓰레드조차 실행할 수 없음
```

![image](https://user-images.githubusercontent.com/67236054/235367667-68ab236e-3f6b-42a1-9977-f532047dad33.png)





```markdown
# 28.7 스핀 락 구현 : test and set 사용
인터럽트 비활성화 방법 > 실패
LD,ST 사용법 > 실패

하드웨어를 이용한 가장 기본적인 방법
__test-and-set 명령어 또는 원자적 교체 atomic exchane 명령어 이용!__

- ptr이 가리키던 예전 값을 반환하고 동시에 new에 새로운 값 저장함
- 중요한건 __해당 동작들이 원자적으로 수행됨__!

```

![image](https://user-images.githubusercontent.com/67236054/235367932-68f8d7bd-4e5e-4ceb-ade9-796d3194f9ec.png)



![image](https://user-images.githubusercontent.com/67236054/235368015-616bac02-24f9-45b3-9e08-164ed9e04c39.png)

```markdown
처음 쓰레드가 락()호출하고 다른 어떤 쓰레드도 현재 락 미보유 상태임, 현재 플래그 0
이 쓰레드가 TestAndSet(flag,1) 호출하면 flag의 이전값인 0을 반환함
flag값을 검사한 쓰레드는 while 문에서 회전하지 않고 락을 획득
이 쓰레드는 flag 값을 1로 설정해 락 보유르 표시함
임계 영역 동작 끝나면 언락() 호출해 flag = 0 변경

# 다른 경우
처음 쓰레드가 락을 획득해 flag가 1인 상태
두번째 쓰레드가 락() 호출해 테스트엔셋 루틴 실행
루틴은 0을 반환! 플래그 값 검사한 쓰레드는 while 문에서 회전하지 않고 락을 획득
이번에는 테스트~()는 이미 락을 다른 쓰레드가 보유하고 있기 때문에
예전값으로 1을 반환하는 동시에 flag 값을 다시 1로 설정함

락을 보유하고 있는 쓰레드가 있는 한 테스트는 계속 1을 반환
두번째 쓰레드는 락이 해제될 때까지 계속 while문 반복
락 보유 중인 쓰레드로 플래그 0이 되면 
대기 중인 두번째 쓰레드가 테스트 호출해서 0받고 원자적으로 값 1로 변경
락 획득! 임계 영역 진입

>>>
락의 값을 검사하고 새로운 값으로 설정하는 동작을 원자적 연산으로 만들어서
락을 구현, 하나의 쓰레드가 락을 획득 가능함! 정상 작동하는 상호 배체 함수!

락을 획득할 때까지 cpu 사이클을 소모하면서 회전함
단일 프로세서에서 이 방식 사용하려면 preemptive 선점형 스케줄러 사용함
선점형은 필요에 따라 다른 쓰레드가 실행되도록 타이머를 통해 쓰레드에 인터럽트 발생시키기 가능
선점형이 아니면 단일 cpu에서 스핀 락의 사용은 불가능
	while문을 회전하며 대기하는 쓰레드가 cpu를 무한독점하기 때문임
	
	
```



# 28 Locks(1/7)

https://www.youtube.com/watch?v=Y4eIgqKTtZs&list=PLGgVuvaPty_2VXqqnH2s7ov8OfYP9RC59

하나의 명령어가 코드상으로 3줄인데 add까지 하고 st하기 전에 인터럽트 걸리면서 기대한 효과 안나옴

결국 atomic하게 할 필요 있음

그래서 사용하는게 lock임

임계영역 진입할때 한 쓰레드가 락을 걸면 다른 쓰레드는 그 영역 진입 불가능하고 기다림

언락되면 기다리던 쓰레드가 임계영역 진입가능해짐



critical section이 임계영역

래퍼를 만들어서 락, 언락할 때 에러처리함, 예제 프로그램에선는 생략

---

```
28.4 락 평가
```

상호배제, mutual exclusion한가

deadlock 걸리면 안됨, 락을 잘못 만든거임, 최소한 하나의 쓰레드는 진행이 되어야함

starvation-free, 어떤 쓰레드는 계속해서 굶는 경우는 없어야 함

락 평가의 5가지 기준

![image](https://user-images.githubusercontent.com/67236054/235421739-9c797458-daa2-455c-af8e-aff76265db4c.png)

---

```
28.5__ Controlling Interrupts__
```

락을 건다는게 인터럽트를 끈다는 것이고 언락은 인터럽트를 킨다는 의미

상호배제는 성공, 원하던 결과 얻음

![image](https://user-images.githubusercontent.com/67236054/235422069-67402aa2-0bdb-404a-aaf0-1c079886dd1f.png)

cpu를 너무 많이 써서 time out 걸고 싶은데 이 방법에서는 그럴 수가 없음

타임아웃이 중요함, 타임아웃도 걸 수가 없다

((__타임아웃__되면 run에서 레디로 변함))

락과 언락은 라이브러리에 있음 링킹이 돼서 코드에 들어있긴 함

언락이 되면 타임아웃 걸릴 수 있어서 for문 끝나는 곳(언락 다음)에서 타임아웃 걸릴 수 있음



__단점__

- __특권 명령__이라 privileged 명령이라 기본적으로 커널에서만 사용가능한 건데 유저프로그램에서 사용가능하게 하려면 신뢰가능해야 함

- __멀티프로세서__ 환경이면 cpu가 여러개라는 의미인데

  cpu1에서 락을 걸면 cpu2는 여전히 인터럽트 가능한 상태, 막을 방법이 없음, 상호배제가 안된다.

- 중요한 인터럽트를 놓칠 수 있음. 임계영역이 굉장히 길어지거나 하면 특히

- 인터럽트 컨트롤하는 명령은 느린 편, 그래서 시간 소요됨

> 멀티프로세서 환경에서는 작동하지 않는다는 단점이 젤 크다



# 28 Locks-A Failed Atempt (2/7)

```
28.6 A failed attempt :  LD, ST만 사용하기
```

락 안에 flag 있고 flag가 0이면 사용 가능, flag 1이면 사용중

먼저 락에 걸린 애는 flag 1로 세팅하고 

뒤에 온 쓰레드는 while 루프에 걸려서 spin-wait()함 == busy waiting 라고 도 함

​	while 루프 돌면서 cpu 사용중임

![image](https://user-images.githubusercontent.com/67236054/235424466-7f2dfd97-8bf2-443e-8c9c-e6281b915aad.png)

---

인터럽트 걸리기 가능한 상태임

락은 이미 걸린 상태면 계속  while 루프 돌면서 spin함, 타임아웃 걸릴때까지 계속 spin

((위에 락, 언락 코드 부분은 라이브러리 부분))



![image](https://user-images.githubusercontent.com/67236054/235424896-b0caecfb-c457-4943-a424-de4490c54c9c.png)

결과적으로 +2가 되면서 원하던 작업 성공함

멀티프로세서에서도 사용가능한

크리티컬섹션 사이에 인터럽트 걸리기 가능

그러나 크리티컬 섹션에 쓰레드가 여러개 동시에 들어갈 수 없음!, 상호배제 상태

__>>> 크리티컬 섹션이 쪼개지기는 함 인터럽트에 의해서 그러나 상호배제 상태 유지__

---

LD, ST 사이가 atomic 하지는 않아서 사이에 인터럽트가 걸릴 수 있는 상태라는 것

즉 다른 케이스에서 (실패하는 케이스)

쓰레드1에서 test하고 set은 못했는데 그 사이에 재수없게 인터럽트 걸림

그래서 쓰레드2가 test하니까 아직 set 안돼서 set까지 하고 크리티컬 진입, 인터럽트 또 걸림

쓰레드1에서는 이제 set 할 차례임, 걍 set 해버림 그렇게 크리티컬 진입해벌임 오우 노우~

두 개 다 크리티컬 진입해버림~ 상호 배제 실패...

결과적으로 +1만 됐다, 락이 제대로 기능하지 못함

경쟁조건 발생

![image](https://user-images.githubusercontent.com/67236054/235425386-86bb6a34-cc45-4ea1-8019-afc3e6bfed1c.png)

# 28-3 Test-and-Set(3,4/7)

로드와 스토어가 동시에 일어남

로드하면서 set 바로 함



# 28 Locks-Working Spin Lock (5/7)

인터럽트 컨트롤하면 멀티프로세서에서는 작동하지 않음

테스트앤셋을 하면 어떤 경우에서는 상호배제안됨, 결과적으로 둘 다 실패



앞으로 할 것들

스핀락 구현하는데 테스트앤셋과 유사한 건데 9와 10

11은 스핀락은 공정성, fairness가 ?한데 공정한것

11까지는 다 결국 while루프를 도는 스핀임, cpu를 계속소모, 낭비라서

12부터는 spin을 줄여보자

13은 cpu를 양보, yield하자는 거고, 양보를 통해 스스로 레디 상태로 빠지는 거고

14은 sleep은 blocked상태로 바꾸고 나중에 누가 깨우면 레디상태로 바꾸는

![image](https://user-images.githubusercontent.com/67236054/235426133-9b68fad5-2e8c-4787-ad9d-390d248bf83b.png)

```
28.7 spin-locks
```

![image](https://user-images.githubusercontent.com/67236054/235427179-da16184d-82ff-4a94-8a3c-5dc1fc44929f.png)

x86에는 실제로 xchange라는 명령어 있음

LD,ST를 합성한 명령어임

메모리에 값을 읽어옴과 동시에 셋하는 atomic하게 이뤄지는 거임

old_ptr이 메모리 값이고 가져와서 테스트하고 새로운 값으로 셋

28.6번 첫시도에서는 락할때와 언락할때로 테스트앤셋이 분리되어있었는데

이제는 하나의 명령어에서 하자

/

위에 실패했던게 테스트와 셋이 분리되었다가 그 사이에 인터럽트 걸리면서 실패한건데

그런 경우 해결됨, 테스트와 셋을 묶었다

![image](https://user-images.githubusercontent.com/67236054/235427679-79618d17-d6ed-44d6-9af6-a954b3616e0b.png)

__평가__

상호 배제됨

데드락 안걸림

starvation-free 하지는 않음

페어하지 않음

> 쓸만하다...걍 

![image](https://user-images.githubusercontent.com/67236054/235427906-9df7744f-2c52-4ddd-ad7b-591d2bf5a3ec.png)

스케줄러가 락과는 무관하게 작동해서 그럼





# 28 Locks-Working Spin Lock(2) (6/7)

파라미터 3개

메모리에서 LD하는데 그 값이 찾던 값(여기서는 0, 즉 아무도 락이 아닐때)이면 새로운 값(1)으로 셋

플래그 1되면 while루프 빠져나옴

아니라 flag가 1이면 기대한값 0이 아니므로 ptr, flag값 유지, 리턴 오리지널 1, 그래서 while 루프 못빠져나옴

Compare앤스왑 함수로 테스트 앤 셋을 한번에 한다

테스트앤셋과 유사



![image](https://user-images.githubusercontent.com/67236054/235428329-a57c19d5-34aa-4ea2-82c8-ad66d1e2d4d2.png)

---

로드링크드할 때 첫번째로 store해서 쓰는 value 일때 쓴다.  아니면 fail, 업데이트안함



로드링크드 > 메모리의 값을 로드, LD하는데 해당 주소 기억

스토어컨디션 > 로드하면서 읽은 이후에 첫번째 Store쓰는 거라면 씀, 아니면 업뎃안함

성공하면 1아니면 0 리턴함



![image](https://user-images.githubusercontent.com/67236054/235428601-6e72da6f-7a4f-426a-af7d-67e8b7973c0d.png)



락만들기

flag에서 0을 읽으면 while 루프 빠져나옴, flag=1이면 누가 락을 건 것이라 못빠져나옴

빠져나왔다면 flag = 0임

 5줄에서 이제 내가 락을 걸겠다, 1로 세팅하겠다, 

근데 로드링크드하고 최초로 쓰는 경우 성공,

5줄 위아래에 인터럽트 걸리기 가능





![image](https://user-images.githubusercontent.com/67236054/235429865-f70470ef-4615-48be-883f-efa6519ee928.png)



## 28 Locks-Fetch And Add(7/7)

스핀락의 3개는 다 언페어함, 페어한 경우

```
28.11 Fetch-And-Add
```

lock는 티켓을 받아와서 turn, 순서가 내 차례가 될때까지 while, spin한다

turn을 +1, 증가시키는게 unlock()



락을 거는게 티켓뽑은거임, 그리고 차례 올때까지 spin

![image](https://user-images.githubusercontent.com/67236054/236799763-9693312e-2ce4-4e99-a571-1d9e858bdb6c.png)

```
평가
```

![image](https://user-images.githubusercontent.com/67236054/236799973-98c6f24a-10b6-4309-8e94-66907a95132e.png)