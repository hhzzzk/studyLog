# 1주차 2 Introduction

## 2 intro

https://www.youtube.com/watch?v=TTemIT1XRSs&list=PLGgVuvaPty_3imVCppnJcjOU-SEvRA2Iq&index=1

요약

> printf는 IO요청
>
> 전역변수는 쓰레드끼리도 공유, 지역변수는 쓰레드마다 존재
>
> Atomic, race condition
>
> 파일시스템으로 영속성 부여, path와 파일 디스크립트 넘버

### 1강 : 2.1  Virtualizing The CPU

3p

```
+ 파라미터 2개 아니면 에러
+ spin()은 sleep 같은, 1초 쉬기 요런 느낌?
+ 무한루프 돌면서 커맨드 라인 파라미터 출력
+ [0]은 ./cpu 같은 커맨드 라인 첫번째 부분
+ [1]은 입력한 string
```

```
+ 여러 개 동시 실행 가능, 명령어 ;이 아니라 &를 붙여야됨
+ 각각의 프로세스 식별 넘버 PID
+ 무한루프 돌면서 각각의 커맨드 라인[1]을 출력함
--- CPU 4개인 것처럼 가상화를 통해 처리한다. 실제 물리적 CPU는 1개
```

### 2강 : 2.2 Virtualizing Memory

5p

```
+ malloc으로 할당, 32bit(4byte) 할당하는 것처럼 그럼
+ 프로그램이 실행되는 상태 == 프로세스
+ printf는 IO요청
+ getpid()로 자신의 pid
```

```
2개 동시 실행, 여기는 &, ;
+ p의 주소는 둘 다 200000번지로 같다
+ 임의의 순서대로 두 개가 번갈아?가며 실행됨
+ 메모리가 실제 물리적 메모리가 아니라 
가상화된 공간에서 각각이 200000번지로 두 개의 메모리에서 사용되는 그런..늑힘?
```



### 3강 : 2.3 Concurrency

7p

멀티쓰레드

```
+ 실행화일에서 메모리로 로딩
+ 메모리에는 기계어로 컴파일된 코드, 텍스트 부분과 Data, Heap, Stack 부분 등있음
+ data에는 인스턴스가 1개인 자료들이 들어감, 전역변수 대표적
	초기값이 있고 없고에 따라 두 부분으로 나뉨
---
+ 쓰레드 만들 때 인자들, 세번째 인자 worker
	쓰레드의 시작점을 worker 함수로 하겠다
+ 두번째 인자 null은 스택의 크기
---
worker 함수는 activation record 가짐
+ 쓰레드 2개, 스택은 따로 가짐
	전역변수는 쓰레드끼리도 공유, 지역변수는 쓰레드마다 존재
---

+ atoi는 아스키코드를 int로 바꿈
+ volatile : 저장을 반드시 메모리에 함, cpu의 레지스터 저장하는 경우도 많은데 
반드시 메모리에 하도록 하는! 레지스터 xxx
```

> 전역변수는 쓰레드끼리도 공유, 지역변수는 쓰레드마다 존재

### 4강 : 2.3 Concurrency2 

8p

```
실행하면 쓰레드마다 커맨드 입력값 만큼(전역변수 loops)반복,
즉 최종 final value는 입력값의 2배가 되어야 함

그러나
100000 입력하면 이상한 값 도출 왜???
```

7p 다음, 8p 위

```
문제는 worker의 cnt++ 이 부분이다

기계어 레벨에서 LD A, ADD A, ST A 의 세 과정이 Atomic하게 이루어져야
처음 생각한 로직대로 작동해 2배가 되는데

이 3단계가 atomic하지 않기 때문에 문제가 발생함

race condition, 경쟁 조건 발생, 두 쓰레드에서 동시에 LD 하는 등 언제 값을 읽어오냐 쓰냐 등 타이밍 문제
```



### 5강 : 2.4 Persistence

9p

```
보통의 메인메모리 DRAM은 전원을 끄면 날라감, 휘발성 VOLATILE함

그렇다면 어떻게 HDD를 영속, Persistence하게 할 것인가

파일, 파일시스템!
```

10p

```
+ open, write, close 는 시스템 콜로 os의 커널이 제공하는 기능이다. 함수같은
+ 파일시스템을 통해 파일에 유일한 경로를 부여한다.

# open
+ open은 사람이 식별하는 path로 구성된 파일이름을 
프로그램이 실행될 때 생성되는 프로세스 안에서
그 파일을 식별하기 위한 파일 디스크립트 넘버(int 등)로 전환해는 역할
오픈할 때 조건설정도 가능
---open : path >>> 파일 디스크립트 넘버

+ 인간은 path로 식별하고 프로그램은 디스크립트 넘버로 파일을 식별한다.

# write, close 모두 식별 넘버 사용
+ write는 그 넘버 위치에 두번째 인자를 쓰겠다.
+ close는 그 넘버를 닫겠다.
```

```
여러 IO 장치들이 하드에 붙게 되는데 이 장치들을 어떻게 식별하고
프로그램 안에서 장치에다가 값을 주거나 읽을 때 어떻게 할 것인가

> 장치를 파일처럼 추상화
Device(장치, IO장치 대표적)를 파일시스템으로 파일처럼 추상화해서 식별 
```

> 영속성 == 파일 시스템, IO 장치, 연관 관계

