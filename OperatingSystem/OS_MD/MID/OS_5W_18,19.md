# OS_5W_18,19

[TOC]





## 18 Paging: Introduction(1/3)

238페이지

개요

```markdown
운영체제가 공간 관리를 할 때 사용하는 방법
1. 세그멘테이션
가상메모리에서 사용, 가변, 변하는 크기의 조각들로 분할한다.
프로세스의 주소 공간을 코드, 힙, 스택 등의 가변 크기의 세그먼트로 나눔
단점은 공간이 다양한 크기의 청크로 분할되면서 fragmented 문제 발생하고 할당이 점점 어려워져서 병합하거나 등등 해결방법 필요함.
2. 페이징
공간을 동일 크기의 조각들로 분할하자. 가상메모리에서 페이징이라고 부름. 
__프로세스__의 주소 공간을 고정 크기 단위로 나눔. 이 각각의 고정 크기 단위를 페이지라고 함.
가상메모리를 페이지로 나누고 물리메모리는 페이지 프레임이라고 불리는 고정 크기로 나눔.
물리메모리의 페이지 프레임 하나는 가상 메모리 페이지 하나를 저장 가능함.
```

2페이지 교안그림해설

```markdown
먼저 가상메모리의 크기를 확인, 64바이트의 가상메모리는 6비트가 필요함
한 페이지는 16바이트고 4개의 페이지로 나뉨. 
페이지를 구분하는 데는 2비트가 필요하고 한 페이지 안에서의 offset은 4비트가 필요함. 
> virtual address는 
	페이지 구분하는 virtual page number(VPN)+offset으로 구성

예시로 가상주소가 21이면 010101임. 여기서 앞의 01이 페이지 넘버고 offset은 0101임.

#
movl 21, %eax
> 21번지의 값을 읽어서 eax 레지스터에 넣음. 방향 > 임
#
프로세스에는 주소변환정보가 있음.
(가상메모리와 물리메모리의 연결)
virtual page 1이 physical frame 7번으로 간다. 이런
VP1 > PF7
#
이 주소변환정보를 바탕으로 Address translation함.
21의 01_0101에서 페이지 1은 pf임. 즉 111(7)이 됨
(VP1 > PF7)
#
물리메모리의 크기는 128바이트이므로 7비트가 필요한다.
(가상메모리와 물리메모리의 크기가 다를 수 있다 즉 변환됨)
한 프레임이 16바이트고 프레임이 8개 있으므로 프레임넘버는 3비트가 필요함.
위의 111이 프레임넘버가 됨. offset은 그대로 간다. 
> 그렇다면 물리메모리가 가상메모리보다 항상 크거나 그 이상일 것 같은디???

따라서 7번 프레임의 시작임 112에다가 0101인 5를 더한 117이 최종 물리메모리 주소임.

#
- 페이징은 고정메모리라 external fragment 문제 발생하지 않음
- 대신 internal frag 발생함
- 메모리 관리 쉬워짐
- bitmap, 이진수 0,1로 페이지 프레임이 비었는지 아닌지 확인 가능.
- 가상공간에서만 연속성 필요, 물리공간에서는 상관없음

```



https://www.youtube.com/watch?v=ax6ixUSEC9Y&list=PLGgVuvaPty_0ypakdHKWnvM8XBSaEWWdg

## 18 Paging: Introduction(2/3)

242페이지

```markdown
# 18.2 페이지 테이블은 어디에 저장되는가?
개요
- 페이지 테이블은 세그멘트 테이블이나 베이스-바운드 쌍에 비교해 매우 커질 수 있음
- PTE, 페이지 테이블 Enrty
- 페이지 테이블이 매우 커서 MMU안에 저장할 수 없음
- 그래서 페이지 테이블은 메모리에 저장됨
- 일단 페이지 테이블이 운영체제가 관리하는 물리 메모리에 저장된다고 알고 있으셈

# 18.3 페이지 테이블에는 무엇이 있는가?
- 페이지 테이블은 가상주소를 물리주소로 매핑하는데 사용되는 자료구조임
- 가상주소 = 가상페이지번호(VPN), 물리주소 = 물리 프레임 번호(PFN)
- 여기서는 Linera page table의 형태라고 하자

- 배열로 구성되며 운영체제는 원하는 PFN을 찾기 위해 VPN으로 배열에 접근하고 그 항목의 PTE, 페이지 테이블 엔틀리 검색함.

## 각 PTE의 비트
Valid bit
- 특정 변환의 유효 여부를 나타냄. 사용하지 않는 공간은 invalid
- 할당되지 않은 주소 공간을 표현
- 주소 공간의 미사용 페이지를 모두 표시해 거기에는 물리 프레임 할당하지 않게 해서 메모리 절약

Protection bit
- 페이지가 읽을 수 있는지, 쓸 수 있는지, 실행될 수 있는지 표시
- 프로텍션 비트가 허용하지 않는 방식으로 페이지 접근하려 하면 운영체제에 트랩걸림

Present bit
- 페이지가 물리 메모리에 있는지 디스크(HDD,하드)에 있는지(스압 아웃 확인)
- 이후 물리 메모리보다 더 큰 주소 공간을 지원하기 위해 주소 공간의 일부를 스왑하는 방법 등 이후 배움

Dirty bit
- 메모리에 반입된 후 페이지가 변경되었는지 여부

Reference bit(Access bit)
- 페이지가 접근되었는지를 추적
- 어떤 페이지가 자주 사용되는지 결정해 메모리에 유지할 페이지 결정하는데 유용(페이지 교체 page replacement 에 중요, 나중에 함) 
```

```
ㅋㅋ교수님 강의 그림만 두둥 보면 에바임 이해 어려움, 교재먼저보셈
아무리봐도..교재가...정리가 잘되네요 슈바 교재가 필수네오
시바 이번주말에는 지금까지 한거 총정리한번해야겟는데요
```

```markdown
# 18.4 페이징은 너무 느림
movl 21, %eax

## 과정
- 시스템은 가상 주소 21을 물리 주소 117로 변환해야 함
- 물리 주소 117에서 데이터를 가져오기 전에 프로세스의 페이지 테이블에서 적절한 페이지 테이블 엔트리 가져와야 함
- 적절한 PTE 가져와서 변환을 수행, 물리 메모리에서 데이터 가져옴

#
- 그를 위해 하드웨어는 현재 실행 중인 프로세스의 페이지 테이블 위치 알아야 함
- PTBR, 페이지 테이블 베이스 레지스터는 페이지 테이블의 시작 물리 주소를 저장함
- 원하는 PTE의 위치를 찾기 위해 하드웨어는 연산필요

#
- 마스킹해서 페이지 테이블 넘버 얻고 그걸 PTE배열의 인덱스로 사용함
- PTBR[VPN]!!! == PTEAddr
- 물리주소 얻었다. 하드웨어는 메모리에서 PTE[PTEAddr]해서 PFN 얻고 ㅅㅂ 모르겟는데

# Figure 18.6 Accessing Memory With Paging
10줄부터
valid bit 확인해서 invalid하면 트랩걸리고
이제 다 valid함
거기서 또 protection 확인해서 아니면 트랩
그 결과애들에서 물리주소 마스킹~ 어쩌구

```



그림 교안 8페이지

```markdown
- 주소변환정보(VP0 > PF3)이런 것들을 <Key,value>쌍으로 받아서 vp,즉 키값을 정렬하고 이후 인덱스로 대체해서 생략가능

- __프로세스마다 페이지 테이블 필요__

- 페이지 테이블에서 한 줄이 PTE임

- 페이지 테이블은 배열로 구성, 연속된 공간 필요함, VPN이 인덱스고 PFN과 Control bit로 구성

- MMU에는 PTBR 저장됨,
```



##18 Paging: Introduction(3/3)

으엉어려워으악악악악할수잇서

245페이지

```markdown
# 18.5 메모리 트레이스
간단..?한 메모리 액세스 예시를 통해 
페이징을 사용했을 때 발생하는 모든 메모리 접근 살펴보잔하^^;

> 여담임, 자료구조 - 페이지 테이블은 현대 운영체제의 메모리 관리 서브시스템에서 가장 중요한 자료 구조 중 하나임! 페이지 테이블은 가상-물리 주소 변환을 저장하여 주소 공간의 각 페이지의 물리 메모리 위치를 알 수 있게함. 이런 변환을 필요로 하기 때문에 페이지 테이블은 프로세스마다 하나씩 존재함! 
```

```c++
int array[1000];
...
for(i=0;i<1000;i++)
	array[i] = 0;
```

- 이 코드를 실행하려면 어셈블리 명령어는 다음과 같다.

```c++
//어셈블리 코드
1 : 1024  movl  $0x0,(%edi, %eax, 4)
2 : 1028  incl %eax
3 : 102c  cmpl  $0x03e8, %eax
4 : 1030  jne  0x1024
  //교수님 왈 기억해야할것
  가져올때 주소변환, 1024를 주소변환, edi 주소변환 - 메모리엑세스
  나머지는 레지스터라!! 메모리 엑세스를 언제, 몇번하는지 중요
  
```

1번

- 값 0x0을 가상 메모리 주소로 옮김
- 0이 저장될 가상 메모리 주소는 %edi + (%eax *4)
- %edi는 배열의 시작 주소, %eax는 배열 인덱스 i 값임
- 배열이 정수 배열 int이고 4바이트라 4를 곱함

2번

- %eax에 저장된 값을 1 증가

3번

- %eax의 값과 16진수 0x03e8 또는 십진수 1000을 비교함
- 비교 결과 두 값이 같지 않으면 false, 같으면 true 플래그 

4번

- false, 위에서 비교해서 같지 않으면 다시 1024로 점프함



## 19 Paging: Faster Translations (TLBs) (1/2)

https://www.youtube.com/watch?v=fpBWB5Zt6Uw&list=PLGgVuvaPty_3oKcIKvO5Whe-AC-_eDV77

254페이지

개요

```markdown
페이징은 느리다. 주소 공간을 페이지 단위로 나누고 각 페이지의 물리메모리의 위치,실제 위치 매핑 정보를 메모리에 저장해야함. 이 매칭 정보가 페이지 테이블인데 큰 메모리 공간 필요함. 주소 변환할때마다 메모리에서 읽어야하는 무한 반복임 굉장히 속도 저하 성능저하다!

그럼 어떡해

하드웨어의 도움을 받자. 주소 변환을 빠르게 하자!
translation-lookaside buffer, TLV를 사용하자.

TLB는 하드웨어 MMU의 일부임. 
자주 참조되는 주소변환 정보를 저장하는 하드웨어 __캐시__임

가상 메모리 참조시 하드웨어는 먼저 TLB에 원하는 주소정보 있는지 확인함.
있다면 페이지 테이블을 통하지 않고 TLB를 통해 빠르게 변환함. 메모리 접근 시간 대폭 줄어들겠군!!! 실질적으로 페이징 성능의 엄청난 향상!
```

교수님 뭐라는지 모르겟다 일단 책을 보자

```c++
1 VPN = (VirtualAddress & VPN_MASK) » SHIFT
2     (Success,  TlbEntry)  =  TLB_Lookup(VPN)
3    if (Success == True)    // TLB  히트
4                if (CanAccess(TlbEntry,ProtectBits)  ==  True)
5                          Offset =  VirtualAddress  &    OFFSET_MASK
6                          PhysAddr =   (TlbEntry.PFN << SHIFT)   | Offset
7                           Register =  AccessMemory(PhysAddr)
8               else
9                          RaiseException(PROTECTION_FAULT)
10   else // TLB  미스
11               PTEAddr  =  PTBR  + (VPN  * sizeof (PTE))
12               PTE  =  AccessMemory(PTEAddr)
13               if (PTE.Valid ==  False)
14                          RaiseException(SEGMENTATION_FAULT)
15               else if (CanAccess(PTE.ProtectBits)  ==  False)
16                          RaiseException(PROTECTION_FAULT)
17              else
18                          TLB_Insert(VPN,  PTE.PFN,  PTE.ProtectBits)
19                         RetryInstruction{)
```



```markdown
# 19.1 TLB의 기본 알고리즘
line1 : 가상주소에서 VPN 추출, 해당 VPN의 TLB 존재여부 검사
line2~ : 존재하면 TLB 히트임. TLB에서 값 찾기 가능
		TLB 항목에서 PFN 추출 가능함. 접근 권한 검사 후
		기존 가상주소의 오프셋과 합쳐 물리주소 구성 > 메모리 접근 성공
		
line10 : TLB 미스, 페이지 테이블에 접근해야함.
		11,12라인으로 페이지 테이블접근, PTE를 읽어온다!
		13,15라인으로 프로세스가 생성한 가상 메모리 참조가 유효하고 접근 가능한지 검사
		18라인까지 오면 접근 권한 검사 다 통과함. 문제없음
		해당 변환 정보를 TLB로 읽어들임 > 12라인 메모리 읽기가 시간 많이 소요함!
TLB가 업뎃되면 하드웨어는 명령어 재실행함
이제는 TLB 히트가 될것이다.
TLB 미스가 많이 발생할수록 메모리 접근 횟수 증가 > 성능저하, 시간소요

__다음 목표 TLB 미스를 최대한 피해야한다!__

#
Valid비트가 두 개 있는데 두 개의 의미가 완전히 다름!! 중요함
PTE에도 있음 이건 그 페이지를 사용하냐아니냐
TLB의 valid는 사용할 수 있는 매칭정보가 있는가를 알려줌

TLB의 Valid와 PTE의 Valid의 구분!!!! 개중요

#
미스가 나면 한 PTE를 캐시에 추가함 그럼 그 페이지 안의 다른 정보들은 이제 다 HIT가 됨
컴구가 생각나네요

```



## 19 Paging: Faster Translations (TLBs) (2/2)



```markdown
# 강의
소프트웨어적 처리와 하드웨어적 처리

TLB미스가 나면 트랩이 걸리면서 트랩핸들러에서 소프트웨어적으로 처리됨 나중에 return-from-trap

- 프로세스의 실행흐름, context도 저장해야함 이때 주소변환정보도 잘 보관/복원되어야함.
- 문제가 TLB미스가 나서 트랩걸려서 트랩핸들러 처리하는데 또 TLB 미스가 나면 개노답됨
- 솔루션이 필요, 커널에서는 반드시 TLB 미스가 일어나지 않음. 반드시 찾게!
- 

우엥 뭔소리야 책보자

```



```markdown
# 19.3 TLB 미스는 누가 처리함?
두 가지 방법, 하드웨어와 소프트웨어 방법 있음
1. 하드웨어가 처리함
조건 > 하드웨어가 페이지 테이블에 대한 확실한 정보 보유함
  미스 발생하면 하드웨어는
  1. 페이지 테이블에서 원하는 PTE 찾음
  2. 필요한 변환 정보 추출해 TLB를 갱신
  3. TLB 미스가 발생한 명령어 재실행함
  예시로 멀티 레벨 페이지 테이블 사용함. CR3 레지스터가 페이지 테이블 주소 가짐
  
2. 소프트웨어가 처리함
과정
1. TLB에서 주소 찾기 실패, MISS나면
2. 하드웨어는 exception, 시그널 발생
3. 운영체제 트랩 걸어서 커널모드로 변경. 트랩 핸들러 진입
4. 트랩 핸들러는 페이지 테이블을 검색해 변환 정보 찾고
5. TLB 접근이 가능한 특권 privileged 명령어 사용해 TLB 갱신후 리턴함
6. 하드웨어가 이제 명령어 재실행함. TLB 갱신됐으므로 이제 TLB 히트가 될것임

# 소프트웨어 처리의 중요포인트
- TLB 미스를 처리하는 트랩 핸들러는 시스템 콜 호출시 사용되는 트랩핸들러와 차이가 있음
	시스템 콜 호출의 경우는 트랩 핸들러에서 리턴 후 시스템 콜 호출한 명령어의 다음 명령어 실행
	
	TLB 미스 처리의 경우는 트랩에서 리턴하면 트랩을 발생시킨 명령을 __재실행__함
	재실행하면 TLB에서 히트가 됨
	> 트랩 발생하면 운영체제는 트랩 발생의 원인에 따라 
	현재 명령어의 PC값이나 혹은 다음 명령어의 PC값을 저장한다. 
	!!! TLB 트랩은 현재, 다른건 다음 PC값을 저장하겠지
	
- TLB 미스 핸들러를 실행할 때 TLB 미스가 무한 반복되지 않아야함! 
	즉 TLB 미스 핸들러에서 다시 TLB 미스가 발생하면 안됨
	
	solution 여러개 있는데
	1. TLB 미스 핸들러를 물리 메모리에 위치시키는 방법
	> 그러면 TLB 미스 핸들러는 unmap되어 있고 주소 변환이 필요없음.
	2. TLB의 일부를 핸들러 코드 주소를 저장하는데 영구히 할당함
	> TLB 핸들러는 항상 TLB에서 히트됨. wired 변환이라고 함
	
	
	>MIPS가 이방법씀, 커널모드에서만 실행가능한 특별, 특권 명령어가 존재한다.
	
```



```markdown
# 19.4 TLB의 구성
완전 연관 fully associative 방식으로 설계됨
이 방식에서 변환 정보는 TLB 내에 어디든 위치 가능, 원하는 변환 정보 찾는 검색은 TLB 전체에서 병렬적으로 수행됨

TLB의 구성은
__VPN | PFN | 다른비트들__
변환 정보 저장 위치에 제약이 없도록 각 항복마다 VPN과 PFN이 있음
하드웨어 측면에서 보면 TLB는 완전 연관 캐시임
변환 주소 찾을 때 하드웨어는 TLB의 각 항목을 __동시에 검색__함

## TLB의 다른 비트들
valid bit : 특정 항목이 유효한 변환 정보를 갖고 있는지 여부
protection bit : 페이지가 어떻게 접근될 수 있는지, 페이지 테이블에서와 쓰임새 같음 읽기/쓰기
추가적으로 이게 중요함
주소공간 식별자 address-space identifier, dirty bit 있음!
```



```markdown
# 19.5 TLB의 문제 : 문맥 교환
TLB를 사용하면 문맥교화할 때 문제 생김
TLB에 잇는 가상주소와 실제 주소간의 변환정보는 그것을 탑재, 로딩시킨 프로세스에서만!! 유효함
새로운 프로세스에서는 이전 프로세스에서 사용한 변환정보 사용하면 안됨

해결법
1. 문맥교환할 때 다음 프로세스가 실행되기 전에 기존 TLB 내용 비움
페이지 테이블 베이스 레지스터가 변경될때 비우기, 비우는 작업은 모든 valid bit를 0으로 설정
> 그러나 이 방법은 새로운 프로세스가 실행될때마다 TLB 미스 발생, 성능상의 저하 우려

2. TLB 내에 ASID 필드를 추가함
ASID는 PID, 프로세스 식별자와 유사함
TLB에 ASID 정보비트가 추가됨. 프로세스 별로 TLB 변환 정보 구분이 가능해졌다!


## 두 개의 프로세스가 동일한 물리페이지 가르키는 경우
VPN이 다른 두 개의 서로 다른 프로세스가 같은 PFN을 가리키는 경우가 있을 수 있음
> 두개의 프로세스가 하나의 페이지를 공유하는 경우, 같은 코드를 공유하는 경우일걸

```











---

퀴즈 18 Paging

```markdown
1. 페이지 테이블의 크기는 PTE 개수 곱하기 한 PTE의 크기인데
PTE의 개수는 페이지 VPN의 개수와 같다. 즉 VPN 곱하기 각 PTE 크기임
가상주소는 24비트, 페이지 하나의 크기는 1키로, 2의 10승임. 오프셋이 10비트 사용하므로
24비트에서 10비트를 제외한 14비트가 페이지개수 VFN임
2의 14승 곱하기 PTE크기 2바이트를 곱하면
페이지 테이블의 크기는 2의 10승인 1키로를 빼고 2의 4승 곱하기 2라서 32키로바이트

2. 가상 주소는 24비트로 페이지 크기는 2의2승 곱하기 2의 10승, 2의 12승인 12비트가 한 페이지 안에서 구별하는 Offset으로 사용되고 12비트가 VPN로 사용
2의 10승인 1키로를 빼고 2의 2승 곱하기 PTE크기닌 4바이트를 곱하면 2의 4승인
16키로 바이트다.

3. 페이지 테이블은 PFN과 비트들로 이루어짐. 메모리에 엑세스해서 적어야 할때는 Write가 읽을때는 read가 활성화 되어 있어야 하고 valid bit가 유효해야 접근가능하다.

어드레스 스페이스는 가상주소, 프로세스에 생성되는 것이고 한 페이지의 크기는 16바이트.
128바이트는 2의 7승이고 256바이트는 2의 8승임. 
주소공간은 7승을 4승으로 나눈 3승, 2의 3승인 8개, 페이지는 총 8개임

물리메모리의 크기는 이것의 두배이므로 음..나중에 확인해봐 일단 한 프레임 크기는 페이지 크기랑 같은거 같음. 그래서 프레임은 총 16개가 되겠지. 즉 0-15까지 있을거임

페이지 테이블에는 VPN과 PFN를 매칭할 수 있음 인덱스 0부터 시작해서 그게 VPN임
구체적으로는 안쓸게 아닌가? 일단 최대한 써

movl의 방향은 >임. 즉 왼쪽에 값을 오른쪽 위치에 저장한다.

왼쪽이 eax 즉 레지스터면 오른쪽의 주소위치에 해당 레지스터 값을 저장한다.
이때 invalid하면 세그멘테이션 폴트가 나고 
해당주소가 read only면 write를 해야하는 상황이라 protection falut가 남

왼쪽이 주소값이면 read가 되어야 읽어올수있겠지
아니면 프로텍션 폴트가 나겠지? 일단 valid 비트먼저 봐서 아니면 세그멘테이션 폴트 나는듯. 즉 비트는 valid 비트 먼저 확인하고 그 다음에 프로텍션 비트 확인하나봄

//
페이지테이블에서 맞는 VPN찾아서 R/W, Valid bit를 확인함
```

퀴즈 19 TLB

```markdown
1. #19.2네오
해설일단 하면 
처음에 sum+=a[i]; 하면서 루프를 돈다.
하드웨어는 VPN을 추출함. a[0]은 VPN 6번이다. TLB에 없다. VPN 6번이 TLB에 갱신됨
a[1], a[2]는 TLB에 존재해서 HIT가 됨

정리하면 a[0], a[3], a[7]에서 tlb miss가 남

## spatial locality
첫번째 루프에서 배열이 서로 인접해있는 위치에 존재하기 때문에 즉
spatial locality, 공간 지역성으로 인해 hit가 많음, 성능이 개선됨

페이지 크기도 TLB의 성능에 큰 영향임. 페이지 크기가 2배가 되면 TLB 미스 횟수가 더 줄어즌다.

## temporal locality
프로그램이 루프 종료 후에도 배열을 사용하면 성능이 더 개선됨
즉 TLB가 모든 주소 변환 정보를 저장할 정도로 크면 이후에는 전부 HIT가 될것임
시간 지역성으로 인해 히트율이 높아진다.

시간 지역성 : 한번 참조된 메모리 영역이 짧은 시간내에 재참조됨
```



```markdown
Line 5에서 i=0 을 실행하기 위해 i 로 접근하면 TLB miss가 난다.
> 두번째 루프, 이미 sum 하는 첫번째 루프에서 TLB가 다 갱신됨. hit만 발생 

Line 6에서 a[7]에 접근할 때 TLB Hit가 된다.
> 두번째루프라서 시간지역성

Line 3에서 i=1일 때 sum으로 접근하면  TLB Hit 가 된다.
> 첫번째 루프, a[0]에서 이미 tlb를 갱신했기 때문에. 짧은 시간내에 재참조. 시간지역성

Line 3의 코드 "+="(ADD, MOVE)는 i=0 일 때는 TLB miss가 나지만 그 다음 i=1 일 때 부터는 계속 TLB Hit가 된다.
> 맞지. 위랑 같음

Line 3에서 a[0]에 접근할 때는 TLB miss가 나지만 그 다음에 a[1], a[2]에 접근할 떄는 계속 TLB Hit가 된다.
> 머 같은애기 아니냐..근데 이건 공간지역성이네, 배열이라 그럼 배열은 서로 연속해서 근처에 있어서 공간지역성으로 봄
```

줌 영상 있으니까 나중에 함보자....



//

페이징 퀴즈 5번 코드에서 1024번지 실행하기 위해 메모리 접근하는 횟수

- 명령어 반입 시에 두번, 명령어위치파악 페이지 테이블 한번, 명령어 자체에 한번
- mov는 메모리 참조 한번 필요 > 페이지 테이블 한번 + 배열 자체 접근용 한번