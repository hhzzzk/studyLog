# OS_6W_20,21,22

[TOC]



## 20 Paging : Smalleer Tables(1/3)

https://www.youtube.com/watch?v=qBoZ8wKbZ7s&list=PLGgVuvaPty_01zYbeLH0Pd4B4Gy4wA8BO

272페이지

하이브리드 방법

개요

```markdown
페이징의 첫번째 문제는 속도, 성능 문제였다
이는 하드웨어의 캐시 TLB를 이용해 해결했다.

두번째 문제는 __페이지 테이블의 크기__가 커서 메모리 공간을 많이 차지한다는 것이다.
또 페이지 테이블은 각 프로세스마다 존재한다. 굉장한 메모리 부담

그래서 페이지 테이블을 어떻게 하면 최소화, 작게 만들수 있을까!!!
```



```markdown
# 20.1 가장 간단한 해결방법은 페이지 크기를 키우기
그러나 부작용은 패이지 내부에서 안쓰는 공간이 많이 생김 
내부 단편화, internal fragmentation 문제가 생김
페이지의 일부분만 계속 사용함

# 20.2 하이브리드 접근법 : 페이징과 세그먼트
세그먼트 기억안나요
> 베이스앤 바운드, 필요한 만큼을 동적으로 공간 할당함. 힙공간 스택공간 등으로 해서

## 힙과 스택에서 일부분만 사용되는 경우
그림 20.1
프로세스의 전체 주소 공간을 하나의 페이지 테이블로 구성하지 말고
세그먼트(힙,스택,코드 등)마다 페이지 테이블을두자.

세그멘트처럼 베이스 앤 바운드 방식을 차용해
베이스 레지스터에는 세그멘트의 페이지 테이블 시작 주소를
바운드 레지스터에는 페이지 테이블의 끝을 나타냄

+ 결국 페이지테이블도 물리주소에 있음 거기로 가는 연결방법, 주소매핑을 세그먼트 테이블로 한것임, 그니까 방향이 퀴즈코드 추가부분임 
+ 결국 세그먼트 테이블도 또 물리주소에 있다
---
> MMU 알고리즘
 가상주소 >>> 세그먼트 번호와 VPN 추출
 세그먼트테이블에서 접근권한검사
 (해당 세그먼트 valid와 vpn이 해당 세그먼트 사이즈초과여부확인)
 TLB 존재하는지 확인
 TLB 히트 > 접근권한검사, 물리주소 엑세스 메모리
 TLB 미스 > PTEAddr을 세그먼트 테이블 이용해서 구함
 			PTE의 물리주소에 엑세스 메모리
 			PTE에서 접근권한 검사
 			TLB에 추가
 ---

소속 세그먼트 나타내기 위해 x개 비트, 여기서는 4개의 세그먼트가 2비트 사용함

실행 중인 프로세스에서 각 세그멘트의 베이스 레지스터는 
각 세그멘트 페이지 테이블의 시작 물리주소 가짐
문맥 교환하면 레지스터는 새로운 프로세스의 페이지 테이블 위치값으로 변경됨

가상주소의 구조는
seg# + vpn + offset 으로 구성됨

### TLB 미스 발생하면
아래 코드 참고
1. 세그멘트 비트, SN을 사용해 어떤 베이스와 바운드 쌍 사용할지 결정
2. PTE의 주소를 얻는다.
> 포인트는 페이지 테이블 베이스 레지스터 말고 세그멘트 베이스 레지스터를 사용한다.
3. PTE의 주소를 다시 물리주소로 변환
```

```c++
SN = (VirtualAddress & SEG_MASK) >> SN_SHIFT
VPN = (VirtualAddress & VPN_MASK) >> VPN_SHIFT
AddressOfPTE  =  Base[SN]  +  (VPN * sizeof (PTE))
```



```markdown
하이브리드 기법의 핵심은 세그멘트마다 바운드 레지스터가 따로 존재한다는 것
각 바운드 레지스터의 값은 세그멘트의 최대 유효 페이지 개수를 나타냄
	(3개의 페이지를 사용중이면 바운드 레지스터는 3, 
	넘어가면 예외 발생, 프로세스 종료)
	
	> 효과 : 그냥 페이지 테이블보다 메모리 사용개선됨
			스택과 힙 사이에 할당되지 않는 페이지들은 
				페이지 테이블 상에서 공간 차지 안함
			
	> 여전히 문제점 존재
				1. 세그멘테이션 사용
					sparsely 빈공간 많은 힙은 여전히 페이지 테이블 낭비 발생
				2. 외부 단편화 유발 - external frag
					세그멘테이션 때의 문제와 같은 문제
					하이브리드 방식에서는 
					페이지 테이블 크기 제한없고 다양한 크기 가짐
					그 때문에 finding free space, 연속된 빈공간 찾기 어려움
					페이지 테이블의 사이즈가 다양해져서
					
					
					다음 방법. 멀리 레벨 페이지 테이블
					
					
> 목표가 페이지 테이블 크기를 줄이자
그래서 세그멘테이션 방법과 페이징 방법을 하이브리드함
세그먼트 테이블이 추가됨 페이지 테이블이란 큰 연속된 공간이 사라지고
세그먼트 테이블을 이용해서 해당 PTE를 찾을 수 있음
```



## 20 Paging : Smalleer Tables(2/3)

멀티 레벨 페이지 테이블 

276페이지

개요

```markdown
# 20.3 멀티 레벨 페이지 테이블
세그멘테이션을 사용하지 않고 페이지 테이블 크기를 줄이자
사용하지 않는 주소 공간을 페이지 테이블에서 제거하는 방법 찾아보자구

이전까지는 페이지 테이블이 선형구조였음.
멀티 레벨 페이지 테이블에서는 선형 페이지 테이블을 트리 구조로 표현함

# 기본 개념
1. 페이지 테이블을 페이지 크기의 단위로 나눈다.
2. 페이지 테이블의 페이지들이 전부 invalid하면 페이지를 할당하지 않음
3. __페이지 디렉토리__라는 자료구조를 사용해 페이지들의 할당 여부와 위치 파악함

# 페이지 디렉토리
페이지 디렉토리는 PDE, 페이지 디렉토리 엔트리로 구성됨
각 PDE의 구성은 페이지 테이블의 각 항목 PTE와 유사함
						Valid비트와 PFN을 가짐
## PTE와 PDE의 valid 비트차이
PDE가 valid >>> 해당 항목의 페이지들 중 최소한 하나의 PTE는 valid=1하다.
PDE가 invalid >>>  PDE는 실제 페이지가 할당되지 않음

## 장점
1. 사용된 주소 공간의 크기에 비례해 페이지 테이블 공간이 할당
		보다 작은 크기의 페이지 테이블로 주소 공간 표현 가능
2. 페이지 테이블을 페이지 크기로 분할해 메모리 관리가 용이
		페이지 테이블 할당/확장시 운영체제는 free 페이지 풀에 있는 빈페이지 사요암
		
## 멀티 레벨 페이징과 선형 페이지 테이블 방식 비교하기
선형 >>> 각 항목은 해당 가상 페이지의 물리 페이지 주소 가짐(디스크로 스왑xxx)
		연속된 물리 메모리 공간 차지
멀티 >>> 페이지 디렉토리 이용해 각 페이지 테이블 페이지들의 위치 파악함
		각 페이지들이 물리 메모리 여러 곳에 나뉘어 퍼져있어도
			페이지 디렉토리를 이용해 위치 파악이 가능
				페이지 테이블을 위한 공간 할당이 유연함
				

## 단점
멀티 레벨 테이블에는 추가 비용 있음
TLB 미스가 나면 주소 변환을 위해 페이지 디렉토리, PTE접근의 2번의 메모리 로드 발생
>>> 선형 페이지 테이블은 한 번의 접근만으로 주소 공간을 TLB로 탑재함.

## 결론
멀리 레벨 테이블은 페이지 테이블 접근 시간과 페이지 테이블 공간을 time-space-trade-off한 것이다. 상호 절충
대신 메모리 접근 시간이 증가함.
TLB 히트하면 성능은 동일하나 TLB 미스하면 두 배의 시간 소요

복잡도가 증가한 단점도 있음
	검색을 하드웨어/운영체제로 구현하느냐 여부와는 무관
	메모리 자원의 절약으 위해 페이지 테이블 검색이 복잡해짐
```



```markdown
# 강의
페이지 테이블이 가상공간에 떠있는데
그 중에 유효한 페이지만 물리메모리에 탑재하자, 
페이지가 invalid하면 페이지 디렉토리에 valid비트가 0

하이브리드는 가상공간을 세그먼트로 자름
멀티는 페이지 테이블을 자른다
	잘라서 안쓰는 페이지는 탑재안함 - 페이지 디렉토리에서 invalid
```





## 20 Paging : Smalleer Tables(3/3)

멀티 레벨 페이징 예제

```markdown
멀티 레벨 페이지 테이블의 목적은 
	페이지 테이블의 모든 분할된 부분들이 단일 페이지 크기에 맞도록 하는 것임

페이지 디렉토리가 너무 커지면 한 번 더 나눌 수 있다.
그런 식으로 단계가 더 더 느어갈수 있음
가상주소가 PDI1 PDI2 PTD~ 머 이런식으로 됨

머르겟다 영상다시봐..
```





## 21 Beyond Physical Memory : Mechanisms(1/2)

https://www.youtube.com/watch?v=YTVdQAkBvSc&list=PLGgVuvaPty_0feiT028pwQTBudzs_G-2j

288페이지

```markdown
# 강의, 그림참고 2페이지
## 현대 사회의 메모리 계층 구조
레지스터 > 캐시 > 메인메모리 > 하드디스크 등

전체적인 구조는 CPU, MMU, 캐시, 물리메모리, HDD의 구조임

일단 프로세스는 가상임. 주소공간이 있고 페이지는 4개, 한 페이지의 크기는 16바이트라
VPN에 2비트, 페이지 Offset에 4비트를 사용함
명령은
​```
1. LD A 11 0100 > 11페이지
2. LD A 10 0010 > 10 페이지
3. JMP 00 1000 > 0 페이지
​```
CPU는 VPN에 대응하는 PFN를 알기 위해 하드웨어 MMU에게 해당하는 PFN을 알려달라고 요청함

MMU에는 TLB, PTBR(페이지테이블 베이스 레지스터, 페이지 테이블 시작주소), PTE가 있음
MMU는 해당 VPN을 인덱스로 사용해 Base[vpn]해서 페이지테이블에 pte을 찾아감.
페이지 테이블은 물리메모리에 있음

1.
	페이지 테이블의 present bit가 11 vpn의 경우 1이라서
	물리메모리에 해당 페이지가 존재함을 알 수 있음
	PFN 해서 알려주면 끝

2. VPN 10의 경우 페이지 테이블의 Present bit가 0으로 물리메모리에 해당 페이지가 없고
	따라서 스왑공간에서 페이지를 가져와야함
	물리메모리에 빈 공간, free한 공간이 있으므로
	스왑공간에서 이 빈공간에 vpn10인 페이지를 가져온다.
	
코드로 보면 PTE.Present==False 이므로 MMU가 exception을 걸고, 트랩이 걸린다.
커널은 트랩핸들러에 가서 어떤 트랩인지 보자 페이지 폴트인 것을 확인

커널코드에서 페이지 폴트를 처리하는 알고리즘을 소프트웨어적으로 처리함

​```코드참고. 그림21.3, 한글교재 294페이지```

​```먼저 빈 페이지 찾음, 빈페이지 없으면 교체 알고리즘 실행하고 빈페이지가 있으면 DiskRead, PTE의 present비트와 PFN을 업데이트, 해당 명령어르 재실행함```

페이지 폴트 처리 후 해당명령어, 2번 명령어가 재실행됨, 이제는 present bit가 1이므로 물리모리의 해당 pfn에서 잘 읽어감

3. VPN00으로 위와 같은 과정 거쳐 커널에서 페이지 폴트를 처리하는데
	빈공간이 없다. 따라서 페이지를 교체하고 명령어가 재실행됨
	
	
# 중요
페이지 폴트를 처리할 때 DiskRead하면 프로세스가 blocked된다. 디스크 리드는 io요청이라 시간 많이 걸림. 따라서 context switch가 일어남. 해당 io요청이 끝나면 프로세스는 다시 레디 상태가 되고 그럼
```





---

---

---





```markdown
# 개요
지금까지는 가상 주소 공간이 작아서 모두 물리 메모리에 탑재가 가능했음
실행 중인 프로세스의 전체 주소 공간이 메모리에 탑재된 것으로 가성했음
이제는 다수의 프로세스들이 동시에 각자 큰 주소공간을 가지고 있는 것을 가정함

---
## 필요한 것
__메모리 계층__에 레이어 추가 필요함
  - 지금까지는 모든 페이지가 물리 메모리에 존재한다고 가정함
  - 이제 큰 주소 공간을 지원하기 위해 
    운영체제는 주소 공간 중에 현재는 필요하지 않은 부분을 보관할 공간이 필요함
    (메모리 공간보다 더 크고 느린 공간)
    보통 하드 디스크 드라이브가 이 역할함
- 메모리 계층에서 크고 느린 하드 디스크 드라이브가 가장 아래에, 그 위에 메모리 존재함

## 왜 프로세스에게 굳이 큰 주소 공간을 제공해야 하는가?
편리함과 사용 용이성
- 주소 공간이 충분히 크면 메모리 고간에 대한 걱정할 필요 없어짐
	필요한 경우 운영체제에게 메모리 할당요청
	운영체제가 이러한 __가상__환경을 제공하면 매우 편리해짐
### 메모리 오버레이
위와같은 가상환경을 제공하는 것과 반대로 
프로그래머가 _수동_으로 메모리에 데이터/코드를 탑재/제거함

## 스왑 공간
스왑 공간이 추가되면 
	운영체제는 실행되는 각 프로세스에게 큰 가상 메모리가 있다고 생각하게 만들기 가능

멀티프로그래밍 시스템-동시에 여러 프로그램 실행시키는 시스템-의 발명으로
__많은 프로세스들이 페이지를 물리 메모리에 전부 저장하는 것이 불가능해짐__
>>> 일부 페이지를 스왑 아웃하는 기능이 필요해짐

멀티프로그래밍과 사용 편의성의 이유로 
실제 물리 메모리보다 더 많은 용량의 메모리 필요해짐 
>>> 가상메모리의 출현
```



```markdown
# 21.1 스왑 공간
__디스크에 페이지들을 저장할 수 있는 공간__ >>> 스왑 공간
(((하드디스크에 페이지를 저장할 수 있는 추가 여부 공간이 스왑 공간이다)))
			(물리)메모리 페이지를 읽어서 스왑공간에 쓴다(swap out)
			스완공간에서 페이지를 읽어 메모리에 탑재(swap in)함
			기준이 메모리임 페이지가 메모리로 가면 인, 메모리말고 스왑공간으로 가면 아웃
			

스왑 공간의 __입출력 단위는 페이지__로 가정함

운영 체제는 스왑 공간에 있는 모든 페이지들의 __디스크 주소(스왑공간) 기억__해야 함
(프로세스의 주소공간을 일정한 크기로 나눈게 페이지임(페이징출처))

## 스왑 공간의 크기
스왑 공간의 크기는 매우 중요함
>>> 스왑 공간의 크기가 시스템이 사용가능한 메모리 페이지의 최대수를 결정함

일단 스왑 공간 매우 크다고 가정함

스왑 공간을 이용하면 시스템에 
실제 물리적으로 존재하는 메모리보다 더 많은 공간이 존재하는 것처럼 가장할 수 있다.

## 스왑 공간에만 스왑 할 수 있는 것은 아님
프로그램을 실행
실행프로그램의 페이지들은 디스크에 존재
프로그램이 실행되면 각 페이지들은 메모리로 탑재

?물리 메모리에 추가 공간을 확보해야 할때 
	코드 영역의 페이지들이 차지하는 물리 페이지는 즉시 다른 페이지가 사용할 수 있다.
	> 빈공간 없을때 코드있는 부분은 디스크에서 바로 가져올수있어서 대체순위가높다???
	코드가 저장되어 있는 파일 시스템 영역이 스왑 목적(추가공간제공)으로 사용되는 셈이다
	해당 페이지들은 디스크에 원본이 있으므로 언제든지 다시 스왑인이 가능하기 때문
```



```markdown
# 21.2 Present bit
디스크에 스왑 공간을 확보했다!! 짝짝짝
페이지 스왑을 위한 기능이 필요한 때이다.
하드웨어 기반읜 TLB를 사용하는 시스템을 가정함

메모리 참조의 과정은
1. 프로세스가 가상 메모리 참조를 생성함(명령어 탑재, 데이터 접근 등)
2. 하드웨어는 메모리에서 원하는 데이터를 가져오기 전에 가상 주소를 물리주소로 변환함
3. 하드웨어는 가상주소에서 VPN 추출해 TLB에 해다 정보 있는지 검사
4-1. 히트면 물리 주소를 얻은 후에 메모리로 가져옴.
4-2. 미스면 하드웨어는 페이지 테이블의 메모리 주소를 파악하고 (PTBR 사용)
	VPN을 인덱스로 해 원하는 PTE추출함
	퀴즈에서 한거임 접근권한검사하고 PTE에서 PFN추출해 그 정보를 TLB에 탑재함
	TLB에 INSERT후 명령어 재실행 이제는 히트됨
	
## 페이지가 디스크로 스왑되려면 필요한 기능
1. 하드웨어가 PTE에서 해당 페이지가 물리 메모리에 존재하지 않음을 표현해야 함
	이 때 TLB기법의 경우 
	하드웨어는 __present bit__사용해 
	물리메모리에 해당 페이지가 존재하는지 나타냄
	
	present bit == 1
		물리 메모리에 해당 페이지가 존재한다.
	presetn bit == 0
		메모리에 해당 페이지 존재하지 않고 디스크 어딘가(스왑공간)에 존재함

### Page fault, 페이지 폴트란 페이지폴트 정의
- __물리 메모리에 존재하지 않는 페이지를 접근하는 행위__

- 페이지 폴트가 발생하면 페이지 폴트를 처리하기 위해 운영체제로 제어권이 넘어감
	페이지 폴트 핸들러 실행됨
		
```



```markdown
# 21.3 페이지 폴트
TLB 미스의 처리 방법에 따른 두 종류의 시스템
1. 하드웨어 기반의 TLB >>> 하드웨어가 페이지 테이블 검색해 원하는 변환 정보 찾음
2. 소프트웨어 기반의 TLB >>> 운영체제가 처리함

둘 다 페이지 폴트가 발생하면 __운영체제가 처리를 담당__함

운영체제의 __페이지 폴트 핸들러__가 처리 매커니즘 규정함

if 요청된 페이지가 메모리에 없고 디스크로 스왑되었으면
>>> 운영체제는 해당 페이지를 메모리로 스왑해옴

이 때 원하는 페이지의 위치를 어떻게 파악하는가?
>>> 해당 페이지의 스왑 공간 상에서의 위치를 페이지 테이블에 주로 저장함

---

- 운영체제는 PFN과 같은 PTE비트들을 페이지의 디스크 주소를 나타내는데 사용가능함
- 페이지 폴트 발생시 운영체제는 
	__페이지 테이블 항목에서 해당 페이지의 디스크상 위치를 파악해 물리메모리로 탑재함__


## 디스크 IO 완료
운영체제는 해당 페이지 테이블 엔트리의 PFN값을 탑재된 페이지의 메모리 위치로 업뎃함(present비트도 업뎃함)
이 작업이 완료되면 페이지 폴트를 발생시킨 명령어가 재실행됨

__재실행으로 인해 TLB 미스 발생가능__!!! 

물리메모리에 탑재된거지 mmu의 tlb에는 여전히 없음

- TLB 미스 처리 과정에서 TLB값이 업뎃됨
	(이를 피하기 위해 페이지 폴트 처리시 함께 TLB 업뎃하게 하기도 함 일단 여기선 아님)
	
- 마지막 재실행 시에 TLB에서 주소변환정보를 찾게 되고
	이를 이용해 물리주소에서 원하는 데이터/명령어를 가져옴
---

## 중요
- IO전송 중에는 해당 프로세스가 __blocked 상태__가 된다는 것 주의
- 페이지 폴트 처리시 운영체제는 다른 프로세스들을 실행할 수 있음
- IO실행 == 시간 많이 소요
- 한 프로세스의 IO작업(페이지 폴트)와 다른 프로세스의 실행을 __overlap중첩__시키는 것은 
	하드웨어를 효율적으로 사용 가능해짐
	
```



```markdown
# 21.4 메모리에 빈 공간이 없으면?
위에서 스왑 공간으로부터 페이지 가져오기 위한 페이지인이 여유 메모리가 충분함을 가정함

그러나! 메모리에 여유 공간이 없을 수 있다!
그래서 기존 것들 중에 필요없는 것을 새로운 페이지로 교체하거나 아웃시켜야 할 때가 있음

교체replace 페이지를 선택하는 것을 __페이지 교체 정책__이라고 함
```



## 21 Beyond Physical Memory : Caching(2/2)

물리메모리 공간의 한계 때문에 하드의 스왑공간 이용해서 필요할때 디스크 엑세스해서 가져오고

그리고 가져온, 그니까 사용하는 정보들을 물리메모리를 캐시로!!!! 사용하는 것처럼 보임

결국 물리메모리를 하드의 캐시로 본다는 말임

```markdown
Locality로 캐쉬 가능해짐

주소 공간에 엑세스하는 패턴을 보면 자주 가는 주소공간이 있음
특정 지역에 자주 엑세스하게 됨
그게 locality이고
두가지
temporal과 spatial임
시간적으로, 최근에 엑세스한 곳에 또 엑세스할 가능성 높은
공간적-배열같은, 특정 위치에 엑세스하면 그 근처에 엑세스 자주함

시간적
페이지 폴트 처리하면서 하드에 있던 페이지가 점점 올라오면서 점점 cpu에 가까워짐

공간적
처음에는 페이지 단위로 올라가다가 cpu까지, 점점 크기가 커진 큰 블락 단위로 올라가게 됨
캐쉬라인

---


```





## 22 Beyond Physical Memory : Policies(1) (1/1)

https://www.youtube.com/watch?v=zk0C4kkSEp0&list=PLGgVuvaPty_2WbkX57JvTTvF3BdD-Vr96

300페이지

```markdown
# 개요
가상 메모리 관리자는 빈 메모리가 많을수록 좋다. 

페이지 폴트(물리메모리에 존재하지 않는 페이지 접근)할 경우
    빈 메모리 공간이 없다면 
    운영체제는 메모리 압박, Memory pressure를 해소하기 위해 
    다른 페이지들을 강제적으로 페이징 아웃해서 공간을 확보함
evict, 내보낼 페이지 선택은 운영체제의 교체 정책 replacement policy에 있음

# 22.1 캐시 관리
시스템의 전체 페이지들 중 일부만 메인 메모리에 있다
> 메인 메모리는 가상 메모리 페이지에 빠르게 가기 위한 일종의 캐시
> 캐시의 교체 정책의 목표는 __캐시 미스__의 횟수를 최소화하기
	> 디스크(스왑공간)로부터 페이지 가져오는 횟수를 최소로 만들자!
> 동시에 __캐시 히트__수를 최대로 한다는 것도 교체 정책의 목표
	> 접근된 페이지가 메모리에 이미 존재하게 하는 횟수를 최대로
    
## AMAT, 평균 메모리 접근시간, Average memory access time
캐시 히트와 미스의 횟수를 안다면 AMAT 계산 가능
((AMAT는 하드웨어 캐시 성능 측정할 때 사용하는 미터법))

>>> AMAT = Tm + (Pmiss * Td)

Tm은 메모리 접근 비용, Td는 디스크 접근 비용, Pmiss는 캐시에서 미스날 확률(데이터없음)

- Pmiss는 0-1 사이의 값, 퍼센트값으로도 나타냄
- __메모리의 데이터 접근 비용은 항상 지불해야 한다__기억
- 그러나 메모리에서 데이터 못찾으면 디스크로부터 데이터 가져오는 비용 !추가! 지불

## 계산법
hit율 * Tm + miss율 * Td
1ms = 100,0000 ns
1microsec = 1000 ns


__정책들 모두 최초시작미스, cold-start miss == compulsory miss는 동일함__
- Access은 프로세스에서 VPN만 모아놓은 것임
- 캐시 상태의 개수

```



```markdown
# 22.2 Optimal Replacement Policy (OPT : Optimal Page Replacement)
- 미스를 최소화함
- 가장 나중에 접근될 페이지를 교체함
- 현실적으로는 불가능함

# 22.3 FIFO
- 먼저 들어온 페이지를 내보냄
- 구현이 매우 쉬운 장점
- 성능은 안좋음

(((Belady's Anomaly : 여담
벨러디 아저씨가 OPT 만듦. 일반적으로 캐시의 크기가 커지면 히트율이 증가하는데
FIFO는 더 안좋아짐. 이걸 벨러디의 Anomaly라고 함
LRU와 같은 다른 정책들은 히트율 좋아짐. 왜냐면 스택특성 stack propery라는 특성가져서임
캐시 크기가 n+1 로 증가하면 캐시크기 n 일때의 내용을 포함함. 그래서 캐시 크기 증가하면 히트율은 최소 유지됨. FIFO와 랜덤은 스택 특성을 가지지 않음!)))


# 22.4 Random
- 메모리 압박 있을 때 페이지 무작위로 내보냄
- 히트율도 랜덤임

# 22.5 LRU 과거 정보의 사용
- frequency, 빈도수를 사용함
- temporal locality 고려함(나머지 정책은 고려하지 않음, opt는 애매)
- least-recently-used, 가장 적은 빈도로 사용된 페이지 교체함
- 히트여도 최근페이지가 계속 캐시순서에 업데이트됨

- MRU는 이와 반대임 존재하긴 하는데 잘 안씀
```













#퀴즈

20:하이브리드

```markdown
열이 pfn이고 행이 offset임
오시발 일단 봐봐

가상주소를 물리주소로 바꾸는 과정 (하이브리드)
1. 가상주소는 seg# + vpn + offest으로 구성됨 > sn과 vpn 얻기
2. 세그먼트 번호로 세그먼트 테이블 참조함 
> 세그먼트 테이블의 valid 확인
> vpn이 세그먼트의 size를 넘어가면 프로텍션 폴트

3. TLB에 존재하는지 확인

4. TLB 미스가 난 경우
5. PTE의 주소는 세그먼트 테이블의 베이스주소[SN]에다가 VPN을 PTE의 크기를 곱한값을 더함. PTE의 주소를 얻었다
물리주소는 PFN+Offset이다.
6. PTE의 주소를 물리주소로 변환한다. 
PFN과 Offset으로 물리메모리에서 PTE값을 얻는다.
PTE는 Validbit + 00 + PFN으로 구성됨
7. Valid 여부를 확인하고 PFN 값을 얻는다.
8. 물리주소는 PFN + Offset이다.

# 2번
0x012
0000 0/001 0/010 > 0번 세그먼트 페이징 2, 오프셋 2
PTEAddr은 Base[0]에서 오프셋2칸이동
PFN 3, off 2는 9c이고 여기서 오른쪽으로 2칸이동하면(vpn*pte사이즈) 15임
PTE는 0X15
0001 0101 > invalid
```

20:멀티

```
방법을 알아야댐
코드가 사실 다긴 해

가상주소는 PDI + PTI + Offset으로 구성됨
PDBR은 페이지 디렉토리 베이스 위치는 문제에 있을것이고
해야되는게 크게 보면
1. 가상주소에서 페이지 디렉토리 엔트리 찾기
2. 페이지 디렉토리 엔트리에서 페이지 테이블 엔트리 찾기
3. 해당되는 PFN과 가상주소 OFFSET 합치기
이거임

PDB(PFN)에서 PDI만큼 이동하면 PDE 페이지 디렉토리 엔트리 나온다.
PDE는 valid비트 + 프로텍션2비트 + PFN 으로 구성됨
접근권한검사, PTE를 구해야함. PFN에서 PTI만큼 이동하면 PTE 페이지 테이블 엔트리 나옴
PTE는 valid비트 + 프로젝트2비트 + PFN 구성임
접근권한검사, PFN+가상주소 OFFSET을 해서 16진수로 바꾸면
PA 물리주소가 나온다.
```

21 Demand Paging

```markdown
페이지 폴트 트랩 걸려서 핸들러로 온거임
즉 페이지 폴트 상태임 지금 상태는

1. Line 1에서 Free인 Physical Page Frame을 찾으면 프로세스의 상태가 Blocked로 되지 않는다.
>>> x 아님 찾아도 디스크리드하면서 io요청해서 블락됨 

2. PTE의 Present bit가  False이면 Trap이 걸려서 호출된다.
>>> ㅇ false면 물리메모리에 없으므로 스왑공간에서 찾아야함. 하드웨어 페이지폴트 알고리즘보면 exception, 트랩이 걸리면서 트랩핸들러에서 페이지 폴트 코드 찾아서 커널이 호출함

3. Line 7은 CPU의 PC 레지스터가 중단되었던 명령어를 가리키도록 해서 다시 실행하는 것이다.
>>> 맞다

4. Line 5, 6, 7은 Line 4에서 요청한 IO(Disk Read)가 진행되는 동안 병행 실행된다.
>>> ? 순차실행 라인4가 실행되고 있으므로 5는 실행되지 않음

5. Line 7에 의해서 중단 되었던 명령어를 다시 실행하면 TLB miss가 난다.
>>> ? 일단 이 코드가 실행됐다는건 pte의 present비트가 0이라 물리메모리에 페이지 정보가 없음. 그리고 트랩걸려먼 페이지 폴트 커널에서 처리할때 일어나는 알고리즘 코드인데 그렇다면 물리메모리에 free공간이 있든없든 일단 스왑공간에서 페이지 정보를 읽어옴-io요청 디스크리드. 이 요청이 완료되면 페이지 테이블이 갱신됨, pte값이 업뎃(present 비트와 pfn값) 명령어를 재시도함. 그러면 TLB 미스가 남. TLB는 페이지 테이블이 아니라 MMU 하드웨어에 있는 캐시자나 여긴 아직 없음. 물리메모리에 탑재된 거임 페이지 정보가!!!!
그러면 TLB 미스 났으니까 하드웨어 페이지 폴트 알고리즘에서 TLB 미스나면 퀴즈에서 했던 것처럼 가상주소에서 PTE값 찾아내서 하다가 PTE의 present bit값을 위에서 업뎃했으므로 TLB에 Insert되고! 그 다음에 또 실행하면 tlb 히트가 됨!!!!!!! 중요하군아


6. Line 1에서 Free Physical Page Frame을 못찾으면 conflict miss가 난 경우이다.
>>> ?capacity 용량부족으로 물리메모리에 free 공간이 없다는것이라 capaciry miss로 봐야

7. 하드웨어 기반 TLB 이면 Line 7에서 중단된 명령어를 재시도할 때 커널로 Trap 없이 실행된다. 
>>> ㅇ 트랩이 sw에서 실행되서 , 하드웨어라 자체회로에서 tlb에 등록
```
22-1 Replacement Policy 1

```
OPT는 미래를 봐서 가장 나중에 쓰는 페이지 교체, 기본적으로 순서는 유지되고 그 페이지만 날아감

LRU는 가장 적게 쓰는 페이지를 날림, 기본적으로 hit도 밀어내고 miss도 계속 밀어내고 순서 바뀜

FIFO는 먼저들어온게가장먼저나감, hit되면 유지 아니면 계속 밀어냄
```

