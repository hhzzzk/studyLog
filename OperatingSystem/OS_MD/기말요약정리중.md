# 11W 컨디션 변수

- 비지웨이팅하면 cpu낭비하지 말고 상태변수 사용해 조건만족 확인해서 쓰레드를 sleep시키자
- 컨디션 변수는 일종의 큐 자료구조임
- 쓰레드 실행에서 조건이 만족되기를 대기하는 큐, 조건만족하면 대기 중인 쓰레드 깨워 실행
- wait()로 쓰레드 sleep시킴, signal()로 쓰레드 wake up

```markdown
	!!!!!!wait()에서 리턴하기 전에 반드시 락을 재획득해야함

!!!!!!!슬립에서 깨어난 프로세스는 리턴하기 전에 락을 재획득해야한다

시그널을 받아 대기상태에서 깨어나더라도 락을 획득하지 못하면 다시 sleep 상태로 들어감

(((대기모드-sleep로 들어가기전에 락을 반납하지 않거나, 
대기모드에서 깨어난 프로세스가 자신이 반납했었던 락을 다시 획득하지 않고 
실행을 계속한다면 다양한 경쟁조건이 발생한다. 
이를 방지하기 위하여 __대기 전과 후에 각각 락의 반납과 획득을 강제__한다.)))
```

- 상태변수와 락이 둘다 있어야 한다. 둘 중 하나라도 없으면 안되는 케이스 예제있음



# 세마포어

- 락과 컨디션 변수로 모두 사용 가능

```markdown
세마포어는 정수 값을 갖는 객체로 두개의 루틴으로 조작할 수 있음
	sem_wait()과 sem_post()
세마포어는 초기값에 의해 동작이 결정되기 때문에
	사용하기 전 __!제일 먼저!__ 값을 초기화해야 함
```



# 12W 병행성 문제(넌데드락,데드락)

- Non Deadlock 비교착상태오류

  1. atomicity  violation, 원자성 위반
     - 실행하면서 원자성 안지켜짐, 공유변수 앞뒤에 락 추가해서 해결 가능
  2. order 위반, 순서 위반
     - 실행 순서 안지켜짐, 순서를 강제하는 컨디션 변수나 세마포어 사용해 해결

- Deadlock 교착상태오류

  - 각 쓰레드가 상대방이 소유한 락을 대기하면서 누구도 실행할수없는 상태

  - 네가지 조건 충족해야 함. 데드락 해결하려면 네 개 중에 하나만 해결해서 데드락 예방 prevention

    1. 상호배제 - 락획득

       해결 : lock-free 락을 아예 없애버림, wait-free 대기도 없음

    2. 점유 및 대기, 홀드앤웨잇 - 락가지고 대기

       해결 : 원자적으로 모든 락을 한번에! 획득하도록

    3. 비선점, no preemption - 강제로뺏기

       해결 : 락을 획득/점유 나타내는 코드 추가 > livelock 새로운문제, 무한반복

    4. 순환대기, 써큘러 웨잇

       해결 : 전체순서 정하거나 부분 순서 정해서 순환대기가 발생하지 않도록

  - 데드락을 avoidance회피하는 방법으로 데드락 해결도 가능함

    - 쓰레드들이 어떤 락을 획득할지 전반적인 내용 알고 쓰레드를 적절히 스케줄링하기





# 14W 파일시스템

전원꺼져도 유지되는 파일시스템을 어떻게 구조화시키고 유지 관리할까

