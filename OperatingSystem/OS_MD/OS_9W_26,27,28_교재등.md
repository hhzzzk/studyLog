[TOC]

# OS_9W_26,27,28_Concurrency,Interlude,Locks,ThreadTrace

https://www.youtube.com/watch?v=d2xRtWJ8U-Y&list=PLGgVuvaPty_13HJiJU6nhMMTDfB0thX0t

한글교재 348페이지

# 26 Concurrency - Intro(1/5)

아싀바 강의모르겟누;

```markdown
# 개요
물리적 cpu는 1개이나 가상 cpu를 이용해 여러 개의 프로그램을 동시에 실행하는 것 같은 효과 만듦
각 프로세스가 주소공간을 이용해 독립적으로 가상 메모리를 가지는 것 같은 효과
실제로는 운영체제가 물리 메모리를 여러 개의 주소 공간이 번갈아 가며 쓰게 함

## Thread
이제 배울 개념은 __쓰레드__
지금까지는 단일 PC, 프로그램 카운터로 한 순간에 하나의 명령어만 실행함
멀리 쓰레드 프로그램은 하나 이상의 실행 지점, __여러 개의 PC값을 가짐__
각 쓰레드가 프로세스와 매우 유사하지만
프로세스와 다른 점은
__쓰레드들은 주소 공간을 공유해서 동일한 값에 접근 가능함!__

## 쓰레드와 프로세스 차이
- 쓰레드의 상태는 프로세스의 상태와 매우 유사
- 쓰레드는 PC(프로그램 카운터)와 연산을 위한 레지스터 가짐
- 두 개의 쓰레드가 하나의 프로세서에서 실행 중이라면 
	실행하려는 쓰레드는 반드시 문맥 교환, context switch를 통해 실행 중인 쓰레드와 교체되어야 함

## 문맥 교환
- 쓰레드의 문맥 교환은 프로세스와 매우 유사함, 1쓰레드가 사용하던 레지스터 저장하고 2쓰레드의 레지스터를 복원
- 프로세스는 문맥교환할 때 프로세스의 상태를 프로세스 컨트롤 블록, PCB에 저장했는데
	프로세스의 쓰레드들의 상태를 저장하기 위해 한 개 이상의 쓰레드 컨트롤 블록, TCB 존재
- 프로세스 문맥교환과 쓰레드의 문맥교환에서 가장 중요한 차이는
	__쓰레드 간의 문맥 교환에서는 주소 공간을 그대로 사용한다는 것!, 
	사용하던 페이지 테이블 그대로 사용!__
	
## 스택
- 쓰레드와 프로세스의 또 다른 차이는 스택이다
- 단일 쓰레드 프로세스에서는 스택이 하나만 존재
- 멀티 쓰레드 프로세스는 각 쓰레드가 독립적으로 실행되며 쓰레드가 실행하기 위해 여러 루틴 호출 가능
- 주소 공간에는 하나의 스택이 아니라 __쓰레드마다 스택이 할당__

__멀티 쓰레드 프로세스__
- 스택에서 할당되는 변수들이나 매개변수, 리턴 값, 그외 스택에 들어가는 것들은 해당 쓰레드의 스택인 쓰레드 로컬 저장소, thread-local storage에 저장됨
-  쓰레드 로컬 저장소의 효과
	이전에는 스택과 힙이 독립적으로 확장되기 때문에 주소 공간에 공간이 없을 경우 문제 생김
	이제는 음..?음 ???
```

![image](https://user-images.githubusercontent.com/67236054/235315122-7f0f444f-d3c0-442d-a73c-610538b92165.png)



```markdown
# 26.1 왜 쓰레드를 사용하는가?
2가지 이유, 병렬 처리 parallelism과 프로그램 실행이 멈추지 않게 하기 위해서임

## 병렬 처리
매우 큰 배열을 대상으로 연산을 수행하는 프로그램의 경우 
멀티프로세서 시스템에서는 실행 속도가 매우 빨라짐

- 표준 단일 쓰레드 single-threaded 프로그램을 멀티프로세서 상에서 같은 작업을 하는 프로그램으로 변환하는 작업을 병렬화, parallelization이라고 부름
- CPU마다 하나의 쓰레드를 사용해 주어진 일을 하는 것이 최신 하드웨어에서 프로그램을 빠르게 실행하는 방법임

## 프로그램 실행이 멈추지 않도록
다른 종류의 IO를 수행하는 프로그램의 경우
IO 처리를 기다리는 시간에 프로그램(CPU) 다른 작업 수행하도록 하기 가능

쓰레드를 사용하면 진행이 막히는 것을 회피 가능함
프로그램 중 하나의 쓰레드가 대기, IO처리를 하는 동안 CPU 스케줄러가 다른 쓰레드로 전환시키기 등

쓰레딩은 하나의 프로그램 안에서 IO와 다른 작업이 중첩 overlap되도록 함

# 26.2 예제 : 쓰레드 생성과 순서
- 메인 프로그램은 mythread() 함수를 실행할 두 개의 쓰레드 생성
- 이 때 함수는 서로 다른 인자 전달받음
- 두 개의 쓰레드 생성 후 메인 쓰레드는 pthread_join()호출해 특정 쓰레드의 동작의 종료 대기함
- 이 작업은 두 번 수행됨. 쓰레드 2개가 실행되고 완료된 후에야 메인 쓰레드가 다시 실행 가능해짐
- 메인 쓰레드가 다시 실행되면 "main : end"가 출력되고 종료
> 지금까지 세 개의 쓰레드가 사용됨
__유의할 점은 도표에서 나타난 실행 순서가 유일한 방법은 아님__
그림 26.4는 쓰레드가 생성된 후 즉시 실행되는 경우임
또 먼저 쓰레드가 생성되어도 먼저 실행된다는 보장은 없음
26.5는 쓰레드2가 먼저 실행되는 경우임

## 쓰레드와 함수의 비교
쓰레드 생성은 함수의 호출과 비슷하게 생각할 수 있는데 차이를 알아둬야함
- 함수 호출에서는 함수 실행 후에 호출자, caller에게 리턴
	생성된 쓰레드는 호출자와는 별개로 실행됨
	쓰레드 생성 함수가 리턴되기 전에 쓰레드 실행하거나 이후에 실행되거나 등 여러 경우의 수 가능

- 다음에 실행된 쓰레드는 OS 스케줄러에 의해 결정
	특정 순간에 어떤 쓰레드가 실행되지 알아내기는 어렵..

```

![image](https://user-images.githubusercontent.com/67236054/235315898-3063e5c1-5793-4cec-9cd8-da195e4c135f.png)



```markdown
# 26.3 쓰레드 어려운 이유 만들어줌 : 데이터의 공유
그림 26.6 참고
## 전역 공유 변수를 갱신하는 두 개의 쓰레드 예시
357페이지
천만 번 (le7)

기대한 값은 이천만번임. 그러나 실제는 다름 왜?

# 26.4 왜일까? 문제의 핵심 : 제어 없는 스케줄링
문제의 원인은 counter 갱신을 위해 컴파일러가 생성한 코드의 실행순서에 있다.
카운터에 단순히 1을 더하려고 할때 코드는
LD, ADD, ST의 세 단계로 구성됨

mov  0x8049alc,  %eax 
add $0x1,  %eax 
mov  응eax,  0x8049alc

카운터 변수 위치 주소가 위의 메모리 주소임

```

![image](https://user-images.githubusercontent.com/67236054/235364136-6417cf36-a626-4382-9194-b3cd6177302e.png)



```markdown
임계영역이 카운터에 1더하는 부분이고 코드상으로는 3단계인 부분임
쓰레드 1이 임계영역 코드 부분에 진입해서 레지스터 값을 1증가시키고
__타이머 인터럽트가 걸려서 
운영체제가 실행 중인 쓰레드의 PC값과 eax를 포함한 레지스터 등 현재 상태를 쓰레드의 TCB에 저장__
쓰레드는 개별적으로 쓰레드 전용 레지스터를 가지고 있어
쓰레드2에서 복원하고 다시 1 증가시켜 결국 51이 유지됨
결과적으로 52를 기대했으나 실제로는 51이 됨

# 경쟁조건 Race condition / data race
명령어의 실행 순서에 따라 결과가 달라지는 상황

- 문맥교환이 잘못된 타이밍에 실행되거나 하면 잘못되 결과 얻음
- 경쟁 조건에 처한 경우 실행할 때마다 다른 결과값 나옴
- 즉 __비결정적, indeterminte__인 결과를 얻음

# 임계 영역, critical section
멀티 쓰레드가 같은 코드를 실행할 때 경쟁조건이 발생한다.
이러한 코드 부분을 __임계 영역__이라고 함

- 공유변수/공유자원을 접근하고 
	하나 이상의 쓰레드에서 동시에 실행되면 안되는 코드를 임계 영역이라고 부름

# 상호 배체 mutual exclusion
하나의 쓰레드가 임계 영역 내의 코드를 실행 중일 때는 다른 쓰레드가 실행할 수 없도록 보장해줌
임계영역 코드에서 필요한 것!
```



```markdown
# 26.5 임계영역 해결법 하나 알려줌
강력한 명령어 한 개로 의도한 동작을 수행해 인터럽트 발생 가능성을 원천적으로 차단하는 방법

즉 원자적으로 실행되는 것을 보장하는 명령어의 사용.
원자성을 보장한다는 것은 명령어 수행 도중에 인터럽트가 발생하지 않음
인터럽트가 발생했다는 것은 명령어가 실행이 안되었거나 실행이 종료된 후라는 것
그 외의 중간상태가 없다는 것이 원자적 atomic하다는 것이다.

358페이지
```



강의

```markdown

```



# 26 Concurrency - Intro(2) (2/5)

```markdown
# 강의
원노트 Thread Trace 3개

조인하면 블락 상태됨
상태보고 블락 안되는 경우도 있음

# 1
- create하면 쓰레드는 ready 상태
- 메인에서 조인하면 메인은 sleep, blocked 상태됨
- 레디 상태였던 쓰레드 1이 run 상태되서 실행하고
- 끝나면 리턴하는데 그럼 블락이였던 메인이 레디상태가 되고 다시 run 상태가 됨
- 그리고 또 메인에서 조인해서 쓰레드2가 런상태됨
- 메인에서 조인하면 블락상태됨

# 2
- 다른 건 __create 하면 바로 쓰레드가 실행__됨, 레디갔다가 런까지 다 하고 리턴함
- 즉 조인해도 메인이 블락안됨. 이미 쓰레드가 끝났기 때문에 바로 리턴함
- 3번도 유사함
```

![image](https://github.com/hhzzzk/capstone-2023-20/assets/67236054/954a16c8-7ad0-4a9a-8f47-f8da3e6b2c6c)



# 26 Concurrency - Race Condition (3/5)

```markdown
강의
마이쓰레드에서 카운터 증가시키는 일을 함
카운터가 전역변수임
쓰레드는 2개 생성
같은 전역변수 사용한다.

마이쓰레드 안의 i는 지역변수라 스택에 배치

카운터는 데이터 영역에 배치
코드는 쓰레드 둘다 공유

__스택과 쓰레드컨트롤 블록은 쓰레드마다 있다.__

__i는 지역변수라 각 쓰레드마다 존재__

사람이 보기에는 총 이천만원 카운터가 증가될 것이라고 생각.

그러나 실제로 아님.
결과가 비결정적임

26.4 왜 이런 결과 생겼나?

카운터 증가시키는 한줄 코드 기계어로는 3단계다
LD, ADD, ST

26.4의 케이스
ST못했는데 인터럽트 걸려서 문맥교환함
쓰레드2로 감
또 인터럽트 문맥교환
쓰레드1로 감
>>> 중간에 끊기고 복원하는 과정에서 엉킴, 원하던 결과 안나옴

```

![image](https://github.com/hhzzzk/capstone-2023-20/assets/67236054/3aa3dd37-3449-41ae-94a3-0fdb338666c4)



![image](https://github.com/hhzzzk/capstone-2023-20/assets/67236054/5fad2c43-7873-467b-a287-435f249c3439)



26.5 결론, atomic하게 만들자

![image](https://github.com/hhzzzk/capstone-2023-20/assets/67236054/ae144aea-51fb-441b-ae1d-c0afcb6fbcf1)





# 26 Concurrency - Multi Processing(4/5)

사람이 cpu에게 일 시키려고 함

먼저 cpu는 메모리에 일을 탑재, 로딩함, 일 여러개 가능

사람은 여러개의 일을 동시에 하길 바람

cpu는 pc를 이용해 문맥교환을 굉장히 빠르게 해서 보기에 동시에 일 진행하는 것처럼 보일 수 있음

병행적으로 실행시키기 가능하다, concurrency



일을 어떻게 메모리에 넣을 것인가

각 실행흐름마다 스택 필요하고, 교환을 위해 컨트롤 블록도 각각 필요함

io관련 일도 할 수 있어서 io핸들링용 테이블도 필요함 각각

코드, 데이터, 힙도 필요. 각각 주소공간이 있음

각 프로세스 형성됨



프로세스 만드는 방법은 fork만 존재, 포크해서 프로세스 만든다.

exec라는 명령을 통해 ..로딩함



실행흐름을 여러개 만드는데 포크를 이용해서 만들때 

이럴 때 일을 어떻게 만들 것인가

355



82페이지

```markdown
# 프로세스 API

PID는 프로세스 식별자

# fork()
운영체제는 프로새스 생성을 위해 이 시스템 콜을 제공함
생성된 프로세스가 호출한 프로세스의 복사본이다.
자식 프로세스는 자신의 주소 공간, 레지스터, pc값 가짐. 완전히 부모프로세스와 같지는 않음
    fork()로부터 부모 프로세스는 생성된 자식 프로세스의 PID 리턴
    자식 프로세스는 0을 리턴받음
# wait()
부모 프로세스가 자식 프로세스의 종료를 대기함
자식 프로세스가 종료되면 wait()을 리턴함


여기서부터 강의나옴
# exec()
자기 자신이 아닌 다른 프로그램을 실행해야 할 때 사용
자신의 복사본이 아닌 다른 프로그램을 실행해야 할 경우 사용함

자식 프로세스는 wc 프로그램을 실행하기 위해 execvp() 시스템 콜 호출함, 19줄

실행 파일의 이름과 약간의 인자가 주어지면 해당 실행 파일의 코드와 정적 데이터를 읽어
현재 실행 중인 프로세스의 코드 세그멘트와 정적 데이터 부분을 덮어 쓴다.
힙과 스택 및 프로그램 다른 주소 공간들도 새로운 프로그램의 실행을 위해 다시 초기화

그리고 운영체제는 프로세스의 argv와 같은 인자를 전달해 프로그램을 실행시킴
__새로운 프로세스를 생성하는 것은 아님__
현재 실행 중인 프로그램(pc)을 다른 실행 중인 프로그램(wc)으로 대체하는 것이다.

자식 프로세스가 exec() 호출 후에는 p3.c는 전혀 실행되지 안흔ㄴ 것처럼 보임
exec() 시스템 콜이 성공하면 p3.c는 절대 리턴하지 않음

87페이지
```

![image](https://github.com/hhzzzk/capstone-2023-20/assets/67236054/9fb170c0-4cde-4e57-87b5-9ee1eb74a1f9)

![image](https://github.com/hhzzzk/capstone-2023-20/assets/67236054/4d26444e-6ba9-4f99-af7b-0ae6a47b8ce9)



# 26 Concurrency - Multi Threading (5/5)



음..프로세스로 만드냐 쓰레드로 만드냐 차이

exec로 탑재, 로딩





# 27 Thread API

27.1 쓰레드 생성

p에 쓰레드 식별자, 널에는 속성 알아서 디폴트 값으로 생성, 함수 주소=함수이름, args 전달, 구조체로 2개 전달

t1을 위한 스택에 args에 포인터 전달, 자기 지역변수에 그 포인터값 저장됨

포인터를 통해 남의 스택에 접근한다는 것!

![image](https://github.com/hhzzzk/capstone-2023-20/assets/67236054/3c38b233-a2a1-4353-b582-54ad02505e4e)



27.2 join

리턴하는데 rvals라는 값을 리턴



27.3 int로 씀



# 28 Locks_book summery

376페이지

지금까지 한 것

- 병행성
- 병행 프로그램의 문제들
- 여러 개의 명령어들을 원자적으로 실행해보고 싶지만 단일 프로세서의 인터럽트, 또는 멀티 쓰레드를 여러 프로세서에 병행성하려고 해서 그렇게 할 수 없었음
- 여기서는 락을 이용해 이 문제를 직접적으로 해결해보자
- 프로그래머들은 소스 코드의 임계 영역을 락으로 둘러서 그 임계 영역이 마치 하나의 원자 단위 명령어인 것처럼 실행되도록 한다.

```markdown
# 28.1 락 : 기본 개념
- 락은 일종의 변수임
- 락을 사용하기 위해서는 락 변수를 먼저 선언해야 함
- 락 변수는 락의 상태 나타냄
- 락의 사용 가능 available 상태(unlocked/free) 또는 사용 중 acquired 상태 둘 중 하나의 상태 가짐
- 사용 가능 상태는 어떤 쓰레드도 락을 가지고 있지 않음
- 사용 중 상태는 임계 영역에서 정확히 하나의 쓰레드가 락을 획득한 상태임
      (이 락 자료 구조에 락을 보유한 쓰레드에 대한 정보나 
      락을 대기하는 쓰레드들에 대한 정보를 저장할 수도 있다.
      물론, 락 사용자는 이러한 정보를 알 수 없다.)
      
# lock()
락 획득을 시도함
- 만약 어떤 쓰레드도 락을 가지고 있지 않으면 그 쓰레드는 락을 획득하여 임계영역으로 진입
- 이렇게 락을 획득한 쓰레드를 락 소유자 owner라고 함
- 락이 사용 중인 동안에서 lock() 함수는 리턴하지 않는다.
- 락을 소유한 쓰레드가 임계 영역에 존재하는 상태에서는 다른 쓰레드들이 임계 영역으로 진입할 수 없음

# unlock()
락 소유자가 unlock()을 호출하면 락은 다시 사용가능한 상태가 됨
- 어떤 쓰레드도 락을 대기하고 있지 않았다면 == 어떤 쓰레드도 lock()을 호출해 멈춰있던 상태가 아니라면
	락의 상태는 사용 가능으로 유지됨
- 대기 중인 쓰레드가 있었다면(락호출해 멈춰있던 쓰레드가 있었다면)
	락의 상태가 변경되었다는 것을 인지하고 락을 획득해 임계 영역으로 지입함
	
>>>
락은 프로그래머에게 스케줄링에 대한 최소한의 제어권을 제공함
일반적으로 쓰레드는 프로그래머가 생성하고 운영체제가 제어함
락은 쓰레드에 대한 제어권을 일부 받을 수 있게 해줌
락으로 코드를 감싸서 프로그래머는 그 코드 내에서는 하나의 쓰레드만 동작하도록 보장 가능

```



```markdown
# 28.2 Pthread Lock
쓰레드 간에 상호 배체 mutual exclusion 기능을 제공하기 때문에 POSIX 라이브러리는 락을 mutex라고 함

상호배제는 한 쓰레드가 임계 영역 내에 있다면
이 쓰레드의 동작이 끝날 때까지 다른 쓰레드가 임계 영역에 들어올 수 없도록 제한한다는 의미
- 래퍼를 사용해 락과 언락 시에 에러를 확인함

- 락/언락 함수에 락의 변수명을 인자로 전달함
	다른 변수를 보호하기 위해 다른 락을 사용할 수도 있기 때문임
__coarse-grained 락 사용 전략__은 하나의 락으로 모든 임계 영역들을 보호
__fine-grained 락 사용 전략__은 다수의 쓰레드가 서로 다른 락으로 보호된 코드를 실행가능

# 28.3 락의 구현
어떤 하드웨어와 운영체제의 도움을 받아서 구현할까?

# 28.4 락의 평가
락의 정상동작 여부 판단을 위한 평가기준 3가지
__상호 배제를 제대로 지원하는가__,
__공정성__, 쓰레드들이 락 획득에 대한 공정한 기회가 주어지는가, 
	락을 전혀 얻지 못하는 starve 굶는 상황 발생하는가?
__성능__, 락 사용 시간적 오버헤드를 평가
	1. 경쟁이 전혀 없는 경우의 성능 >>> 하나의 쓰레드가 실행 중 락을 획득/해제하는 과정의 성능
	2. 여러 쓰레드가 단일 cpu상에서 락을 획득하려고 경쟁할 때의 성능
	3. 멀티 cpu 상황에서 락 경쟁 시의 성능
	
# 28.5 인터럽트 제어
단일 프로세스 시스템에서는 상호배제 지원을 위해 
임계 영역 내에서는 아예 인터럽트를 비활성화 하는 방법 사용함


__임계 영역 진입 전에 하드웨어 명령어를 사용해 인터럽트 비활성화하는 방법__
> 임계 영역 내의 명령어 원자적으로 실행 가능해짐
> 모든 동작 후 다시 하드웨어 명령어를 통해 인터럽트 활성화해서 정상화
## 장점
단순함
인터럽트가 발생하지 않으면 코드 실행 중에 다른 쓰레드가 중간에 끼어들지 않는것 보장가능함
## 단점
1. 인터럽트 비활성화 요청은 privileged 특권 명령이라 요청한 쓰레드에게 허가를 해줘야함
	허가를 해줘야해서 특권 명령을 다른 목적으로 사용하지 않음을 신뢰가능해야 함
	__greedy 프로그램 예시__
	탐욕기법 사용한 프로그램이 시작과 동시에 락을 호출해 프로세서를 독점해 사용가능
	더해서 악의적인 프로그램이 락을 호출하고 무한 반복문에 들어가면
	운영체제는 시스템의 제어권을 다시 얻을 수가 없음
	>>> __응용 프로그램을 매우 신뢰해야 한다는 문제!!!__
	
2. 멀티프로세서에서는 적용 불가능
	여러 쓰레드가 여러 cpu에서 실행 중이면
	각 쓰레드가 동일한 임계 영역을 진입하려고 시도할 수 있음
	이 때 특정 프로세서에서의 인터럽트 비활성화는 
	다른 프로세서에서 실행 중인 프로그램에 영향 없음
	>>> 즉 임계영역에 진입가능함

3. 중요한 인터럽트의 시점을 놓칠 수 있음
4. 비효율적임, 인터럽트 비활성화시키는 코드들은 느리게 실행되는 편

>>>
상호 배제를 위해 인터럽트 비활성화하는 방법은 제한된 범위에서만 사용되어야 함
예시
	운영체제 내부에서는 신뢰라는 문제가 사라지기 때문에
	용인 가능함

```



```markdown
# 28.6 락 구현 : 실패한 시도 오직 LD/ST 명령어만 사용하기
락을 구현하는데 인터럽트 비활성화는 별로고
락 구현의 기본 아이디어를 파악하고 LD, ST 명령어만으로는 락의 구현이 불가능한 이유 알기
```

![image](https://user-images.githubusercontent.com/67236054/235367415-0646d38b-a5fe-4dbc-a071-e744cae4a802.png)

```markdown
기본 아이디어는 간단한 변수 flag를 사용해 쓰레드가 락을 획득하였는가 표시

- 임계 영역에 진입하는 첫 스레드가 락()을 호출해 플래그 값을 검사
- 플래그 값을 1로 설정해 이 쓰레드가 락을 보유 hold하고 있다고 표시
- 임계 영역에서 나오면 쓰레드가 언락()을 호출해 플래그 값 초기화, 더이상 락 미보유 표시

__만약 쓰레드1이 임계 영역 내에 있을 때 다른 쓰레드가 락()호출하면__
그 쓰레드는 while문으로 spin-wait하며 처음 쓰레드가 언락()호출해 플래그 초기화를 기다림
쓰레드1이 플래그 초기화하면 대기하던 쓰레드는 while문 빠져나와 플래그 1로 설정하고 임계영역 진입

# 이 코드의 2가지 문제
1. 제대로 작동하는가? correctness
2. 성능

1 > 인터럽트 때문에 두 쓰레드 모두 플래그 1로 설정하는 경우 발생 가능, 그럼 임계 영역에 두 쓰레드 전부 진입 가능
상호 배제 제공 실패!!! 작동 실패
2 > 사용 중인 락을 대기하는 방법에 문제 있음
spin-wait 방법은 다른 쓰레드가 락을 해제할 때까지 시간 낭비, 단일 프로세서에서는 엄청난 손해!
문맥교환전까지는 락을 소유한 쓰레드조차 실행할 수 없음
```

![image](https://user-images.githubusercontent.com/67236054/235367667-68ab236e-3f6b-42a1-9977-f532047dad33.png)





```markdown
# 28.7 스핀 락 구현 : test and set 사용
인터럽트 비활성화 방법 > 실패
LD,ST 사용법 > 실패

하드웨어를 이용한 가장 기본적인 방법
__test-and-set 명령어 또는 원자적 교체 atomic exchane 명령어 이용!__

- ptr이 가리키던 예전 값을 반환하고 동시에 new에 새로운 값 저장함
- 중요한건 __해당 동작들이 원자적으로 수행됨__!

```

![image](https://user-images.githubusercontent.com/67236054/235367932-68f8d7bd-4e5e-4ceb-ade9-796d3194f9ec.png)



![image](https://user-images.githubusercontent.com/67236054/235368015-616bac02-24f9-45b3-9e08-164ed9e04c39.png)

```markdown
처음 쓰레드가 락()호출하고 다른 어떤 쓰레드도 현재 락 미보유 상태임, 현재 플래그 0
이 쓰레드가 TestAndSet(flag,1) 호출하면 flag의 이전값인 0을 반환함
flag값을 검사한 쓰레드는 while 문에서 회전하지 않고 락을 획득
이 쓰레드는 flag 값을 1로 설정해 락 보유르 표시함
임계 영역 동작 끝나면 언락() 호출해 flag = 0 변경

# 다른 경우
처음 쓰레드가 락을 획득해 flag가 1인 상태
두번째 쓰레드가 락() 호출해 테스트엔셋 루틴 실행
루틴은 0을 반환! 플래그 값 검사한 쓰레드는 while 문에서 회전하지 않고 락을 획득
이번에는 테스트~()는 이미 락을 다른 쓰레드가 보유하고 있기 때문에
예전값으로 1을 반환하는 동시에 flag 값을 다시 1로 설정함

락을 보유하고 있는 쓰레드가 있는 한 테스트는 계속 1을 반환
두번째 쓰레드는 락이 해제될 때까지 계속 while문 반복
락 보유 중인 쓰레드로 플래그 0이 되면 
대기 중인 두번째 쓰레드가 테스트 호출해서 0받고 원자적으로 값 1로 변경
락 획득! 임계 영역 진입

>>>
락의 값을 검사하고 새로운 값으로 설정하는 동작을 원자적 연산으로 만들어서
락을 구현, 하나의 쓰레드가 락을 획득 가능함! 정상 작동하는 상호 배체 함수!

락을 획득할 때까지 cpu 사이클을 소모하면서 회전함
단일 프로세서에서 이 방식 사용하려면 preemptive 선점형 스케줄러 사용함
선점형은 필요에 따라 다른 쓰레드가 실행되도록 타이머를 통해 쓰레드에 인터럽트 발생시키기 가능
선점형이 아니면 단일 cpu에서 스핀 락의 사용은 불가능
	while문을 회전하며 대기하는 쓰레드가 cpu를 무한독점하기 때문임
	
	
```



# 28 Locks(1/7)

https://www.youtube.com/watch?v=Y4eIgqKTtZs&list=PLGgVuvaPty_2VXqqnH2s7ov8OfYP9RC59

하나의 명령어가 코드상으로 3줄인데 add까지 하고 st하기 전에 인터럽트 걸리면서 기대한 효과 안나옴

결국 atomic하게 할 필요 있음

그래서 사용하는게 lock임

임계영역 진입할때 한 쓰레드가 락을 걸면 다른 쓰레드는 그 영역 진입 불가능하고 기다림

언락되면 기다리던 쓰레드가 임계영역 진입가능해짐



critical section이 임계영역

래퍼를 만들어서 락, 언락할 때 에러처리함, 예제 프로그램에선는 생략

---

```
28.4 락 평가
```

상호배제, mutual exclusion한가

deadlock 걸리면 안됨, 락을 잘못 만든거임, 최소한 하나의 쓰레드는 진행이 되어야함

starvation-free, 어떤 쓰레드는 계속해서 굶는 경우는 없어야 함

락 평가의 5가지 기준

![image](https://user-images.githubusercontent.com/67236054/235421739-9c797458-daa2-455c-af8e-aff76265db4c.png)

---

```
28.5__ Controlling Interrupts__
```

락을 건다는게 인터럽트를 끈다는 것이고 언락은 인터럽트를 킨다는 의미

상호배제는 성공, 원하던 결과 얻음

![image](https://user-images.githubusercontent.com/67236054/235422069-67402aa2-0bdb-404a-aaf0-1c079886dd1f.png)

cpu를 너무 많이 써서 time out 걸고 싶은데 이 방법에서는 그럴 수가 없음

타임아웃이 중요함, 타임아웃도 걸 수가 없다

((__타임아웃__되면 run에서 레디로 변함))

락과 언락은 라이브러리에 있음 링킹이 돼서 코드에 들어있긴 함

언락이 되면 타임아웃 걸릴 수 있어서 for문 끝나는 곳(언락 다음)에서 타임아웃 걸릴 수 있음



__단점__

- __특권 명령__이라 privileged 명령이라 기본적으로 커널에서만 사용가능한 건데 유저프로그램에서 사용가능하게 하려면 신뢰가능해야 함

- __멀티프로세서__ 환경이면 cpu가 여러개라는 의미인데

  cpu1에서 락을 걸면 cpu2는 여전히 인터럽트 가능한 상태, 막을 방법이 없음, 상호배제가 안된다.

- 중요한 인터럽트를 놓칠 수 있음. 임계영역이 굉장히 길어지거나 하면 특히

- 인터럽트 컨트롤하는 명령은 느린 편, 그래서 시간 소요됨

> 멀티프로세서 환경에서는 작동하지 않는다는 단점이 젤 크다



# 28 Locks-A Failed Atempt (2/7)

```
28.6 A failed attempt :  LD, ST만 사용하기
```

락 안에 flag 있고 flag가 0이면 사용 가능, flag 1이면 사용중

먼저 락에 걸린 애는 flag 1로 세팅하고 

뒤에 온 쓰레드는 while 루프에 걸려서 spin-wait()함 == busy waiting 라고 도 함

​	while 루프 돌면서 cpu 사용중임

![image](https://user-images.githubusercontent.com/67236054/235424466-7f2dfd97-8bf2-443e-8c9c-e6281b915aad.png)

---

인터럽트 걸리기 가능한 상태임

락은 이미 걸린 상태면 계속  while 루프 돌면서 spin함, 타임아웃 걸릴때까지 계속 spin

((위에 락, 언락 코드 부분은 라이브러리 부분))



![image](https://user-images.githubusercontent.com/67236054/235424896-b0caecfb-c457-4943-a424-de4490c54c9c.png)

결과적으로 +2가 되면서 원하던 작업 성공함

멀티프로세서에서도 사용가능한

크리티컬섹션 사이에 인터럽트 걸리기 가능

그러나 크리티컬 섹션에 쓰레드가 여러개 동시에 들어갈 수 없음!, 상호배제 상태

__>>> 크리티컬 섹션이 쪼개지기는 함 인터럽트에 의해서 그러나 상호배제 상태 유지__

---

LD, ST 사이가 atomic 하지는 않아서 사이에 인터럽트가 걸릴 수 있는 상태라는 것

즉 다른 케이스에서 (실패하는 케이스)

쓰레드1에서 test하고 set은 못했는데 그 사이에 재수없게 인터럽트 걸림

그래서 쓰레드2가 test하니까 아직 set 안돼서 set까지 하고 크리티컬 진입, 인터럽트 또 걸림

쓰레드1에서는 이제 set 할 차례임, 걍 set 해버림 그렇게 크리티컬 진입해벌임 오우 노우~

두 개 다 크리티컬 진입해버림~ 상호 배제 실패...

결과적으로 +1만 됐다, 락이 제대로 기능하지 못함

경쟁조건 발생

![image](https://user-images.githubusercontent.com/67236054/235425386-86bb6a34-cc45-4ea1-8019-afc3e6bfed1c.png)

# 28-3 Test-and-Set(3,4/7)

로드와 스토어가 동시에 일어남

로드하면서 set 바로 함



# 28 Locks-Working Spin Lock (5/7)

인터럽트 컨트롤하면 멀티프로세서에서는 작동하지 않음

테스트앤셋을 하면 어떤 경우에서는 상호배제안됨, 결과적으로 둘 다 실패



앞으로 할 것들

스핀락 구현하는데 테스트앤셋과 유사한 건데 9와 10

11은 스핀락은 공정성, fairness가 ?한데 공정한것

11까지는 다 결국 while루프를 도는 스핀임, cpu를 계속소모, 낭비라서

12부터는 spin을 줄여보자

13은 cpu를 양보, yield하자는 거고, 양보를 통해 스스로 레디 상태로 빠지는 거고

14은 sleep은 blocked상태로 바꾸고 나중에 누가 깨우면 레디상태로 바꾸는

![image](https://user-images.githubusercontent.com/67236054/235426133-9b68fad5-2e8c-4787-ad9d-390d248bf83b.png)

```
28.7 spin-locks
```

![image](https://user-images.githubusercontent.com/67236054/235427179-da16184d-82ff-4a94-8a3c-5dc1fc44929f.png)

x86에는 실제로 xchange라는 명령어 있음

LD,ST를 합성한 명령어임

메모리에 값을 읽어옴과 동시에 셋하는 atomic하게 이뤄지는 거임

old_ptr이 메모리 값이고 가져와서 테스트하고 새로운 값으로 셋

28.6번 첫시도에서는 락할때와 언락할때로 테스트앤셋이 분리되어있었는데

이제는 하나의 명령어에서 하자

/

위에 실패했던게 테스트와 셋이 분리되었다가 그 사이에 인터럽트 걸리면서 실패한건데

그런 경우 해결됨, 테스트와 셋을 묶었다

![image](https://user-images.githubusercontent.com/67236054/235427679-79618d17-d6ed-44d6-9af6-a954b3616e0b.png)

__평가__

상호 배제됨

데드락 안걸림

starvation-free 하지는 않음

페어하지 않음

> 쓸만하다...걍 

![image](https://user-images.githubusercontent.com/67236054/235427906-9df7744f-2c52-4ddd-ad7b-591d2bf5a3ec.png)

스케줄러가 락과는 무관하게 작동해서 그럼





# 28 Locks-Working Spin Lock(2) (6/7)

파라미터 3개

메모리에서 LD하는데 그 값이 찾던 값(여기서는 0, 즉 아무도 락이 아닐때)이면 새로운 값(1)으로 셋

플래그 1되면 while루프 빠져나옴

아니라 flag가 1이면 기대한값 0이 아니므로 ptr, flag값 유지, 리턴 오리지널 1, 그래서 while 루프 못빠져나옴

Compare앤스왑 함수로 테스트 앤 셋을 한번에 한다

테스트앤셋과 유사



![image](https://user-images.githubusercontent.com/67236054/235428329-a57c19d5-34aa-4ea2-82c8-ad66d1e2d4d2.png)

---

로드링크드할 때 첫번째로 store해서 쓰는 value 일때 쓴다.  아니면 fail, 업데이트안함



로드링크드 > 메모리의 값을 로드, LD하는데 해당 주소 기억

스토어컨디션 > 로드하면서 읽은 이후에 첫번째 Store쓰는 거라면 씀, 아니면 업뎃안함

성공하면 1아니면 0 리턴함



![image](https://user-images.githubusercontent.com/67236054/235428601-6e72da6f-7a4f-426a-af7d-67e8b7973c0d.png)



락만들기

flag에서 0을 읽으면 while 루프 빠져나옴, flag=1이면 누가 락을 건 것이라 못빠져나옴

빠져나왔다면 flag = 0임

 5줄에서 이제 내가 락을 걸겠다, 1로 세팅하겠다, 

근데 로드링크드하고 최초로 쓰는 경우 성공,

5줄 위아래에 인터럽트 걸리기 가능





![image](https://user-images.githubusercontent.com/67236054/235429865-f70470ef-4615-48be-883f-efa6519ee928.png)



## 28 Locks-Fetch And Add(7/7)

스핀락의 3개는 다 언페어함, 페어한 경우

```
28.11 Fetch-And-Add
```

lock는 티켓을 받아와서 turn, 순서가 내 차례가 될때까지 while, spin한다

turn을 +1, 증가시키는게 unlock()



락을 거는게 티켓뽑은거임, 그리고 차례 올때까지 spin

![image](https://user-images.githubusercontent.com/67236054/236799763-9693312e-2ce4-4e99-a571-1d9e858bdb6c.png)

```
평가
```

![image](https://user-images.githubusercontent.com/67236054/236799973-98c6f24a-10b6-4309-8e94-66907a95132e.png)











# 퀴즈

```

static volatile int counter = 0;
void *mythread(void *arg) {
	int i;
	printf("%s: begin\n", (char *)arg);
	for (i = 0; i < 1e7; i++) {
		counter = counter + 1;
	}
	printf("%s: done\n", (char *)arg);
	return NULL;
}

int main() {
	pthread_t T1;
	printf("main: begin [counter = %d]\n", counter); Pthread_create(&T1, NULL, mythread, "A"); mythread((void *)"main");
	// join waits for the threads to finish
	Pthread_join(T1, NULL);
	printf("main: done\n [counter: %d]\n", counter);
	return 0;
}
```

```markdown
# mythread() 함수는 쓰레드를 만들 때만 사용되어야 하는가?
예, 일반적으로 mythread() 함수는 쓰레드를 생성할 때 사용됩니다. mythread() 함수는 쓰레드가 실행하는 작업을 정의하고, 해당 작업이 독립적으로 실행되어야 할 때 사용됩니다.

그러나 주어진 코드에서는 mythread() 함수가 쓰레드 생성 이외에도 main() 함수에서 직접 호출되고 있습니다. 따라서 mythread((void *)"main"); 코드를 통해 mythread() 함수를 main() 함수 내에서 일반적인 함수 호출로 사용하고 있습니다.

이 경우, mythread() 함수는 단순히 main() 함수의 일부로 실행되며, 멀티스레딩의 이점을 활용하지 않습니다. 실제로 main() 함수에서 mythread() 함수를 호출할 때는 쓰레드를 생성하지 않고, 일반적인 함수 호출로 실행됩니다. 따라서 mythread() 함수는 별도의 스레드로 실행되지 않고, main() 함수의 흐름에 따라 실행됩니다.

일반적으로 멀티스레딩을 사용하려면 pthread_create() 함수를 사용하여 쓰레드를 생성하고, mythread() 함수를 쓰레드에서 실행하도록 지정해야 합니다.

> 해설, 코드에서는 마이쓰레드 함수를 단순히 함수처럼 사용하기는했으나 이는 멀티쓰레딩의 이점을 활용하지 못하는 방식임. 그렇게 사용한 마이쓰레드 함수는 별도의 쓰레드로 실행되지 않음.



# main 쓰레드에서 호출한 mythread()는 counter를 항상 1e7(10,000,000) 만큼 증가 시키지만 T1에서 실행한 mythread()는 그에 못미치는 경우도 있을 것이며 실행할 때 마다 못 미치는 정도가 다르다.

둘 다 cnt 동일하게 증가시킴

# main 쓰레드가 T1 쓰레드를 생성 했으므로  Line 19가 없어도 T1이 종료한 후에 Line 20을 실행한다.
주어진 코드에서 T1 쓰레드는 pthread_create() 함수를 통해 생성됩니다. pthread_create() 함수는 새로운 쓰레드를 생성하고 해당 쓰레드에서 실행할 함수를 지정합니다. pthread_create() 함수는 호출되면 바로 반환되며, 생성된 쓰레드와 main 쓰레드는 동시에 실행됩니다.

따라서 T1 쓰레드가 생성되고 pthread_create() 함수가 반환된 시점에서 T1 쓰레드와 main 쓰레드는 병렬적으로 실행됩니다. 그리고 T1 쓰레드의 실행이 완료되기 전에 main 쓰레드가 printf() 함수를 통해 Line 20을 실행하는 것은 보장되지 않습니다. 따라서 Line 20은 T1 쓰레드의 실행과 상관없이 main 쓰레드에서 즉시 실행될 수 있습니다.

따라서 주어진 문장은 틀린 내용을 포함하고 있습니다. T1 쓰레드의 실행 완료를 보장받기 위해서는 pthread_join() 함수를 사용하여 T1 쓰레드가 종료될 때까지 main 쓰레드를 대기시켜야 합니다. pthread_join() 함수를 사용하면 T1 쓰레드의 실행이 완료될 때까지 main 쓰레드가 대기하게 되므로, T1 쓰레드가 종료한 후에 Line 20이 실행될 것입니다.
```





레이스 컨디션

```
static volatile int counter = 0; 
#define loop... //
void *worker A(void *arg) { 
  int i;
  for (i = 0; i < loop; i++) {
  							// LD (counter); A1
  counter = counter + 2;
  							// ST (counter); A3
  }
  return NULL;
}

void *worker B(void *arg) {
  int i;
  for (i = 0; i < loop; i++) {
  	AtomicIncrement(&counter,1);
  	// counter+1 atomicoc
  }
  return NULL;
}
 
int main(int argc, char *argv[]) {
  pthread_t T1;
  Pthread_create(&T1, NULL, workerB, NULL);
  workerA(NULL);
  Pthread_join(T1, NULL);
  printf("counter = %d)\n",counter);
  return 0;
}


루프3일때
최소인 경우는 에이에서 로드하다가 인터럽트 걸리고
b 작업을 3을 더하고 인터럽트 되면
에이에서 다시 add 부터 할텐데 교환되면서 b에서 작업한게 날라감
//

메인 함수 설명

create로 T1 쓰레드 생성, workerB 실행함
현재 쓰레드에서 workerA 실행
join을 통해 t1의 종료를 대기함

```

![image](https://github.com/hhzzzk/capstone-2023-20/assets/67236054/0534a215-0707-44f1-b444-82fe81c8aa64)



![image](https://github.com/hhzzzk/capstone-2023-20/assets/67236054/8182280b-ac8c-428f-9f17-0d74f01aa1d6)













```
HW
static volatile int counter = 0; 
#define loop... //
void "worker A(void *arg) {
	int i;
	for (i=0; i < loop; i++) {
	counter = counter + 2; 
	// atomic 하지 않음, LD,ADD,ST의 세 단계 사이에 인터럽트 걸릴 수 있음
	}
	return NULL;
}

void "workerB(void *arg) {
	int i;
	for (i = 0; i < loop; i++) {
	counter = counter + 1; 
	// atomic 하지 않음, LD,ADD,ST의 세 단계 사이에 인터럽트 걸릴 수 있음
	}
	return NULL;
}

int main(int argc, char *argv[]) {
	pthread_t T1;
	Pthread_create(&T1, NULL, workerB, NULL);
	workerA(NULL);
	Pthread_join(T1, NULL);
	printf("counter = %d)\n",counter);
	return 0;
}
//
A1에서 인터럽트
workerB를 세바퀴 실행, counter = 3, 인터럽트
A2를 하면 2가 됨. counter=2로 A3까지 실행 후 인터럽트
B1을 하면 T1쓰레드의 TCB에 2가 저장, 그리고 인터럽트
workerA를 세바퀴 실행 후 counter=8. 그리고 인터럽트.
T1 쓰레드의 TCB에는 2가 저장되어 있으므로 마지막 1을 더하고 종료하면
counter을 3이 된다.
```



```markdown
# critical section이 긴 경우에 Dead lock이 걸릴 수 있다.
Critical section이 긴 경우에 Deadlock이 발생할 가능성은 있지만, 이는 critical section의 길이 자체가 직접적인 원인은 아닙니다. Deadlock은 상호 배제, 점유와 대기, 비선점, 순환 대기 등의 4가지 조건이 동시에 충족될 때 발생합니다. Critical section이 길더라도 이러한 조건들이 충족되지 않는다면 Deadlock은 발생하지 않습니다. 따라서, critical section의 길이가 Deadlock 발생 여부를 결정하는 것은 아닙니다.

특권 명령을 사용하지 않는 구현에서 CPU가 1개인 경우, critical section의 길이를 짧게 하는 것이 CPU 낭비를 줄일 수 있다는 주장은 맞을 수 있습니다. 이는 다른 스레드가 critical section에 접근하기 전까지 해당 CPU를 계속해서 사용할 수 있기 때문입니다.

그러나 이 주장이 틀린 이유는, CPU 낭비를 줄이기 위해서 critical section을 짧게 하는 것은 Deadlock의 가능성을 높일 수 있다는 점입니다. 만약 critical section이 매우 짧다면, 다른 스레드가 해당 critical section에 접근하기 위해 대기하는 시간이 길어질 수 있습니다. 이는 락을 기다리는 스레드가 쓰레기 CPU 사이클을 소비하면서 대기해야 함을 의미합니다.

# 특권 명령을 사용하지 않는 구현에서 CPU가 1개 일 때 critical section의 길이를 짧게 하면 CPU 낭비를 줄일 수 있다.
따라서, critical section의 길이를 결정할 때는 CPU 낭비와 Deadlock 사이의 균형을 고려해야 합니다. 적절한 크기의 critical section을 선택하여 CPU를 효율적으로 활용하면서 Deadlock을 피할 수 있도록 해야 합니다.
```











### ticket locks



```
ticket lock은 상호배제(mutual exclusion)를 위한 동기화 기법 중 하나입니다. 다수의 스레드가 임계 영역(critical section)에 접근하는 것을 제어하기 위해 사용됩니다.

Ticket lock은 공정한 대기열(Fair queue) 방식으로 동작합니다. 각 스레드는 번호표(ticket)를 발급받고, 번호표에 따라 순서대로 임계 영역에 진입할 수 있습니다. 스레드가 진입하고자 할 때는 번호표를 발급받고, 대기열에서 자신의 차례가 되면 접근을 허용받습니다.

Ticket lock은 두 개의 변수로 구성됩니다:

ticket 변수: 각 스레드가 발급받은 번호표를 나타냅니다. 이 변수는 atomic 연산을 사용하여 원자적으로 증가시킵니다.

turn 변수: 현재 처리중인 번호표를 나타냅니다. turn 변수는 공유 변수이며, 스레드는 이 변수가 자신의 번호표와 일치할 때만 임계 영역에 진입할 수 있습니다.

Ticket lock을 사용하는 일반적인 절차는 다음과 같습니다:

스레드가 임계 영역에 진입하고자 할 때, ticket 변수에 atomic 연산을 통해 증가시킨 번호표를 발급받습니다.
발급받은 번호표를 이용하여 임계 영역에 진입할 차례인지 확인합니다.
자신의 차례가 될 때까지 spin lock을 사용하여 대기합니다.
차례가 되면 임계 영역에 진입하고 작업을 수행합니다.
임계 영역에서 빠져나오면 다음 번호표로 진입할 차례인 스레드를 허용합니다.
Ticket lock은 각 스레드가 번호표를 순차적으로 발급받고 대기하는 방식으로 동작하기 때문에 공정성을 보장합니다. 그러나 스레드의 수가 많을 경우 번호표가 커질 수 있어 오버헤드가 발생할 수 있으며, 컨텍스트 스위칭 등의 비용이 큰 환경에서는 성능 저하가 발생할 수도 있습니다.
```



```

```







```

```

