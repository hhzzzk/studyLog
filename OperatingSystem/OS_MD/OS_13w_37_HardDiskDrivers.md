# OS_13w_37_HardDiskDrivers

[TOC]





# OS 37 Hard Disk Drives

## (1) 37 Hard Disk Drives - geometry

514페이지

```markdown
현대 하드 디스크 드라이브는 어떻게 데이터를 저장하는가?
인터페이스는 무엇인가?
데이터는 실제로 어떻게 배치되고 접근되는가?
디스크 스케줄링은 어떻게 성능을 개선시킬 수 있는가?

# 37.1 인터페이스
현대 디스크 드라이브의 인터페이스는 기본적으로
읽고 쓸 수 있는 매우 많은 섹터들로 이루어짐
디스크 위의 N개의 섹터들은 0부터 숫자로 이름 붙음
디스크는 섹터들의 배열이고 섹터들은 드라이브의 주소 공간이 됨

__멀티 섹터 작업?__
멀티 섹터 작업 가능
많은 파일 시스템들이 한번엔 4KB나 그 이상을 읽거나 쓴다
  그러나 드라이브는 하나의 512바이트 쓰기만
  원자성(온전히 모두 완료/모두 실패)을 보장함
  즉 갑작스러운 전력 손실 등 발생하면
  대량의 쓰기 중에 일부만 완료됨 == torn write

인터페이스에 명시되지는 않은 __계약불문율__ 이란거 있음
1. 드라이브의 주소 공간에서 가깝게 배치되어 있는 두개의 블럭을 접근하는 것은 
	멀리 떨어진 두개의 블럭을 접근하는 것보다 빠르다고 가정
2. 연속적인 청크의 블럭을 접근하는 것(순차 읽기나 쓰기)이 가장 빠르며
	어떤 랜덤 접근 패턴보다 매우 빠르다는 가정
	
# 37.2 기본 구조

## __플래터__
원형의 딱딱한 표면 가짐
플래터에 자기적 성질을 변형해 데이터를 지속시킴
디스크는 하나 이상의 플래터를 가짐
각각은 2개의 표면surface를 가짐
플래터는 대체적으로 알루미늄 같은 단단한 물질로 만들어짐
__드라이브의 전원이 나가더라도 비트를 드라이브에 영구적으로 저장하기 위해
얇은 자성층이 입혀져있음__
/
플래터는 __회전축spindle__ 으로 고정됨
이 축은 모터와 연결되어 있어 드라이브에 전원이 있으면 플래터를 일정한(고정된) 속도로 회전시킴
회전의 속도는 분당 회전수 rotation per minute, RPM으로 측정됨
보통 7200-15000 RPM
플래터가 한바퀴 회전할 때 걸리는 시간이 중요
예시로 10000RPM이면 한바퀴 회전하는데 6msec 걸림
/
__트랙__
각 표면에 동심원을 다라 배치된 섹터들 위에 데이터가 부호화됨
이때 동심원을 하나를 트랙이라 함
표면surface에는 수많은 트랙들이 서로 촘촘하게 붙어있음
__디스크헤드__
표면 위를 읽거나 쓸때 디스크의 자기적 패턴을 감지(읽기)하거나 변형을 유도(쓰는)하는 기계 장치
각 표면마다 헤드가 하나씩 존재함
디스크 헤드는 디스크 암disk arm에 연결
디스크 암을 통해 헤드가 원하는 트랙 위에 위치하도록 이동가능

# 37.3 간단한 디스크 드라이브
하나의 트랙으로 이뤄진 간단한 디스크 가정
트랙에는 12개의 섹터, 각 섹터는 512바이트, 주소영역은 0-11
모터에 연결된 회전축을 중심으로 플래터가 회전함
디스크 암의 끝에 붙은 디스크 헤드
표면은 시계 반대 방향으로 회전함

	rotation delay : 단일 트랙 지연 시간 : 회전지연 
블럭 0번 읽기
디스크 헤드 아래에 원하는 섹터가 위치하기를 기다리면 됨
이를 rotational delay, rotation delay
만약 한 바퀴를 다 회전하는데 걸리는 회전 지연이 R이면 

	seek time : 멀티 트랙 : 탐색시간
seek 탐색은 디스크 암을 올바른 트랙에 이동시킴. 탐색은 가장 비싼 디스크 동작 중 하나임
디스크 암을 맞는 트랙으로 이동시킴
탐색은 
1. acceleration가속 단계 - 디스크 암 움직이기 시작
2. coasting활주 단계 - 디스크 암이 최고 속도로 움직임
3. deceleration감속 단계 - 디스크 암의 속도가 줄어든다.
4. setting time안정화 단계 - 정확한 트랙 위에 헤드가 위치
		안정화 시간settling time 매우 중요.보통 0.5-2msec 정도로 오래 걸림
탐색 이후 디스크 암은 올바른 트랙 위에 헤드를 위치 시킴

탐색 과정 동안에도 플래터도 회전함

	track skew : 트랙 비틀림
한 트랙에서 다른 트랙으로 전환하는 경우 디스크 헤드를 다시 위치시키기 위한 시간 필요
> 헤드가 다음 트랙으로 넘어갔을 대 다음에 읽어야 하는 블럭이 이미 헤드를 지나칠 수 있음, 이 경우 거의 한바퀴를 다시 돌아야 하는 회전지연 감수해야 함
그래서 같은 라인이 아니라 약간 엇갈리게 블럭을 위치하는?

	multi-zoned : 멀티 구역
바깥 측에 공간이 더 많은 구조적인 이유 때문에 바깥 트랙에는 안보다 더 많은 트랙들있음
디스크들은 여러 구역으로 나뉘어 있으며 한 구역은 표면 위에 연속적으로 존재하는 트랙들의 집합임
각 구역 내의 트랙은 같은 수의 섹터들을 포함, 바깥 쪽 트랙이 안쪽 트랙보다 더 많은 섹터들 가짐

	cache : 캐시 : track buffer
드라이브가 디스크에서 읽거나 쓴 데이터를 보관하는데 사용하는 작은 크기의 메모리 > 캐시
디스크에서 하나의 섹터를 읽을 때 해당 트랙의 모든 섹터를 다 캐시에 저장 가능
이후 같은 트랙에 대한 요청은 캐시를 통해 빠르게 처리 가능함
__읽기는 쉬운데 쓰기에 대한 것 약간..__
쓰기 요청의 경우 선택지 2가지
1. write-back캐싱 > 메모리에 데이터가 기록된 시점에 쓰기가 완료됨 > immediate reporting 즉시 보고
		성능이 더 좋음, 빨라, 그러나 일관성이 없음
2. write-throung캐싱 > 디스크에 실제로 기록되었을 때 완료됨
		성능은 더 느림, 일관성, 안정성이 있음, 정확함

```



##  (2) 37 Hard Disk Drives - IO Time

519페이지

```markdown
# 37.4 IO 시간 계산
T(io = seek + rotation + transfer)
Rio = SIZEtransfer / Tio

# 4KB 랜덤 워크로드 VS 100MB Sequential 워크로드
작은 읽기 요청 발생 vs 헤드의 이동없이 디스크에 연속된 여러 개의 섹터들 읽기 요청

Cheetah는 고성능 드라이브, 가능한 빠르게 회전해 낮은 seek 시간과 빠른 데이터 전송 속도
Barracuda는 저가 대용량 드라이브, 속도는 낮으나 공간에 가능한 많은 비트 저장

1. 랜덤 워크로드, 랜덤한 디스크의 위치에서 4KB씩 읽기 발생하는 경우
평균적으로 디스크는 반 바퀴를 회전해 평균 로테이션 딜레이는 2로 나눔
transfer time = 전송된 데이터 크기를 최대 전송 속도로 나눈 값
Rio = 전송 데이터의 크기를 평균 시간으로 나눔

	결론
1. 랜덤 워크로드와 순차 워크로드의 드라이브 간 성능 차이가 크다.
2. 성능위주의 드라이브와 저사양의 용량 위주의 드라이브 간의 성능 차이가 크다.
> 강의 : 순차 워크로드, 즉 100메가처럼 큰 용량의 요청은 생각보다 치타랑 바라랑 차이가 적다. 
근데 랜덤워크로드, 작은크기의 요청의 경우는 2배가량 고성능이 더 좋다.


@@@ Disk management, 파일 배치를 어떻게 할 것인가?
read하는 경우는 캐시에 써서 빠르게 처리가능
그러나 write하는 경우는 sequential!!!하게 하라 그게 훨씬 빠르다.
불가피하게 랜덤하게 하면 작은 용량으로 하던가..암튼...비추@@@

```

## (3) 37 Hard Disk Drives - Disk Scheduling

```markdown
# 37.5 디스크 스케줄링
(((읽기요청은 캐시사용해서 빠름, 근데 여러 쓰레드에서 쓰기요청한 경우, 그리고 랜덤요청일 경우 순차아니고
메모리에서 스케줄링, 먼저 순서를 조정하고 그리고 넘기면 빨라진다. 순서조정 즉 스케줄링 안한게 FIFO)))

각 작업의 길이가 얼마나 될지 알 수 없는 작업 스케줄링과 다르게
디스크 스케줄링은 디스크 요청 작업이 얼마나 길지 꽤 정확히 에측 가능함
요청의 탐색seek과 회전지연의 정도를 예측하면 디스크 스케줄러가 대략적인 시간 예측함
greedy 방법으로 처리할 수 있는 가장 빠른 요청 선택 가능함
__디스크 스케줄러는 SJF 짧은 작업 우선의 원칙을 따름__

	SSTF : 최단 탐색 시간 우선
		트랙이동최소화

Shortest-seek-time-first, == shortest-seek-first, SSF라고도 함
트랙을 기준으로 IO요청 큐를 정렬해 
가장 가까운 트랙의 요청이 우선 처리되도록 함
예시로 현재 헤드가 안쪽 트랙에 위치함
이때 가운데 있는 트랙의 섹터 21번과 바깥 측의 섹터 2번에 대한 요청받음
> 가운데 있는 트랙이 더 가까움. 21번 먼저 처리함
(((현재 섹터 기준으로 가장 가까운거 처리함!)))
	SSTF의 문제
1. 드라이브의 구조는 호스트 운영체제에게 공개되어 있지 않으며 운영체제는 그저 블럭들의 배열로만 인식함
해결 > SSTF 대신에 NBF, Nearest-block-first, 가장 가까운 블럭 우선 방식 사용
@가장 가까운 블럭 주소에 접근하는 요청을 다음에 처리하도록 스케줄함 >>> 강의에는 일단 없음

2. starvation 문제 !!!
	가까운 애들만 처리하니까 좀 멀리 있는 작업은 계속 뒤로 밀리는
/
	SCAN : 엘리베이터 알고리즘
트랙의 순서에 따라 디스크를 앞뒤로 가로지르며 요청을 서비스함
디스크를 한번 가로지르기 = 밖에서 안/안에서 밖, 하는 것을 sweep
(((양/음의방향으로 끝까지 가는거 한번 그게 스윕임)))

__어떤 요청이 이번 스윕에 이미 지나간 트랙에 대해 들어온다면(다른방향) 바로 처리되지 않고
다음번 스윕(반대방향)에 처리되도록 큐에서 대기,블럭 요청 하나를!!!__

sweep가 양방향임, 끝까지 갔다가 다시 처리하면서 반대방향 끝까지 가고 반복

	F-SCAN
디스크를 스윕하는 동안(한방향으로 가는 동안) 새로운 요청오면
다음 번 서비스 될 큐에 삽입함
현재 요청과 가까이 있지만 늦게 도착한 요청들을 지연시켜 멀리 있는 요청에 대한 기아현상을 줄인다.
(((중간에 다른 방향 요청 들어오면 일단 끊음. 거기서부터 다시 요청들 재정렬. 다음에 실행할 집단)))

	C-SCAN (circular scan)
sweep가 단방향임, 끝까지 갔다가 처리하지 않고 바로 0으로 되돌아오고 다시 방향끝까지 감
그냥 스캔 방향은 가운데 애들, 중간트랙이 우선 처리되는, 우대되는데 
(== 스윕갔다가 돌아오면서 또 중간처리하면서 중간 트랙이 2번서비스 된다.)
__씨스캔은 중간트랙 우대가 덜하다.__

> 그러나 스캔, 엘리베이터 알고리즘 계열들은 회전을 무시함. SJF 원칙에 최선은 아님
```



## (4,5) 37 Hard Disk Drives - Disk Scheduling(2,3)

482페이지

```markdown
	SATF: SPTF : 최단 위치 잡기 우선
shortest positioning time first, SATF라고도 함, !포지셔닝에 따라!
상황에 따라 다르게 작동함
탐색에 걸리는 시간과 회전에 걸리는 시간이 다르다.
seek time vs rotation delay time 비교해서 달라진다.

	IO mergeing
블럭이 연속된 요청이 있으면 스케줄러는 요청을 병합해 두 블럭 길이의 요청으로 만든다
seek time을 줄일 수 있음

```



# OS 37 Hard Disk Drives - Scheduling 



## Disk Scheduling 0

## Disk Scheduling 1

## Disk Scheduling 2

## Disk Scheduling 3





# 퀴즈

```markdown
addr 5, 22, 10
해당 블록 반바퀴 전에서 멈춰야 읽고 쓰는데 30도 써서 종료는 해당 블록 반바퀴 더 간거
시작은 6에서 함
FIFO로 하면 
5로 가면 
	10칸 반, 30*10 + 15
22
	5칸반에서 출발, 4칸 이동, 120이니까 seek 40 빼고 80
10
	22칸반에서 출발, seek는 40이라 트랙 이동하면서 10지나감, 한바퀴 더 돌아야함
	11칸 가야함, 30*11 = 330이고 seek 40빼서 290
	
# 1
SSTF로 바꾸면 트랙이동을 최소화함, 5, 22, 10 순서대로 제일 밖이 0번트랙이면 0, 1, 0 트랙임
6에서 시작하면 10이 5로 가는 것보다 가까움 ??이유 약간 애매
순서가
10, 5, 22로 감

10
	3칸 반, 105이동 읽기, 트랜스퍼 30 = 135
5
 	6칸 이동, 180 + 30 = 210
22
	4칸이동, seek 40 + 80 + 30 = 150
토탈 495
/
5
	10칸 반, 315+30 = 345
10
	4칸, 120 + 30 = 150
22
	11칸, 330 + 30 = 360 
> 855
# 2
SATF로 바꾸면 포지셔닝, seek랑 rotation 시간 차이 비교해서 더 나은걸로 그때그때에 맞게 감
6에서 제일 가까운건 10?22?
10으로 가는건 135
22로 바로 가는건 
	3칸 반, 105인데 이게 seek 40포함임. 토탈 30 transfer더해서 135 둘다 같네...

10 - 22 - 5 아니면 22 - 10 -5인데
뭘해도 seek는 2번 발생함
10 > 135
22 > 11칸, 330 + 30 = 360
//5 > 6칸, 180 + 30 = 210
	705

22 > 135
10 > 290
//5 > 6칸, 180
	토탈 605

# 3
SATF로 하면 22번 먼저 처리된대
정답 2개임

```

