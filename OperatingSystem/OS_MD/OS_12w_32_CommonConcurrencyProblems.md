# OS_12w_32_CommonConcurrencyProblems

[TOC]



# OS, 32 Common Concurrency Problems

462페이지

## 32 Common Concurrency Problems -Non Deadlock Bugs (1/5)

```markdown
# 병행성 관련 버그
# 32.1 오류의 종류
복잡한 병행 프로그램에서 발생하는 문제들
비 교착 상태 오류와 교착 상태(deadlock) 오류

# 32.2 비교착 상태 오류
__atomicity violation(원자성 위반)____order violation(순서 위반)__

	원자성 위반
((다수의 메모리 참조 연산들 간에 있어 예상했던 직렬성 （serializability） 이 보장되지 않았다（즉, 코드의 일부에 원자성이 요구되었으나, 실행 시에 그 원자성이 위반되었다))

해결 > 공유 변수 참조 앞 뒤에 락을 추가

	순서위반
((두 개의 （그룹의） 메모리 참조 간의 순서가 바뀌었다（즉, A가 항상 B보다 먼저 실행되어야 하지만 실행 중에 그 순서가 지켜지지 않았다))

해결 > 순서를 강제, 이러한 종류의 동기화에는 컨디션 변수 적절
쓰레드 간의 순서가 문제가 된다면 컨디션 변수（또는 세마포어）를 사용하여 해결
```

//

## 32 Common Concurrency Problems -Deadlock Bugs(1) (2,3/5)

```markdown
# 32.3 교착 상태 오류
락 L1 을 갖고 있는 쓰레드 1 이 또 다른 락 L2를 기다리는 상황에서 불행하게도 락 L2를 갖고 있는 쓰레드 2가 락 L1 이 해제되기를 기다리고 있을 때 교착 상태가 발생

((각 쓰레드가 상대방이 소유하고 있는 락을 대기하고 있기 때문에 누구도 실행할 수 없게 
된다))
- 사이클(cycle)의 존재는 교착 상태 발생 가능성을 의미

	왜 발생하는가
1. 코드가  많아지면서 구성 요소 간에 __복잡한 의존성__이 발생하기 때문
2. 캡슐화(encapsulation) 의 성질
	모듈화와 락은 잘 조화되지 않는다
.
	발생조건
네가지 조건 충족
1. Mutual Exclusion 상호배제
2. Hold-and-wait 점유 및 대기
3. No preemption 비선점
4. Circular wait 순환 대기

1. 쓰레드가 자신이 필요로 하는 자원에 대해 독자적인 제어권 주장(락획득)
2. 쓰레드가 자신에게 할당된 자원을 점유한 채로 다른 자원을 대기
3. 자원을 점유하고 있는 쓰레드로부터 자원을 강제적으로 빼앗을 수 없다.
4. 각 쓰레드는 다음 쓰레드가 요청한 하나 또는 그 이상의 자원을 갖고 있는 쓰레드들의 순환 고리가 있다.

네 가지 전부 만족해야 데드락 발생

	데드락의 예방 - 4가지 중 하나만 막아도 데드락 발생 안함
4 > 순환 대기가 발생하지 않도록 락에 관련된 코드 작성
1. total ordering를 정함, 전체 순서 정함
2. partial ordering 부분순서 정함

2 > 원자적으로 모든 락을 한번에 획득하도록 함
> 락을 획득하는 과정 중에 쓰레드의 문맥 교환이 발생하는 것을 방지하고
> 데드락의 발생 가능성 차단
문제 : 필요한 락들을 정확히 파악하고 그 락들을 미리 획득해야함
실제 필요와 무관하게 단번에 락들을 획득해 병행성 저하

//
3 > 락을 한번 획득하면 명시적으로 반납하기 전까지는 락을 보유함
> 락이 획득 가능하면 락을 획득하고 성공을 나타내는 코드를 반환하거나, 락이 점유되었다는 것을 나타내는 에러 코드를 반환
> 새로운 문제, livelock, 무한반복 문제
> 471페이지

1 > 상호 배제 자체를 없애기
> lock-free __락이 없는__, 그래서 연관된 wait-free 대기 없는 자료구조
> compare-and-swap 예제
> 락을 획득하여 값을 갱신한 후에 락을 해제하는 대신, CAS 명령어를 사용해 값에 새로운 값을 갱신하도록 반복시도
> 락을 획득할 필요 없어짐, 교착 상태 발생하지 않음, 472페이지

```

## 32 Common Concurrency Problems -Deadlock Bugs(3) (4/5)



```markdown
세마포어 부분
# 31.6 Dining 철학자, 식사하는 철학자
다섯 명의 철학자 식탁 주위로 앉음
5개의 포크가 철학자 사이에 하나씩 있음
철학자는 식사/생각 을 할 수 있음
생각 중이면 포크 필요없음
자신의 왼쪽과 오른쪽에 있는 포크를 들어야 식사 가능
> 이 포크를 잡기 위한 경쟁과 그에 다른 동기화 문제

각 철학자는 0-4까지 고유한 쓰레드 식별자 p 가짐
get포크와 put포크의 루틴을 작성하되 교착 상태를 방지해야 하고 굶주미녀 안되고 병행성이 높아야함(최대한 많은 철학자가 동시에 식사해야 함)

# 해결
left, right 함수 이용, 호출하면 그쪽의 포크를 잡기 원한다는 의미

# 불완전한 해답
첫번째 시도
각 포크마다 한 개씩 총 5개의 세마포어 존재
포크 배열에 있는 세마포어 다 1로 초기화
각 철학자는 자신의 순번 알고 있음
루틴 작성 가능

포크가 필요할 때 하나의 락을 획득
먼저 왼쪽 잡고 오른쪽 잡음
식사 끝나면 잡은 순서대로 놓음

__교착상태 문제__
각 철학자가 자신의 왼쪽 포크를 다른 철학자가 오른쪽 포크 잡기 전에 잡으면
각 철학자는 하나의 포크만 가지고 평생 기다려야 함

__해결:의존성 제거__
최소한 하나의 철학자가 다른 순서로 포크를 집도록 하기
가장 높은 순번의 철학자 4가 포크를 다른 순서로 획득

환형 대기 상태 끊기

```



## 32 Common Concurrency Problems -Deadlock Bugs(4) (5/5)

```markdown
# 데드락 avoidance, 회피
예방 prevention 말고 회피하는 방법도 가능
실행 중인 여러 쓰레드가 어떤 락을 획득할지에 대해 전반적으로 파악해야 함
정보를 바탕으로 쓰레드들을 스케줄링해서 데드락 회피 가능

겹치는 쓰레드가 있는 쓰레드들끼리 동시에 발생하지 않도록 적절히 스케줄링

그러나 성능이 떨어질 수 있음, 한쪽만 몰리는 경우 발생 가능

# Banker's 알고리즘
아래에서 함
```



# Condition Variable with Semaphore





# ConVarSem-문법 설명 (1/1)



# OS, 32 Common Concurrency Problems(2) (1/1)







# 퀴즈

## Deadlock

- Non Deadlock 비교착상태오류

  1. atomicity  violation, 원자성 위반
     - 실행하면서 원자성 안지켜짐, 공유변수 앞뒤에 락 추가해서 해결 가능
  2. order 위반, 순서 위반
     - 실행 순서 안지켜짐, 순서를 강제하는 컨디션 변수나 세마포어 사용해 해결

- Deadlock 교착상태오류

  - 각 쓰레드가 상대방이 소유한 락을 대기하면서 누구도 실행할수없는 상태

  - 네가지 조건 충족해야 함. 데드락 해결하려면 네 개 중에 하나만 해결해서 데드락 예방 prevention

    1. 상호배제 - 락획득

       해결 : lock-free 락을 아예 없애버림, wait-free 대기도 없음

    2. 점유 및 대기, 홀드앤웨잇 - 락가지고 대기

       해결 : 원자적으로 모든 락을 한번에! 획득하도록

    3. 비선점, no preemption - 강제로뺏기

       해결 : 락을 획득/점유 나타내는 코드 추가 > livelock 새로운문제, 무한반복

    4. 순환대기, 써큘러 웨잇

       해결 : 전체순서 정하거나 부분 순서 정해서 순환대기가 발생하지 않도록

  - 데드락을 avoidance회피하는 방법으로 데드락 해결도 가능함

    - 쓰레드들이 어떤 락을 획득할지 전반적인 내용 알고 쓰레드를 적절히 스케줄링하기



```markdown
# 케이스1
순서 결정, 4번 순환 고리 끊기
# 케이스2
동시에 락 획득, 원자적 락 획득 2번홀드앤웨잇
# 케이스3
락을 사용 안함, 1번, 상호배제 없애기, 락을 없애는게 wait free임
# 케이스4
무한루프, 3 > 락을 한번 획득하면 명시적으로 반납하기 전까지는 락을 보유함
```



## ConvarSem

