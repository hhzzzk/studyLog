# OS_14w_39,40_FilesAndDirections_FileSystem

[TOC]



# [OS, 39 Interlude: Files and Directories]

## 1. File System Overview

552페이지

```markdown
persistent storage라는 영속 저장 장치라는 가상화에 있어 중요한 개념 다룸
하드 디스크 드라이브나 최근의 솔리드스테이트 드라이브 (solid-state storage, SSD)와 같은 저장 장치는
__영구적으로 정보를 저장함. == 전원 공급이 차단되면 내용이 사라지는 메모리와 다르게 데이터 보존함__
그런 영속 장치를 어떻게 관리하는가?

# 39.1 파일과 디렉토리
저장 장치의 가상화에 대한 주요 개념 두가지
1. 파일
	파일은 단순 읽거나 쓰는 순차적인 바이트의 배열
	각 파일은 low-level name 가짐 보통 숫자로 표현하지만 사용자는 그 이름에 대해 모름
	이 로우레벨 이름은 inode number이라고 함 - 아이노드
	
	운영체제는 파일의 구조를 모름, 어떤 파일이 그림/문서/c코드인지 모름
        파일 시스템의 역할은 그러한 데이터를 디스크에 안전하게 저장하고
        데이터 요청시 저장한 데이터 리턴

2. 디렉토리
	파일처럼 로우레벨 네임, 아이노드 번호 가짐
	파일과는 달리 디렉토리의 내용은 구체적으로 정해져있음
	디렉토리는 <사용자가 읽을 수 있는 이름, 로우레벨네임> 쌍으로 이루어진 목록을 가짐
	예시로 <foo, 10>
	디렉토리의 각 항목은 파일 또는 다른 디렉토리 가리킴
		디렉토리 내에 다른 디렉토리를 포함하는 방식으로
		사용자는 모든 파일들과 디렉토리들이 저장된 임의의 디렉토리 트리/계층을 구성가능함
			## 디렉토리 계층
            	루트 디렉토리(/)부터 시작해 원하는 파일이나 디렉토리의 이름을 표현할 때까지 
            	구분자, separator을 사용해 하위 디렉토리 명시함 (/home/foo/bar.txt)
            		대부분 마지막의 bar.txt의 txt는 파일의 종류 나타냄. 
            		그러나 관용적인 것으로 반드시 그러한 것은 아님
            		
# 39.2 파일 시스템 인터페이스
파일의 생성과 접근, 삭제 등

# 39.3 파일의 생성
open()(1,2,3,4,5) 여러 인자 받음
	open의 리턴값이 중요함

__파일 디스크립터는 프로세스!마다 존재하는 정수__로 열린 파일을 읽고 쓰는데 사용

```

강의

```markdown
파일을 식별할 때 PATH 사용, 경로는 유니크하다
open하면 파일 디스크립터 번호가 부여된다.

__프로세스마다 파일 디스크립터 테이블 존재한다__
테이블의 0,1,2는 스탠다은 in,out,err을 위해 할당됨

__open은 사람이 본 path를 프로세스가 보는 디스크립터 넘버로 변환하는 것임__

---

커널에 open file table 존재함, offset을 이용해 물리적인 파일 위치 찾아가기 가능함
또 i-node table도 존재함, i-num을 통해 HDD/SSD에서 물리적 위치를 식별가능하다.

__사람 :경로 >>> 프로세스 : 디스크립터 넘버 >>> 하드 : 아이넘버__
같은 건데 누구의 입장에서 보느냐에 따라 전환하는
(((사람이 인식하는 경로를 프로세스에서 파일 디스크립터 번호로 변환한 후, 프로세스의 파일 디스크립터 테이블을 통해 파일에 접근하고, 해당 파일의 아이노드를 아이노드 테이블에서 찾아가는 과정으로 파일에 접근이 이루어집니다.)))


# 파일을 보는 VIEW : User vs System
유저가 볼 때는 durable data structure
시스템(시스템콜 인터페이스)이 볼 때는 바이트들의 집합
시스템(OS)가 볼때 블락 단위의 집합임
블록은 논리적 유닛이고 섹터는 물리적 유닛임
블록은 여러 개의 섹터로 구성됨
섹터는 512바이트고 __섹터 단위는 atomic하게 전부 읽거나 하나도 안읽거나 두 개의 상태만 존재함.__
블록은 4KB

__논리적으로 읽고 쓰는 단위는 블록 단위임__

(((블록은 파일 시스템의 논리적인 단위로서 파일의 데이터를 관리하기 위해 사용되며, 섹터는 하드 디스크의 물리적인 단위로서 데이터를 저장하고 접근하는 데 사용됩니다. 블록은 섹터를 포함하는 개념이며, 파일 시스템은 섹터 단위로 하드 디스크와 상호 작용하여 데이터를 읽고 쓰는 작업을 수행합니다.)))
---

메타데이터, i-node는 Head에 저장,
	크기 작아서 하나의 헤드에 여러 메타데이터 저장 가능함


테이블 순서가
프로세스의 파일 디스크립터 테이블 >>> 오픈 파일 테이블 >>> 아이노드 테이블 >>> 찾던 블럭 찾기

((( 파일을 찾을 때는 먼저 파일 디스크립터 테이블에서 해당 파일 디스크립터를 찾고, 이를 사용하여 오픈 파일 테이블에서 파일 정보를 얻습니다. 그리고 오픈 파일 테이블에서 얻은 아이노드 번호를 사용하여 아이노드 테이블에서 해당 파일의 아이노드 정보를 찾습니다. 이를 통해 파일에 대한 실제 정보와 데이터에 접근)))


영속성 때문에 아이노드 테이블도 하드에 있고

물리적 공간에 파일도 있고 디렉토리들도 존재하는데 이런게 파일시스템임
물리적 공간에서 파일과 디렉토리를 구분할 필요가 없음

"." == 자기자신
".." == 부모

디렉토리는 자기자신과 부모, 자식들을 관리함. 트리 같은

# 장치
파일 시스템은 경로를 이름으로 본다.
장치도 이름이 필요함
경로 하나를 장치로 사용함. ㅇ때 디렉토리 끝에 파일, 즉 경로가 있어야 함
이런 장치는 블럭이 필요가 없어 head만 있으면 된다. 

__device, pipe, socket가 블럭 필요없이 헤드만 있어도 되는 것들임__
```



## 2. Interlude: Files and Directories - File

강의

```markdown
파일 시스템콜들 

파일에 이름을 부여하자 PATH 사용
반복개중요@@@PATH에서 open해서 파일 디스크립터 부여하고 거기서 inode로 가면 비로소 물리 공간에서 엑세스가 가능해진다.

디렉토리는 이름과 inode를 매핑한것. 디렉토리 계층구조로 생기게 되는데 따라가면 맞는 inode로 가는

# open
경로를 디스크립터 넘버로 바꾸는 것
flag 인자로 줌

# read/write
바이트 단위, fd를 offset으로 사용
write에서 cat foo 동작과정 보기

​```
echo hello > foo
cat foo
>>> hello
/
  strace cat foo
  ...
  open("foo",)				=3 > fd임
  read(3, "hello\n", 4096)	=6
  write(1, "hello\n", 6)		=6
  >>> hello
  read(3, "", 4096)			=0
  close(3)					=0
/
4096이 4KB임
0,1,2는 사용중이고 다음인 3을 리턴받고
읽을게 6바이트임
6바이트 읽고 아래는 다 공백임
write에서 첫번째 인자 1은 stdout, ((012는 첨부터 할당된 스탠다운 in,out,err))
/


fp 파일 포인터
순차 아닌데 랜덤 위치로 이동하면 __lseek__라는 시스템콜 사용함

# fsync()
DRAM과 DISK의 속도 차이 어마어마함
write할때 딜레이 생김. dirty data 관리. 보통 5-30초마다 업뎃하는 방식 씀
딜레이된 write. 적힌 정보는 30초전의 정보임
그러나 __민감한 프로그램은 즉각적으로 써야할 필요 있음__
이 때 fsync사용. 정말 민감한 프로그램은 data뿐만 아니라 디렉토리도 fsync해줘야 함

- mv foo bar > 파일 이름 바꾸기는 atomic하게 진행해야함. 이전이름과 현재바뀐 이름 동시에 존재하면 안됨. fsync사용

- 파일 지울 때 unlink 사용

- 메타 정보 읽어올때 stat 시스템콜 사용. fstat도 있음
구조체, 시스템콜, 또 어떤거해서 3가지 존재함
```

## 3. Interlude: Files and Directories - Directory

강의

```markdown
mkdir로 디렉토리 생성

rmdir로 디렉토리 삭제

ls로 디렉토리 리스트 확인 가능

opendir
readdir
closedir
디렉토리 용으로 따로 존재함

writedir은 없음! 

dirent라는 구조체에 디렉토리 정보 있음 참조함

# Hard Links
Link는 물리적으로 같은 곳을 가리킴. 즉 __아이넘버가 같아지는 새로운 파일이름__을 만들어줌
<<< 		__ln file file2__

파일과 파일2는 물리적으로 같은 공간 가리킴

위에서 물리공간에 해당하는 아이넘버 위치의 __아이노드 Link count가 증가__함.
rm file을 해도 file2는 남아있음

rm은 unlink고 링크카운터를 감소시킨다.

감소시켜도 아직 해당 아이노드의 링크카운터는 1이고 0이 아니므로 삭제되지 않고 존재한다. 

# Symbolic link
바로가기와 유사.
<<< 	__ln -s__
새로운 경로 생성, 포인터가 생기는 거임 하드링크는 물리적으로 둘다 같은 공간 가리키는데 다름
아이넘버가 새로 생김
그래서 rm하면 에러, 공백이 된다.

# mounting
서로 다른 계층을 하나의 계층으로 합치는. 단일계층화 시킴

```



# [OS, 40 File System Implementation]

580페이지

```markdown
very simple file system, VSFS라는 간단한 파일 시스템 구현해보자

파일 시스템은 이전에 다룬 CPU 가상화, 메모리 가상화 부분과 다르게 
__순수한 소프트웨어__임

	이전 가상화에서는 하드웨어가 필요함. (특권모드로의 변환이나 페이징 위한 것 등)

# 40.1 생각하는 방법
2가지 측면에서 파일 시스템 공부하기
1. 파일 시스템의 자료 구조
		우리가 하는건 블럭과 배열 같은...실제로는 트리 기반의 자료 구조 씀
		어떻게 파일들을 관리하는가
		
2. 접근 방법 access method
		프로세스가 호출하는 open, read, write 등의 명령들은 어떻게 동작하는가?
		파일들에 어떻게 접근하는가
		
# 40.2 전체 구성
디스크를 블럭 단위로 나누기
블럭은 보통 4KB 크기
디스크 파티션 구조는 블럭들이 N개 배열처럼 있음

	사용자 데이터가 있는 디스크 공간을 데이터 영역이라고 함

파일 시스템은 각 파일에 대한 정보를 관리함. 그 정보가 __메타데이터__의 핵심
(파일을 구성하는 데이터 영역 안의 데이터 블럭들과 파일 크기, 소유자, 접근 권한, 접근과 변경 시간 등)

파일 시스템은 이 정보를 __아이노드__라는 자료 구조에 저장함
	((메타데이터를 아이노드에 저장))

# 아이노드
아이노드들의 저장을 위해 디스크 공간 필요
이 영역이 __아이노드 테이블__

아이노드는 일반적으로 128-256바이트로 그렇게 크지 않음
아이노드가 256바이트면 4KB 블럭에는 16개의 아이노드 저장 가능

# 할당 구조 allocation structure
각 블럭이 현재 __사용 중인지 아닌지__ 표현하는 할당 구조가 필요하다.
다양한 방법 존재
free list를 사용해 사용 중이 아닌 블럭들을 링크드 리스트 형태로 관리
아이노드는 첫번째 프리 블럭의 위치만 기억하면 됨
다음 프리 블럭의 위치는 각 프리 블럭에서 정해진 위치에 기록
__비트맵__사용

--데이터 영역--에 있는 블럭들의 사용여부를 표현하기 위해 --데이터 비트맵--을
--아이노드 테이블--에 있는 아이노드들이 사용 중인지를 나타내기 위해 --아이노드 비트맵-- 사용

비트맵은 비트들의 배열
각 비트는 해당 블럭이나 객체==아이노드가 사용중인지 아닌지 나타냄

# 슈퍼블럭
파일 시스템 __전체__에 대한 정보 = 파일 시스템에 몇 개의 아이노드와 데이터 블럭 있는가,
아이노드 테이블은 어디에서 시작하는지 등의 정보 가짐

파일 시스템을 식별할 수 있는 매직 넘버도 갖고 있음 vsfs

파일 시스템이 깨진다는 것은 슈퍼블럭이 저장된 디스크 블럭이 훼손되는 것
일반적으로 대부분의 파일 시스템은 슈퍼블럭을 몇 개 복사해둠

# 마운트
파일 시스템을 마운트할 때
운영체제는 우선 슈퍼블럭을 읽어 파일 시스템의 여러 요소 초기화하고
각 파티션을 파일 시스템 트리에 붙임
>>>
디스크 볼륨에 잇는 파일들을 접근할 때
해당 파일을 읽거나 쓰는데 필요한 자료 구조의 위치를 파악함

# 40.3 파일 구성 : 아이노드
아이노드는 인덱스 노드의 줄임말
각 아이노드는 숫자, 아이넘버로 표현됨, 이게 파일의 low-level name
vsfs에서는 아이넘버를 사용해 해당 아이노드가 디스크 상에 어디있는지 직접적 계산 가능

아이노드 테이블 20KB(4KB * 5개)

	슈퍼(4) | 아이노드 비트맵(4) | 데이터 비트맵(4) | 아이노드 테이블(20KB)
	
32번 아이노드 있는 블럭 읽기
섹터 주소
>>> 아이노드 테이블 20KB = 1024 * 20
	이걸 512로 나누면 40이 나옴. 40블럭에  ????
(((디스크는 바이트 단위 접근 불가능, 
읽을 수 있는 제일 작은 단위가 섹터==512바이트, atomic하게 읽기가능)))


/
아이노드에는 파일에 대한 정보 들어있음 : 파일의 종류, 크기, 할당블럭수, 보호 정보, 데이트 블럭 위치를 가리키는 포인터 겸 등등
이러한 정보들이 메타데이터, 사용자 데이터가 아닌 기타 정보를 통틀어 메타데이터라 함

## 아이노드에서 데이터 블럭 위치 표현하기
간단한 방법은 아이노드 내에 여러개의 direct pointer를 두는 것임
각 포인터는 파일의 디스크 블럭 하나를 가리킴
그러나 이방법은 파일 크기의 제한이 있음. 파일 크기는 (포인터개수 * 블럭크기)로 제한됨


# 멀티 레벨 인덱스
큰 파일을 지원하기에는 direct 포인터로는 부족함.
__간접 포인터__indirect pointer 사용
간접 포인터는 데이터 블럭을 가리키지 않고
간접 포인터가 가리키는 블럭에 데이터 블럭을 가리키는 포인터들이 저장됨
직접 포인터와 간접 포인터를 결합해 사용

- 아이노드에는 정해진 수의 직접 포인터(보통 12개)와 하나의 간접 포인터 있음

큰 파일에 대해서는 데이터 블럭의 간접 블럭이 할당, 아이노드의 간접 포인터는 이 간접 블럭 가리킴
블럭이 4KB이고 디스크 주소가 4바이트면 1024개의 포인터 추가 가능함(4*1024 / 4), 포인터당 4바이트 크기

__이중 간접 포인터__ 사용하면 파일은 4KB * 1024 * 1024라 

## 이런 구조를 갖게 된 이유, 삼중 포인터까지 막 사용하는
이런 비대칭적 트리구조?
1. 대부분 파일 크기가 작음 - 보통 2KB
	대부분 파일 트리가 작다면 작은 파일을 빠르게 읽고 쓰는 파일 구조 필요.
	VSFS의 아이노드는 첫 12개의 블럭들을 빨리 읽도록 12개의 직접 포인터 가짐.
	큰 파일들을 위해 하나이사의 간접 포인터 사용하는 간접블럭 필요
2. 평균 파일 크기가 커지ㄴ고 있음
3. 큰 파일들이 대부분의 용량 차지함
4. 파일 시스템에는 많은 파일들이 있음
5. 파일 시스템은 대략 반쯤 사용됨
6. 디렉토리의 크기가 대체적으로 작음

```



## 1. 40 File System Implementation(1)

- 디스크는 블럭 단위로 구성됨
- 1블럭은 4KB고 읽고 쓰는 단위는 512바이트의 섹터 단위로 Atomic하게 이뤄짐
- 보통 1블럭은 8개의 섹터임

(물리적으로 섹터단위, 논리적으로 블럭 단위)

아이노드가 1블럭 안에 배열처럼 존재하고 이때 사용하는 아이노드의 idx가 아이넘버다.



​	\__**구성**

슈퍼블럭 - 아이노드비트맵 - 데이터 비트맵 - 아이노드 - 데이터 블럭

- 슈퍼블럭은 0번 idx, 메타데이터로 파일 시스템당 1개임
- 아이노드가 헤드 역할, stat으로 정보 꺼내올 수 있음
- 직접 포인터 12개
- 간접 포인터 블럭 존재하고 따라가면 데이터 있음
- 이중 간접 포인터도 존재.
- 이를 이용해 큰파일 감당함



## 2. 디렉토리 구성과 free space 관리	

​	디렉토리 구성과 free space 관리	

디렉토리 <filename , i-num>

- 빈공간 비트맵으로 관리



## 3. Access Paths : Reading and Writing

40.6

​	Access Paths : Reading and Writing

/foo/bar인 path를 따라가기

디렉토리 구조 확인했던 /foo/bar인 거임

루트에서 foo찾기

​	맞는 블럭가서 i-num찾고...

bar까지 가면 메타데이터(마지막으로 엑세스한 시간) 업데이트하려고 write

```
파일 시스템에서 "/foo/bar"와 같은 경로를 액세스하는 과정은 다음과 같이 이해할 수 있습니다:

1. 파일 시스템 루트 디렉토리: 파일 시스템의 가장 상위 디렉토리로, 모든 경로는 이 루트 디렉토리를 기준으로 합니다. 일반적으로 루트 디렉토리는 "/"로 표시됩니다.

2. 블록과 아이노드: 파일 시스템은 데이터를 블록이라는 고정 크기의 조각으로 저장합니다. 블록은 디스크 상의 연속된 영역에 할당됩니다. 각 파일 및 디렉토리에는 해당 파일 또는 디렉토리의 메타데이터를 저장하는 아이노드가 있습니다. 아이노드는 파일의 권한, 소유자 정보, 파일 크기 등을 포함합니다.

3. 경로 구성: "/foo/bar"는 루트 디렉토리인 "/"에서 시작하여 "foo"라는 디렉토리를 포함하고, 그 안에 "bar"라는 파일 또는 디렉토리를 가리킵니다.

4. 경로 탐색: 경로를 탐색하여 해당 파일이나 디렉토리를 찾습니다. 루트 디렉토리부터 시작하여 각 디렉토리를 차례로 탐색합니다.

5. 블록 액세스: 먼저 루트 디렉토리의 아이노드를 찾습니다. 아이노드에는 블록 주소가 포함되어 있습니다. 해당 블록에는 루트 디렉토리의 내용이 저장되어 있습니다.

6. 디렉토리 엔트리 탐색: 루트 디렉토리의 블록에서 "foo"라는 디렉토리를 찾습니다. 이 디렉토리도 아이노드를 가지고 있으며, 해당 아이노드의 블록을 찾습니다.

7. 다시 디렉토리 엔트리 탐색: "foo" 디렉토리의 블록에서 "bar"라는 파일 또는 디렉토리의 아이노드를 찾습니다.

8. 파일 액세스: "bar" 파일의 아이노드를 찾았다면, 해당 아이노드에는 파일의 메타데이터와 데이터 블록의 주소 등이 포함되어 있습니다. 이를 통해 파일을 읽거나 쓸 수 있습니다.

요약하자면, 경로 "/foo/bar"의 액

세스 과정은 루트 디렉토리부터 시작하여 각 디렉토리를 탐색하고, 파일이나 디렉토리의 아이노드를 찾아 해당 파일의 메타데이터와 데이터 블록을 액세스하는 과정으로 진행됩니다. 이를 통해 파일 시스템은 정확한 파일 위치를 찾고 파일을 읽거나 쓸 수 있게 됩니다.
```





## 4. Access Paths : Create, R/W 





## 5. 캐싱, 버퍼링

40.7



## 6. VSFS Example

아이노드 개수, 데이터 블럭 개수

inodes

​	d로 시작하는건 디렉토리, 최초 디렉토리는 .0, ..0으로 2개의 link count 가짐, r:2

​	a는 address, data의 idx

create

​	루트 밑에 만든다. 만들면 블럭을 할당하지 않았으므로 a, address는 -1임. 

​	data의 0번째 idx에 있는ㄴ건...디렉토리, (y,1) > 아이노드의 1번에 y가 있다는

open

​	오픈하면 블럭이 할당됨. address가 업뎃됨. 데이터 블럭 새로운 곳에 머써짐

link( old, new)

​	 new를 추가해서 old 가리키는게 두개되는

​	old가 가리키던 아이노드의 링크카운트 증가

​	new가 디렉토리 추가되서 그것도 해당 아이노드 가리킴

unlink

​	가리키던 아이노드 링크카운트 감소, 해당 디렉토리 삭제

mkdir

​	디렉토리 생성

​	빈첫번째 데이터 블럭에 디렉토리 생성, (.아이노드번호) (..0) 두개 링크카운트 해당 아이노드에 2.



​	

